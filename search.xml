<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>&lt;&lt;历代经济变革得失&gt;&gt;读后感</title>
    <url>/2017/03/21/2017-03-21-History-Book/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;偶然之间听说一本名为《历代经济变革得失》的书籍，虽平时很少关心时政，了解经济；但人活于世，总是需要知道一些前人历尽千辛万苦以及无数生命总结的道理，好以后按图索骥。   </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;看完本书之后的最大的感悟就是“兴，百姓苦；亡，百姓苦”；社会顶层人的奇思妙想以及各种治国大道，对于百姓来说都是苦难，只是苦难深浅而已。按照本书总结的各种道理与经验，仿佛一切都是在循环往复。希望能通过本书发现特定的规律能从中受益，发现一切都是枉然，未来的不确定是无法预料的。但是还是有所收获，至少我总结不出来这些得失，也听闻了之前不曾听闻的轶事。  </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;阅读本书还有一个感触就是之前按照学校学的历史，以及对历史人物的了解是那样的片面；按照书中的说法一切都是为统治以及稳定服务，这样的历史书不可信。何况对于历史人物的了解的确也不能从历史书中简短的评价去概况一个人。对一个人的评价也适用于同样的道理。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;感觉书中对王安石评价的一段非常有意思的文字，分享给大家：</p>
<blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;这个人才华横溢，诗文独步天下，是公认的”唐宋八大家“之一。他读书很多，自诩读遍天下所有的书。他辩才无碍，讲起《周礼》，举朝无人比他更烂熟于心。他把司马光，苏东坡等人整得很惨，可是没有人敢说自己才华比他。他还是个非常能干的官员，很懂财经之道，当官不靠后台，科举出身，从县一级干起，当过知县、通判，一直干到中央。他对所有的行政关节非常熟悉，谁都骗不了他。</p>
</blockquote>
<blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;他不修边幅，不通人情。宋朝是士大夫之国，大家都穿得很体面，彬彬有礼，偏偏这个王安石不洗头，不剃须，每天身上很臭地来上朝，还整天死着一张脸，同僚都叫他“拗相公”。他不拉帮结派，独来独往，跟任何人都没关系。更要命的是，他不贪色、不爱财。中国传统思想中，一个坏官必会犯这两条，可是王安石一条都不沾。他节俭清廉，视富贵如浮云，每次发官响，总是拎了一袋子钱回家，数也不数就上缴给妻子。他还终生不纳妾，在风流开放的宋代文人中绝无仅有。他当然不通敌、不卖国，是一个国家利益为上的爱国主义者。</p>
</blockquote>
<blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;这样一个道德高尚、百毒不侵的人，勤勤恳恳，日以继夜地把国家搞亡掉了，你怎么评价他？</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;这样一个与众不同的人的确不好评价他。只希望能从他身上得到经验教训。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;看完此书之后，还有一个感触自己之前看关于历史社科类的书太少了；大多数是技术类书籍，这样的确有碍于自己对事情的看法与理解，不能更好的形成更加客观，全面的观点。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在以后需要多看书。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>dumpsys介绍</title>
    <url>/2017/04/18/2017-04-18-Performance-dumpsys/</url>
    <content><![CDATA[<h1 id="1-概要"><a href="#1-概要" class="headerlink" title="1. 概要"></a>1. 概要</h1><p><code>dumpsys</code>是Android提供的系统工具，可以用来查看所有系统服务的信息。</p>
<p>在命令行输入如下命令，就可以罗列出当前所有的系统服务名：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb shell dumpsys -l</span><br><span class="line">Currently running services:</span><br><span class="line">  ...</span><br><span class="line">  SurfaceFlinger</span><br><span class="line">  ...</span><br><span class="line">  activity</span><br><span class="line">  alarm</span><br><span class="line">  ...</span><br><span class="line">  battery</span><br><span class="line">  batterystats</span><br><span class="line">  ...</span><br><span class="line">  meminfo</span><br><span class="line">  ...</span><br><span class="line">  window</span><br></pre></td></tr></table></figure>

<p>如果<code>dumpsys</code>不追加任何参数，则会输出所有系统服务的详细信息，输出的内容是非常多的。实际解决具体问题时，我们通常只关注一些特定系统服务的输出，<br>只需要将服务名作为<code>dumpsys</code>命令的参数，就可以只输出特定服务的信息。譬如要输出磁盘使用的统计信息，则可以将<strong>diskstats</strong>这个系统服务名作为参数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb shell dumpsys diskstats</span><br><span class="line">Latency: 0ms [512B Data Write]</span><br><span class="line">Data-Free: 6589272K / 12258876K total = 53% free</span><br><span class="line">Cache-Free: 337720K / 420552K total = 80% free</span><br><span class="line">System-Free: 306024K / 1523568K total = 20% free</span><br></pre></td></tr></table></figure>

<h1 id="2-工作原理"><a href="#2-工作原理" class="headerlink" title="2. 工作原理"></a>2. 工作原理</h1><p><code>dumpsys</code>是Android上的一个二进制程序， 在命令行输出<code>adb shell dumpsys xx</code>命令，会通过<strong>adb</strong>将<strong>dumpsys xx</strong>发送到移动设备执行<br>(<strong>adb的工作原理可以参见<a href="/2017-05-03-Intro-adb">adb介绍</a>一文</strong>)，<br>收到<strong>dumpsys xx</strong>指令后，<code>dumpsys</code>这个二进制程序就开始工作了，<code>dumpsys</code>本身只提供一个输出框架，具体的输出内容还是交由实际的系统服务完成。</p>
<p>下图是<code>dumpsys</code>的工作原理：</p>
<div align="center"><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Test/1-2017-04-18-Performance-dumpsys.png" alt="dumpsys工作原理"/></div>

<h2 id="2-1-dumpsys的代码逻辑"><a href="#2-1-dumpsys的代码逻辑" class="headerlink" title="2.1 dumpsys的代码逻辑"></a>2.1 dumpsys的代码逻辑</h2><p><code>dumpsys</code>由<a href="/platform/frameworks/native/+/master/cmds/dumpsys/dumpsys.cpp">frameworks/native/cmds/dumpsys/dumpsys.cpp</a>这个文件中编译得到。<br>我们截取该文件主要的代码片段来分析一下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 1. 首先获取 servicemanager</span></span><br><span class="line">    sp&lt;IServiceManager&gt; sm = defaultServiceManager();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 2. 进行命令行参数解析</span></span><br><span class="line">    <span class="keyword">bool</span> showListOnly = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> ((argc == <span class="number">2</span>) &amp;&amp; (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"-l"</span>) == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// 2.1 当参数仅为 "-l" 时，设置只罗列出所有的服务名</span></span><br><span class="line">        showListOnly = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((argc == <span class="number">1</span>) || showListOnly) &#123;</span><br><span class="line">        <span class="comment">// 2.2 当不带任何参数时，则附加 "-a" 参数，表示输出所有系统服务信息</span></span><br><span class="line">        services = sm-&gt;listServices();</span><br><span class="line">        services.sort(sort_func);</span><br><span class="line">        args.add(String16(<span class="string">"-a"</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 2.3 当带了一个参数时，表示仅输出指定的系统服务信息</span></span><br><span class="line">        services.add(String16(argv[<span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;argc; i++) &#123;</span><br><span class="line">            args.add(String16(argv[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 罗列出services这个数组中的服务名称，到这一步为止，都还只是在dumpsys本身的逻辑中转悠</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> N = services.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (N &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        aout &lt;&lt; <span class="string">"Currently running services:"</span> &lt;&lt; <span class="built_in">endl</span>;    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">            sp&lt;IBinder&gt; service = sm-&gt;checkService(services[i]);</span><br><span class="line">            <span class="keyword">if</span> (service != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                aout &lt;&lt; <span class="string">"  "</span> &lt;&lt; services[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (showListOnly) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 输出services这个数组中所包含系统服务的详细信息</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">        sp&lt;IBinder&gt; service = sm-&gt;checkService(services[i]);</span><br><span class="line">        <span class="keyword">if</span> (service != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 4.1 调用service的dump方法，来输出service的具体信息</span></span><br><span class="line">            <span class="keyword">int</span> err = service-&gt;dump(STDOUT_FILENO, args);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码逻辑并不复杂，按照如下逻辑执行：</p>
<ol>
<li>获取servicemanager，所有的系统服务都会向servicemanager注册</li>
<li>进行命令行参数解析，根据参数的不同设置后续的执行指令序列</li>
<li>简单的罗列了一下需要输出的系统服务名称</li>
<li>真正完成系统服务详细信息的输出</li>
</ol>
<p>关键在第4步的实现，调用具体系统服务的<strong>dump()</strong>方法。</p>
<h2 id="2-2-系统服务的dump方法"><a href="#2-2-系统服务的dump方法" class="headerlink" title="2.2 系统服务的dump方法"></a>2.2 系统服务的dump方法</h2><p>Android中，所有的系统服务都是<strong>Binder</strong>的子类，<strong>Binder</strong>作为一个抽象的概念，用来描述一个远程对象，<br>这里有几个基础知识：</p>
<ul>
<li><p>Android中的系统服务，譬如ActivityManagerService, PackageManagerService， BatteryStatsService等都是运行在<strong>system_server</strong>这个进程中，<br>在Android启动的时候，就会按照系统服务的重要性，按序来启动这些的系统服务，它们作为服务端，为整个Android系统提供服务支撑。</p>
</li>
<li><p>Android中的应用程序是运行在独立的进程中的，如过某个应用程序需要使用系统服务，则需要发起跨进程调用(Remote Procedure Call， RPC),应用程序将作为客户端，<br>与系统服务进行数据交换。</p>
</li>
<li><p>Android上实现RPC的机制就是<strong>Binder</strong>，当客户端获取到<strong>Binder</strong>时，就可以理解为客户端跟系统服务建立绑定关系，这时，<strong>Binder</strong>就代表了远程系统服务。<br>实际的系统服务，都是<strong>Binder</strong>的子类，需要实现<strong>Binder</strong>定义的抽象方法，其中<strong>Binder.dump()</strong>这个方法就是专门为输出系统服务的信息而生。</p>
</li>
<li><p><strong>Binder.dump()</strong>这个方法的实现，完全由实际的系统服务来控制，可以附加访问权限，可以输出任何信息，甚至可以为空实现。如果某个系统服务的<strong>dump()</strong>方法<br>为空实现，那么使用<code>dumpsys</code>输出这个信息服务的信息就为空。</p>
</li>
</ul>
<p>以<strong>DiskStatsService.dump()</strong>这个方法为例，在命令行输出<code>adb shell dumpsys diskstats</code>，最终的实现就落到该方法中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dump</span><span class="params">(FileDescriptor fd, PrintWriter pw, String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 权限检查</span></span><br><span class="line">    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.DUMP, TAG);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 生成一个大小为512B的临时文件</span></span><br><span class="line">    <span class="keyword">byte</span>[] junk = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">512</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; junk.length; i++) junk[i] = (<span class="keyword">byte</span>) i;  <span class="comment">// Write nonzero bytes</span></span><br><span class="line">    File tmp = <span class="keyword">new</span> File(Environment.getDataDirectory(), <span class="string">"system/perftest.tmp"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 将512B的临时文件写入磁盘，目的是为了快速的测试写磁盘的延迟</span></span><br><span class="line">    <span class="keyword">long</span> before = SystemClock.uptimeMillis();</span><br><span class="line">    ...</span><br><span class="line">    fos = <span class="keyword">new</span> FileOutputStream(tmp);</span><br><span class="line">    fos.write(junk);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">long</span> after = SystemClock.uptimeMillis();</span><br><span class="line">    ...</span><br><span class="line">    pw.print(<span class="string">"Latency: "</span>);</span><br><span class="line">    pw.print(after - before);</span><br><span class="line">    pw.println(<span class="string">"ms [512B Data Write]"</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 4. 输出Data, Cache和System这几个分区的磁盘使用信息</span></span><br><span class="line">    reportFreeSpace(Environment.getDataDirectory(), <span class="string">"Data"</span>, pw);</span><br><span class="line">    reportFreeSpace(Environment.getDownloadCacheDirectory(), <span class="string">"Cache"</span>, pw);</span><br><span class="line">    reportFreeSpace(<span class="keyword">new</span> File(<span class="string">"/system"</span>), <span class="string">"System"</span>, pw);</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-解析dumpsys输出"><a href="#3-解析dumpsys输出" class="headerlink" title="3. 解析dumpsys输出"></a>3. 解析dumpsys输出</h1><p>对<code>dumpsys</code>输出内容的理解需要有相关领域的知识，能够理解这些日志，对Android性能调优、Bug调试都有很大的帮助，这也是一个Android系统开发人员的必备技能。</p>
<p>笔者分析了常见系统服务的<code>dumpsys</code>日志输出：</p>
<ul>
<li><a href="">dumpsys batterystats</a></li>
<li><a href="">dumpsys meminfo</a></li>
<li><a href="">dumpsys diskstats</a></li>
</ul>
<p>目前，已经有一些工具，对<code>dumpsys</code>的输出内容进行解析，并作图形化的展示，便于系统开发人员分析问题。例如：</p>
<ul>
<li><a href="https://github.com/google/battery-historian" target="_blank" rel="noopener">Battery Historian</a> 分析<strong>batterystats</strong>这个系统服务的dumpsys输出，生成HTML页面</li>
<li><a href="https://github.com/duanqz/androidlogsuite" target="_blank" rel="noopener">Android Log Suite</a></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>电量统计(2)-日志</title>
    <url>/2017/04/19/2017-04-19-Performance-Battery2/</url>
    <content><![CDATA[<h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>在<a href="/2017-04-19-Performance-Battery1">电量统计(1)-原理</a>一文<br>中，我们分析了电量统计服务的运行机制、耗电量的计算方法。本文我们分析电量统计的输出日志，包括日志信息的格式、表示的意义等，这些日志信息能够帮助开发人员解决一些功耗和性能问题。</p>
<h1 id="电量统计信息的分析"><a href="#电量统计信息的分析" class="headerlink" title="电量统计信息的分析"></a>电量统计信息的分析</h1><p>Android提供的<strong>dumpsys</strong>命令用于查看系统服务的信息(实现原理可以查阅<a href="/2017-04-18-Performance-dumpsys">dumpsys介绍</a>)，<br>将<strong>batterystats</strong>作为参数，就能输出完整的电量统计信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb shell dumpsys batterystats</span><br><span class="line">Battery History (2% used, 6184 used of 256KB, 36 strings using 2418):</span><br><span class="line">                    0 (9) RESET:TIME: 2015-07-23-07-59-11</span><br><span class="line">                    0 (2) 100 status=not-charging health=good plug=none temp=310 volt=4308 +running +wake_lock +audio +screen +phone_in_call phone_signal_strength=great +wifi_running +wifi wifi_signal_strength=4 wifi_suppl=completed top=u0a4:<span class="string">"com.android.dialer"</span></span><br><span class="line">                    0 (2) 100 user=0:<span class="string">"0"</span></span><br><span class="line">                    0 (2) 100 userfg=0:<span class="string">"0"</span></span><br><span class="line">             +1s868ms (2) 100 phone_signal_strength=very</span><br><span class="line">             +4s655ms (3) 100 -phone_in_call -top=u0a4:<span class="string">"com.android.dialer"</span></span><br><span class="line">                  ...</span><br><span class="line">          +5m10s450ms (2) 100 phone_signal_strength=great wifi_signal_strength=3</span><br><span class="line">          +5m24s232ms (2) 100 -top=u0a13:<span class="string">"com.android.mms"</span></span><br><span class="line">          +5m24s232ms (2) 100 +top=u0a10:<span class="string">"com.android.launcher3"</span></span><br><span class="line">          +5m29s113ms (2) 099</span><br><span class="line">          +5m31s160ms (2) 099 -top=u0a10:<span class="string">"com.android.launcher3"</span></span><br><span class="line">          +5m31s160ms (2) 099 +top=u0a2:<span class="string">"com.android.browser"</span></span><br><span class="line">                  ...</span><br><span class="line">         +21m20s645ms (2) 099 +wake_lock=1000:<span class="string">"*alarm*:android.intent.action.TIME_TICK"</span></span><br><span class="line">         +21m20s664ms (1) 099 -wake_lock</span><br><span class="line">         +21m44s890ms (2) 098</span><br><span class="line">         +24m41s381ms (3) 098 +wake_lock=-1:<span class="string">"screen"</span> +screen brightness=dim</span><br><span class="line">         +24m50s491ms (1) 098 wifi_signal_strength=3</span><br><span class="line">                  ...</span><br><span class="line">         +34m22s702ms (2) 098 temp=320</span><br><span class="line">         +39m23s248ms (1) 098 -running</span><br><span class="line">         +42m28s514ms (2) 098 +running +screen -phone_in_call</span><br><span class="line">         +42m28s808ms (3) 097 data_conn=umts wifi_suppl=scanning</span><br><span class="line">                  ...</span><br><span class="line">         +55m49s554ms (3) 097 +wake_lock=-1:<span class="string">"screen"</span> +screen brightness=bright</span><br><span class="line">         +55m49s750ms (2) 097 brightness=dark</span><br><span class="line">         +55m50s000ms (2) 096 temp=330</span><br><span class="line">         +55m51s998ms (2) 096 brightness=dim</span><br><span class="line">                  ...</span><br><span class="line">         +59m02s534ms (2) 096 +top=u0a10:<span class="string">"com.android.launcher3"</span></span><br><span class="line">         +59m03s452ms (2) 096 -top=u0a10:<span class="string">"com.android.launcher3"</span></span><br><span class="line">         +59m03s452ms (2) 096 +top=u0a2:<span class="string">"com.android.browser"</span></span><br><span class="line">         +59m19s915ms (2) 095</span><br><span class="line">         +59m49s908ms (2) 095 volt=4190</span><br><span class="line">       +1h01m50s806ms (2) 095 data_conn=umts</span><br><span class="line">       +1h01m57s536ms (2) 095 data_conn=hspap</span><br><span class="line">       +1h02m04s176ms (2) 095 data_conn=umts</span><br><span class="line">       +1h02m12s472ms (2) 095 data_conn=hspap</span><br><span class="line">                  ...</span><br></pre></td></tr></table></figure>

<p>本文引用至 <a href="http://duanqz.github.io/2015-07-21-batterystats-part2" target="_blank" rel="noopener">http://duanqz.github.io/2015-07-21-batterystats-part2</a>.</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>电量统计(1)-原理</title>
    <url>/2017/04/19/2017-04-19-Performance-Battery1/</url>
    <content><![CDATA[<p>说明：本文的代码以<strong>android-5.1.1_r8</strong>为蓝本，代码的在线网址是&lt;/&gt;</p>
<h1 id="1-概要"><a href="#1-概要" class="headerlink" title="1. 概要"></a>1. 概要</h1><p>我们平常说的手机耗电量，一般涵盖两个方面：硬件层面的功耗和软件层面的电量。</p>
<p>本文介绍的电量统计的原理，并不涉及到硬件层面的功耗设计，仅从软件层面围绕以下几个问题进行分析：</p>
<blockquote>
<p>Android如何启动电量统计服务？<br/><br>电量统计涉及到哪一些硬件模块？<br/><br>如何计算一个应用程序的耗电量？<br/><br>电量统计需要完成哪些具体工作？</p>
</blockquote>
<p>手机有很多硬件模块：CPU，蓝牙，GPS，显示屏，Wifi，射频(Cellular Radio)等，在手机使用过程中，这些硬件模块可能处于不同的状态，譬如Wifi打开或关闭，屏幕是亮还是暗，CPU运行或休眠。<br>硬件模块在不同的状态下的耗电量是不同的。Android在进行电量统计时，并不是采用直接记录电流消耗量的方式，而是跟踪硬件模块在不同状态下的使用时间，收集一些可用信息，用来近似的计算出电池消耗量。</p>
<p>从用户使用层面来看，Android需要统计出应用程序的耗电量。应用程序的耗电量由很多部分组成，可能使用了GPS，蓝牙等模块，可能应用程序要求长时间亮屏(譬如游戏、视频类应用)。<br>一个应用程序的电量统计，可以采用累计应用程序使用所有硬件模块时间这种方式近似计算出来。</p>
<p>举一个例子，假定某个APK的使用了GPS，使用时间用 <em>t</em> 表示。GPS模块单位时间的耗电量用 <em>w</em> 表示，那么，这个APK使用GPS的耗电量就可以按照如下方式计算：</p>
<pre><code>耗电量 = 单位时间耗电量(w) × 使用时间(t)</code></pre><p>Android框架层通过一个名为<code>batterystats</code>的系统服务，实现了电量统计的功能。<code>batterystats</code>获取电量的使用信息有两种方式：</p>
<ul>
<li><p><strong>被动(push)</strong>：有些硬件模块(wifi, 蓝牙)在发生状态改变时，通知<code>batterystats</code>记录状态变更的时间点</p>
</li>
<li><p><strong>主动(pull)</strong>：有些硬件模块(cpu)需要<code>batterystats</code>主动记录时间点，譬如记录Activity的启动和终止时间，就能计算出Activity使用CPU的时间</p>
</li>
</ul>
<p>电量统计服务的代码逻辑涉及到以下android源码：</p>
<ul>
<li><a href="{{ site.android_source }}/platform/frameworks/base/+/android-5.1.1_r8/services/java/com/android/server/SystemServer.java#314">frameworks/base/services/java/com/android/server/SystemServer.java</a></li>
<li><a href="{{ site.android_source }}/platform/frameworks/base/+/android-5.1.1_r8/services/core/java/com/android/server/am/ActivityManagerService.java#2162">frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</a></li>
<li><a href="{{ site.android_source }}/platform/frameworks/base/+/android-5.1.1_r8/services/core/java/com/android/server/am/BatteryStatsService.java">frameworks/base/services/core/java/com/android/server/am/BatteryStatsService.java</a></li>
<li><a href="{{ site.android_source }}/platform/frameworks/base/+/android-5.1.1_r8/core/java/android/os/BatteryStats.java">frameworks/base/core/java/android/os/BatteryStats.java</a></li>
<li><a href="{{ site.android_source }}/platform/frameworks/base/+/android-5.1.1_r8/core/java/com/android/internal/os/BatteryStatsImpl.java">frameworks/base/core/java/com/android/internal/os/BatteryStatsImpl.java</a></li>
<li><a href="{{ site.android_source }}/platform/frameworks/base/+/android-5.1.1_r8/core/java/com/android/internal/os/BatteryStatsHelper.java">frameworks/base/core/java/com/android/internal/os/BatteryStatsHelper.java</a></li>
<li><a href="{{ site.android_source }}/platform/frameworks/base/+/android-5.1.1_r8/core/res/res/xml/power_profile.xml">frameworks/base/core/res/res/xml/power_profile.xml</a></li>
</ul>
<p>为了描述的简便，后文仅以<strong>短类名.方法名()</strong>表示代码片段所在的位置。</p>
<h1 id="2-电量统计服务的启动过程"><a href="#2-电量统计服务的启动过程" class="headerlink" title="2. 电量统计服务的启动过程"></a>2. 电量统计服务的启动过程</h1><p>电量统计服务是一个系统服务，名字为<code>batterystats</code>，在Android系统启动的时候，这个服务就会被启动，其启动时序如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Test/1-2017-04-19-Performance-Battery1.png" alt="电量统计服务启动时序"></p>
<p>电量统计服务是间接由ActivityManagerService(后文简称AMS)来启动，AMS是Android系统最为基础的服务，进入Android系统后，最优先启动的，就是这类服务。</p>
<ul>
<li><p>在<strong>SystemServer.startBootstrapServices()</strong>这个方法中，将ActivityManagerService.Lifecycle传入<strong>SystemServiceManager.startService()</strong>这个方法，就实现了AMS的初始化。</p>
<p>注：Android提供了系统服务的基础类<strong>SystemService</strong>，子类通过实现系统回调函数，来完成具体系统服务的生命周期。ActivityManagerService.Lifecycle就是<strong>SystemService</strong>的子类。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startBootstrapServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mActivityManagerService = mSystemServiceManager.startService(</span><br><span class="line">            ActivityManagerService.Lifecycle<span class="class">.<span class="keyword">class</span>).<span class="title">getService</span>()</span>;</span><br><span class="line">    mActivityManagerService.setSystemServiceManager(mSystemServiceManager);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在<strong>SystemServiceManager.startService()</strong>这个方法中，利用反射构造出一个新的实例，当ActivityManagerService.Lifecycle作为参数传入的时候，就完成了ActivityManagerService的初始化，注册和启动的工作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T extends SystemService&gt; <span class="function">T <span class="title">startService</span><span class="params">(Class&lt;T&gt; serviceClass)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    Constructor&lt;T&gt; constructor = serviceClass.getConstructor(Context<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    service = constructor.newInstance(mContext);</span><br><span class="line">    ...</span><br><span class="line">    mServices.add(service); <span class="comment">// 注册新的系统服务</span></span><br><span class="line">    ...</span><br><span class="line">    service.onStart();      <span class="comment">// 启动新的系统服务</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在<strong>ActivityManagerService.start()</strong>方法中，伴随着ActivityManagerService启动的，BatteryStatService通过publish方法，将自己注册到系统服务中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mBatteryStatsService.publish(mContext);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在<strong>BatteryStatsService.publish()</strong>方法中，将<strong>BatteryStats.SERVICE_NAME</strong>这个名字注册到系统服务中，这个名字实际上就是<strong>batterystats</strong>，<br>后续使用电量统计服务时，只需要通过这个名字向系统获取对应的服务就可以了。  </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publish</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ServiceManager.addService(BatteryStats.SERVICE_NAME, asBinder());</span><br><span class="line">    mStats.setNumSpeedSteps(<span class="keyword">new</span> PowerProfile(mContext).getNumSpeedSteps());</span><br><span class="line">    mStats.setRadioScanningTimeout(mContext.getResources().getInteger(</span><br><span class="line">            com.android.internal.R.integer.config_radioScanningTimeout)</span><br><span class="line">            * <span class="number">1000L</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>mStats</strong>是BatteryStatsImpl类的一个对象，从类名可以看出BatteryStatsImpl是BatteryStats的实现类，它描述了所有与电量消耗有关的信息，其实现逻辑，后文再作具体分析。</p>
<p>这里新建了<strong>PowerProfile</strong>类，并调用了getNumSpeedSteps()方法， <em>NumSpeedSteps</em>描述的是CPU的运行频率，不同设备的CPU值可能不同。<br>除了CPU的运行频率，还有很多其他与耗电量相关参数，都是因设备而异的，<strong>PowerProfile</strong>类就是专门描述这些参数的，通过解析<a href="{{ site.android_source }}/platform/frameworks/base/+/android-5.1.1_r8/core/res/res/xml/power_profile.xml">frameworks/base/core/res/res/xml/power_profile.xml</a><br>这个XML文件完成初始化。厂商需要根据硬件设备的实际情况，设置不同的参数，以下是Nexus 5(hammerhead)耗电参数配置的代码片段：</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">device</span> <span class="attr">name</span>=<span class="string">"Android"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- All values are in mAh except as noted --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"none"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"wifi.on"</span>&gt;</span>3.5<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"wifi.active"</span>&gt;</span>73.24<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"wifi.scan"</span>&gt;</span>75.48<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"battery.capacity"</span>&gt;</span>2300<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">device</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>wifi.on, wifi.active, wifi.scan分别表示wifi模块在打开、工作和扫描时的单位时间的电流量，这个值的单位的mAh。其他一些参数可以参见：<a href="https://source.android.com/devices/tech/power/index.html#power-values" target="_blank" rel="noopener">https://source.android.com/devices/tech/power/index.html#power-values</a></p>
<p>前面我们提到耗电量是通过计算：</p>
<pre><code>耗电量 = 单位时间的耗电量(w) × 使用时间(t) = 电压(U) × 单位时间电流量(I) × 使用时间(t)</code></pre><p>在手机上电压一般是恒定的，所以，计算耗电量只需要知道单位时间电流量即可。有了power_profile.xml这个文件描述的单位时间电流量，再收集硬件模块在不同状态下的使用时间，就能够近似的计算出耗电量了。</p>
<p><strong>至此，我们分析了以下两个问题：</strong></p>
<ul>
<li><p><strong>Android如何启动电量统计服务？</strong> Android系统启动 -&gt; AMS启动和注册 -&gt; batterystats启动和注册</p>
</li>
<li><p><strong>Android如何计算耗电量？</strong> 并不是直接跟踪电流消耗量，而是采用“单位时间电流量(I)×使用时间(t)”来做近似计算。不同硬件模块的单位时间电流量是需要厂商给定的。</p>
</li>
</ul>
<h1 id="3-电量统计服务的工作过程"><a href="#3-电量统计服务的工作过程" class="headerlink" title="3. 电量统计服务的工作过程"></a>3. 电量统计服务的工作过程</h1><p>电量统计包含几个重要的功能：信息收集、信息存储和电量计算。</p>
<ul>
<li>信息收集是指在什么时间点采用什么方式收集电量使用数据</li>
<li>信息存储按照什么格式存放，存放在什么位置</li>
<li>电量计算是指根据已经收集的信息，如何计算出不同应用、服务、进程等的电量使用情况</li>
</ul>
<p>在具体介绍电量统计服务的工作过程之前，先上工作原理图一张：</p>
<div align="center"><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Test/3-2017-04-19-Performance-Battery1.png" alt="电量统计服的工作过程"/></div>

<h2 id="3-1-电量信息收集"><a href="#3-1-电量信息收集" class="headerlink" title="3.1 电量信息收集"></a>3.1 电量信息收集</h2><p><code>batterystats</code>有主动和被动收集电量使用信息的方式，收集的信息基本都包含硬件模块的状态和被使用的时间两个维度。为什么仅仅是收集不同硬件模块的使用时间呢？<br>前面我们说过，手机电压通常是恒定的，耗电量是通过 “单位时间电流量(I) × 使用时间(t)” 来计算，而单位时间电流量是由厂商给定的，定义在power_profile.xml中，<br>所以，只需要收集不同硬件模块的使用时间，就可以近似的计算出耗电量了</p>
<p>收集信息被组织起来，在内存中的数据结构是由<a href="/platform/frameworks/base/+/android-5.1.1_r8/core/java/android/os/BatteryStats.java"><strong>BatteryStats</strong></a>类描述的。<br>为了能够从不同维度统计耗电量，这个数据结构设计得比较复杂，我们不在这里展开讨论，仅通过一个收集应用程序前台运行时间的例子，来说明信息收集过程。</p>
<p>记录应用程序中所有Activity从显示状态(Resumed)到消失状态(Paused)的时间，就能够统计应用程序的前台运行时间。Activity状态的切换是由AMS掌控的，因此AMS需要将Activity的状态信息通知给<code>batterystats</code>服务。</p>
<ul>
<li>当Activity要切换到显示状态(Resumed)时，会调用<strong>ActivityStackSupervisor.resumeTopActivitiesLocked()</strong>方法，<br>接下来会调用<strong>ActivityStack.resumeTopActivityInnerLocked()</strong>方法来完成Activity的状态切换，在完成状态切换后，<br>会调用<strong>ActivityStackSupervisor.reportResumedActivityLocked()</strong>方法，从这里开始，就开始通报了：“本Activity已经进入了显示状态”。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">reportResumedActivityLocked</span><span class="params">(ActivityRecord r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ActivityStack stack = r.task.stack;</span><br><span class="line">    <span class="keyword">if</span> (isFrontStack(stack)) &#123;</span><br><span class="line">        mService.updateUsageStats(r, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在<strong>ActivityManagerService.updateUsageStats()</strong>方法中，首先会获取一个统计信息的实例<strong>BatteryStatsImpl</strong>，它是<strong>BatteryStats</strong>的子类，描述了所有的统计信息；<br>然后，根据是否处于resumed的状态，作出Resumed或Paused的通知。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateUsageStats</span><span class="params">(ActivityRecord component, <span class="keyword">boolean</span> resumed)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics();</span><br><span class="line">    <span class="keyword">if</span> (resumed) &#123;</span><br><span class="line">        ...</span><br><span class="line">        stats.noteActivityResumedLocked(component.app.uid);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ....</span><br><span class="line">        stats.noteActivityPausedLocked(component.app.uid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在<strong>BatteryStatsImpl.noteActivityResumedLocked()</strong>方法中，会启动一个计时器(StopwatchTimer)，记录下了启动时间(uptime)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noteActivityResumedLocked</span><span class="params">(<span class="keyword">long</span> elapsedRealtimeMs)</span> </span>&#123;</span><br><span class="line">    createForegroundActivityTimerLocked().startRunningLocked(elapsedRealtimeMs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在<strong>BatteryStatsImpl.noteActivityPausedLocked()</strong>方法中，会停止之前启动的计时器(StopwatchTimer)，并计算出使用时间。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noteActivityPausedLocked</span><span class="params">(<span class="keyword">long</span> elapsedRealtimeMs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mForegroundActivityTimer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mForegroundActivityTimer.stopRunningLocked(elapsedRealtimeMs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了应用程序前台运行时间，还有很多信息是<code>batterystats</code>服务关注的，包括WakeLock、Sendor、Wifi、Audio、Video等，这些信息的采集方式与上述过程雷同，都会经过以下步骤：</p>
<ul>
<li>由相应的模块发起状态变更的通知</li>
<li>BatteryStats使用定时器记录起止时间</li>
</ul>
<p>应用程序可能会使用多个硬件模块，所以，耗电信息收集的策略也被设计得比较复杂，譬如，要使用到很多计时器，就设计出了“计时器池”来提高资源利用率。</p>
<h2 id="3-2-电量信息存储"><a href="#3-2-电量信息存储" class="headerlink" title="3.2 电量信息存储"></a>3.2 电量信息存储</h2><p>收集到的电量信息，在内存中是由<strong>BatteryStats</strong>这个类来描述的，Android支持历史电量信息的显示的，如果重新启动Android，那内存中的数据就丢失了，<br>所以需要把这些信息存储到磁盘上，磁盘上的 <em>/data/system/batterystats.bin</em> 文件中就是电量信息的序列化数据。</p>
<p><code>batterystats</code>服务启动时，会从 <em>batterystats.bin</em> 这个文件中读取数据，来初始化<strong>BatteryStats</strong>这个数据结构。</p>
<ul>
<li><strong>BatteryStatsService()</strong>构造函数中，初始化了<strong>BatteryStats</strong>的子类<strong>BatteryStatsImpl</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BatteryStatsService(File systemDir, Handler handler) &#123;</span><br><span class="line">    mStats = <span class="keyword">new</span> BatteryStatsImpl(systemDir, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>BatteryStatsImpl()</strong>构造函数中，一开始就会新建一个文件batterystats.bin，传入参数systemDir,就是“/data/system”。<br>这个时候，还并没有从文件中读取数据来填充内存。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BatteryStatsImpl</span><span class="params">(File systemDir, Handler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (systemDir != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mFile = <span class="keyword">new</span> JournaledFile(<span class="keyword">new</span> File(systemDir, <span class="string">"batterystats.bin"</span>),</span><br><span class="line">                <span class="keyword">new</span> File(systemDir, <span class="string">"batterystats.bin.tmp"</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mFile = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>ActivityManagerService()</strong>构造函数中,有初始化电量统计服务的逻辑，会调用到<strong>BatteryStatsImpl.readLocked()</strong>方法，<br> 这个方法里面完成了将磁盘数据反序列化到内存。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ActivityManagerService</span><span class="params">(Context systemContext)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    File systemDir = <span class="keyword">new</span> File(dataDir, <span class="string">"system"</span>);</span><br><span class="line">    systemDir.mkdirs();</span><br><span class="line">    mBatteryStatsService = <span class="keyword">new</span> BatteryStatsService(systemDir, mHandler);</span><br><span class="line">    mBatteryStatsService.getActiveStatistics().readLocked();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有数据的读取，就有数据的写入，通过调用<strong>BatteryStatsImpl.writeLocked()</strong>方法，就将数据写回到了 <em>batterystats.bin</em> 这个文件。<br><strong>ActivityManagerService.updateCpuStatsNow()</strong>方法会触发写 <em>batterystats.bin</em> 的操作，而这个方法，在更新电量使用信息的时候就会被调用到。<br>所以，在手机使用的过程中，收集到的电量信息，就会被当作历史信息，不定时的写入到磁盘保存下来，下次<code>batterystats</code>启动时，又会被用到。</p>
<h2 id="3-3-电量计算"><a href="#3-3-电量计算" class="headerlink" title="3.3 电量计算"></a>3.3 电量计算</h2><p><strong>BatteryStatsHelper.refreshStats()</strong>承载了电量计算的全部过程，在需要显示电量统计信息的地方，就可以通过<strong>BatteryStatsHelper</strong>这个类，来获取统计完成的电量信息。<br>Setting.apk就引用了这个类。电量计算大体可以分为两块：</p>
<ul>
<li><p><strong>AppUsage</strong>：应用程序耗电量计算，是指每一个应用程序使用硬件模块所产生的耗电量</p>
</li>
<li><p><strong>MiscUsage</strong>：其他杂项耗电量计算，所谓杂项，其实就是用户比较关心的一大类，包括：待机的耗电量、亮屏的耗电量、通话的耗电量、Wifi的耗电量等</p>
</li>
</ul>
<h3 id="3-3-1-AppUsage"><a href="#3-3-1-AppUsage" class="headerlink" title="3.3.1 AppUsage"></a>3.3.1 AppUsage</h3><p>在<strong>BatteryStatsHelper.processAppUsage()</strong>这个方法中，实现了应用程序的电量计算(实际上统计的粒度是uid，不同的apk可以运行在同一个uid)。</p>
<ul>
<li>首先，有一个统计时间段的概念，是通过统计类型<strong>mStatsType</strong>这个变量来表示的，有以下可选值：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 统计从上一次充电以来至现在的耗电量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STATS_SINCE_CHARGED = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计系统启动以来到现在的耗电量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STATS_CURRENT = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计从上一次拔掉USB线以来到现在的耗电量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STATS_SINCE_UNPLUGGED = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>


<ul>
<li>然后，我们来看一下这个函数体，它实现的是与APP耗电量计算的逻辑。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processAppUsage</span><span class="params">(SparseArray&lt;UserHandle&gt; asUsers)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据power_profile.xml文件中的单位时间电流量定义，初始化一些计算参数</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> which = mStatsType;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> speedSteps = mPowerProfile.getNumSpeedSteps();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">double</span>[] powerCpuNormal = <span class="keyword">new</span> <span class="keyword">double</span>[speedSteps];</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span>[] cpuSpeedStepTimes = <span class="keyword">new</span> <span class="keyword">long</span>[speedSteps];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; speedSteps; p++) &#123;</span><br><span class="line">        powerCpuNormal[p] = mPowerProfile.getAveragePower(PowerProfile.POWER_CPU_ACTIVE, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">double</span> mobilePowerPerPacket = getMobilePowerPerPacket();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">double</span> mobilePowerPerMs = getMobilePowerPerMs();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">double</span> wifiPowerPerPacket = getWifiPowerPerPacket();</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对一个UID进行电量统计， UID几乎可以等同于一个应用程序</span></span><br><span class="line">    SparseArray&lt;? extends Uid&gt; uidStats = mStats.getUidStats();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> NU = uidStats.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> iu = <span class="number">0</span>; iu &lt; NU; iu++) &#123;</span><br><span class="line">        <span class="comment">// 1. 计算每一个UID中所有进程在CPU运算时的耗电量，比如应用程序在前台显示，或者后台有服务在占用CPU</span></span><br><span class="line">        <span class="comment">//    CPU有不同的运行频率，每一个频率和该频率下的单位时间电流都在power_profile.xml中有定义  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 计算Wakelock占用的耗电量，Wakelock被占用，意味着CPU处于唤醒状态</span></span><br><span class="line">        <span class="comment">//    在有些时候，并不需要进行CPU运算，但CPU仍处于唤醒状态</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 计算使用数据网络的耗电量</span></span><br><span class="line">        <span class="comment">//    应用程序使用数据网络上网时的耗电量，完成这部分通信的射频模块(radio)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 计算使用wifi的耗电量</span></span><br><span class="line">        <span class="comment">//    wifi的使用又可以分为两个情况：扫描可用wifi(SCAN)和进行数据传输(RUNNING)，</span></span><br><span class="line">        <span class="comment">//    这两种情况下的单位时间电流量是不同的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 计算使用传感器的耗电量</span></span><br><span class="line">        <span class="comment">//    GPS使用的耗电量计算也被包含在这里</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>最后，我们来总结一下应用程序的电量计算过程。Android通过一个名为<strong>BatteryStats.Uid</strong>的数据结构来维护一个应用程序的电量统计信息。<br>这个数据结构中，又包含很多子结构：</p>
<ul>
<li>Proc：表示属于Uid的进程，一个Uid中可能会有多个进程，每个进程都有CPU占用时间</li>
<li>WakeLock：表示Uid持有的WakeLock锁的电量统计，一个Uid也可能会持有多个锁</li>
<li>Mobile Raido：表示Uid使用数据流量的电量统计，譬如3G流量、4G流量</li>
<li>Wifi：表示Uid使用wifi的电量统计</li>
<li>Sendor：表示Uid使用传感器的电量统计  </li>
</ul>
</li>
</ul>
<div align="center"><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Test/1-2017-04-18-Performance-dumpsys.png" alt="应用程序电量计算过程"/></div>

<p>  Android会对每一个Uid进行电量计算，每次计算都会涉及到以上五个维度，每一个维度的计算<strong>几乎</strong>都要用到硬件模块在不同状态下单位时间的电流量，以及硬件模块在当前Uid下的使用时间。</p>
<p>  注：这里说的<strong>几乎</strong>，是指还有一些例外情况，在计算使用数据网络的耗电量时，也可能会通过传输的数据包来计算耗电量。从这里，我们也可以看到电量计算是由一套复杂的策略决定的。</p>
<h3 id="3-3-1-MiscUsage"><a href="#3-3-1-MiscUsage" class="headerlink" title="3.3.1 MiscUsage"></a>3.3.1 MiscUsage</h3><p>在<strong>BatteryStatsHelper.processMiscUsage()</strong>这个方法中，实现了其他一些杂项的电量计算，函数的实现清晰了表明了意图。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processMiscUsage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    addUserUsage();</span><br><span class="line">    addPhoneUsage();</span><br><span class="line">    addScreenUsage();</span><br><span class="line">    addFlashlightUsage();</span><br><span class="line">    addWiFiUsage();</span><br><span class="line">    addBluetoothUsage();</span><br><span class="line">    addIdleUsage(); <span class="comment">// Not including cellular idle power</span></span><br><span class="line">    <span class="comment">// Don't compute radio usage if it's a wifi-only device</span></span><br><span class="line">    <span class="keyword">if</span> (!mWifiOnly) &#123;</span><br><span class="line">        addRadioUsage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>至此，我们进一步分析以下两个问题:</strong></p>
<ul>
<li><p><strong>如何计算一个应用程序的耗电量？</strong> 收集硬件模块使用时间 -&gt; 对每个应用程序进行归类计算</p>
</li>
<li><p><strong>电量统计需要完成哪些具体工作？</strong> 电量使用信息收集，存储和计算</p>
</li>
</ul>
<p>本文分析了软件层面的电量统计原理，电量统计的结果，一般可以在“设置”这个程序的电池信息中可以看到。另一方面，Android提供的<code>dumpsys batterystats</code>功能，也能输出所有的电量统计信息，<br>在<a href="/2017-04-19-Performance-Battery2">电量统计(2)-日志</a>一文中，我们对Android的Log进行了详细的分析。</p>
<p>本文引用至 <a href="http://duanqz.github.io/2015-07-21-batterystats-part1" target="_blank" rel="noopener">http://duanqz.github.io/2015-07-21-batterystats-part1</a>.</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法</title>
    <url>/2017/04/20/2017-04-20-Markdown-Syntax/</url>
    <content><![CDATA[<p>本文作为一个Markdown语法的一个参考手册，列出Markdown支持的语法。<br>Markdown的语法标记是一些常见的特殊字符，譬如 <strong>#, *, &gt;</strong> 等，使用起来都比较自然。</p>
<p><br/><font color='blue' size='5'><b>标题</b></font></p>
<pre><code># 一级标题
## 二级标题
##### 五级标题</code></pre><p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Programing/1-2017-04-20-Markdown-Syntax.png" alt="各级标题"></p>
<p><br/><font color='blue' size='5'><b>强调</b></font></p>
<pre><code>*斜体* 或 _斜体_
**粗体** 或 __粗体__
~~删除线~~
**_加粗且斜体_**</code></pre><p><em>斜体</em></p>
<p><strong>粗体</strong></p>
<p><del>删除线</del></p>
<p><strong><em>加粗且斜体</em></strong></p>
<p><br/><font color='blue' size='5'><b>列表</b></font></p>
<pre><code>* 一级表项
* 一级表项
    * 二级表项
    * 二级表项

1. 一级表项1
    * 二级表项1
    * 二级表项2
2. 一级表项2</code></pre><ul>
<li>一级表项<ul>
<li>二级表项</li>
<li>二级表项</li>
</ul>
</li>
<li>一级表项</li>
</ul>
<ol>
<li>一级表项1<ul>
<li>二级表项1</li>
<li>二级表项2</li>
</ul>
</li>
<li>一级表项2</li>
</ol>
<p><br/><font color='blue' size='5'><b>引用</b></font></p>
<pre><code>毛主席说过:

&gt; 枪杆子里出政权！
&gt;
&gt; 一切反动派都是纸老虎。</code></pre><p>毛主席说过：</p>
<blockquote>
<p>枪杆子里出政权！</p>
<p>一切反动派都是纸老虎。</p>
</blockquote>
<p><br/><font color='blue' size='5'><b>链接</b></font></p>
<pre><code>自动链接 &lt;https://yaitza.github.io&gt;
文本链接 [Click to yaitza](https://yaitza.github.io)</code></pre><p>自动链接 <a href="https://yaitza.github.io" target="_blank" rel="noopener">https://yaitza.github.io</a></p>
<p>文本链接 <a href="https://yaitza.github.io" target="_blank" rel="noopener">Click to yaitza</a></p>
<p><br/><font color='blue' size='5'><b>图片</b></font></p>
<pre><code>![文字描述](图片链接)
![锤锤](https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Programing/2-2017-04-20-Markdown-Syntax.png)</code></pre><p><img src="%E5%9B%BE%E7%89%87%E9%93%BE%E6%8E%A5" alt="文字描述"></p>
<p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Programing/2-2017-04-20-Markdown-Syntax.png" alt="锤锤"></p>
<p><br/><font color='blue' size='5'><b>表格</b></font></p>
<pre><code>head1 | head2
----- | -----
 1.1  |  1.2
 2.1  |  2.2</code></pre><table>
<thead>
<tr>
<th>head1</th>
<th>head2</th>
</tr>
</thead>
<tbody><tr>
<td>1.1</td>
<td>1.2</td>
</tr>
<tr>
<td>2.1</td>
<td>2.2</td>
</tr>
</tbody></table>
<p><br/><font color='blue' size='5'><b>转义</b></font></p>
<p><code>\</code>是转义前导符，能够还原特殊字符本来的样子。</p>
<pre><code>\#, \*, \&gt;, \{}, \[], \(), \\, \+, \-, \`, \_, \!, \.</code></pre><p>#, *, &gt;, {}, [], (), \, +, -, `, _, !, .</p>
<p><br/><font color='blue' size='5'><b>任务列表</b></font></p>
<p>不同的Markdown对任务列表的支持程度不一样。</p>
<pre><code>- [x] 任务一，已完成
- [ ] 任务二，未完成
- [ ] 任务三，未完成</code></pre><div ><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Programing/3-2017-04-20-Markdown-Syntax.png" alt="任务列表"/></div>

<p><br/><font color='blue' size='5'><b>代码块语法高亮</b></font></p>
<p>代码块语法高亮需要一些插件的支持，不同的插件使用略有差别。</p>
<pre><code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"hello, markdown"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"hello, markdown"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Pycharm修改文件默认生成</title>
    <url>/2017/04/20/2017-04-20-Pycharm-Setting/</url>
    <content><![CDATA[<h1 id="1-Pycharm设置路径"><a href="#1-Pycharm设置路径" class="headerlink" title="1. Pycharm设置路径"></a>1. Pycharm设置路径</h1><p>pycharm 修改新建文件时的头部模板:  </p>
<blockquote>
<p>默认为<strong>author</strong> = “…” [省略号是默认你的计算机名]. </p>
</blockquote>
<p>修改这个作者名的步骤：  </p>
<blockquote>
<p>1.依次点击：File-&gt;Settings-&gt;Editor-&gt;File and Code Templete.<br>2.点击右侧Templates选项卡，会有一些格式文件新建时的模板.<br>3.在这里可以修改这些默认模板.  </p>
</blockquote>
<h1 id="2-Python-Script示例"><a href="#2-Python-Script示例" class="headerlink" title="2. Python Script示例"></a>2. Python Script示例</h1><p>按照如下设置进行Python Script默认指设置：<br><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Tools/1-2017-04-20-Pycharm-Setting.png" alt="Pycharm截图"><br>设置完成后，重启Pycharm；新建Python Script查看，如下图：<br><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Tools/2-2017-04-20-Pycharm-Setting.png" alt="Pycharm截图"></p>
<h1 id="3-常用替换变量"><a href="#3-常用替换变量" class="headerlink" title="3. 常用替换变量"></a>3. 常用替换变量</h1><p>如上图所示， 也可以把${USER} 换成你想要的作者名；也可以换成别的变量，或其他代码：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$&#123;PROJECT_NAME&#125;</span> - the name of the current project.  </span><br><span class="line"><span class="variable">$&#123;NAME&#125;</span> - the name of the new file <span class="built_in">which</span> you specify <span class="keyword">in</span> the New File dialog box during the file creation.  </span><br><span class="line"><span class="variable">$&#123;USER&#125;</span> - the login name of the current user.  </span><br><span class="line"><span class="variable">$&#123;DATE&#125;</span> - the current system date.  </span><br><span class="line"><span class="variable">$&#123;TIME&#125;</span> - the current system time.  </span><br><span class="line"><span class="variable">$&#123;YEAR&#125;</span> - the current year.  </span><br><span class="line"><span class="variable">$&#123;MONTH&#125;</span> - the current month.  </span><br><span class="line"><span class="variable">$&#123;DAY&#125;</span> - the current day of the month.  </span><br><span class="line"><span class="variable">$&#123;HOUR&#125;</span> - the current hour.  </span><br><span class="line"><span class="variable">$&#123;MINUTE&#125;</span> - the current minute.  </span><br><span class="line"><span class="variable">$&#123;PRODUCT_NAME&#125;</span> - the name of the IDE <span class="keyword">in</span> <span class="built_in">which</span> the file will be created.  </span><br><span class="line"><span class="variable">$&#123;MONTH_NAME_SHORT&#125;</span> - the first 3 letters of the month name. Example: Jan, Feb, etc.  </span><br><span class="line"><span class="variable">$&#123;MONTH_NAME_FULL&#125;</span> - full name of a month. Example: January, February, etc.</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>VR常用术语</title>
    <url>/2017/04/24/2017-04-24-VR-terminology/</url>
    <content><![CDATA[<h1 id="1-VR"><a href="#1-VR" class="headerlink" title="1. VR"></a>1. VR</h1><h1 id="2-VR常用术语解析"><a href="#2-VR常用术语解析" class="headerlink" title="2. VR常用术语解析"></a>2. VR常用术语解析</h1><h2 id="2-1-FOV-视场角，又称：视场"><a href="#2-1-FOV-视场角，又称：视场" class="headerlink" title="2.1 FOV (视场角，又称：视场)"></a>2.1 FOV (视场角，又称：视场)</h2><p>视场角，英文 Field of View，简称FOV。 </p>
<ul>
<li>1.在光学仪器中，以光学仪器的镜头为顶点，以被测目标的物像可通过镜头的最大范围的两条边缘构成的夹角，称为视场角。如图一。视场角的大小决定了光学仪器的视野范围，视场角越大，视野就越大，光学倍率就越小。通俗地说，目标物体超过这个角就不会被收在镜头里。<br><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Test/1-2017-04-24-VR-terminology.png" alt="图一">  </li>
<li>2.在显示系统中，视场角就是显示器边缘与观察点（眼睛）连线的夹角。例如在图二中，AOB角就是水平视场角，BOC就是垂直视场角。<br><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Test/2-2017-04-24-VR-terminology.png" alt="图二"><br>视场角与焦距的关系：一般情况下，视场角越大，焦距就越短。  </li>
</ul>
<h2 id="2-2-分辨率"><a href="#2-2-分辨率" class="headerlink" title="2.2 分辨率"></a>2.2 分辨率</h2><p>分辨率可以从显示分辨率与图像分辨率两个方向来分类。显示分辨率（屏幕分辨率）是屏幕图像的精密度，是指显示器所能显示的像素有多少。图像分辨率则是单位英寸中所包含的像素点数，其定义更趋近于分辨率本身的定义。    </p>
<h3 id="2-2-1-定义"><a href="#2-2-1-定义" class="headerlink" title="2.2.1 定义"></a>2.2.1 定义</h3><ul>
<li>1.图像处理或信号处理中的空间或时间分辨率：能够分辨图像中两个点或线的能力。最好的数学定义是使用点扩展函数的分布大小。</li>
<li>2.信号处理中的频谱分辨率，由观察的时间窗长所决定的所能够分辨的最小的频谱分量的差别。</li>
</ul>
<p>以分辨率为1024×768的屏幕来说，即每一条水平线上包含有1024个像素点，共有768条线，即扫描列数为1024列，行数为768行。分辨率不仅与显示尺寸有关，还受显像管点距、视频带宽等因素的影响。其中，它和刷新频率的关系比较密切，严格地说，只有当刷新频率为“无闪烁刷新频率”，显示器能达到最高多少分辨率，才能称这个显示器的最高分辨率为多少。  </p>
<h3 id="2-2-2-特质"><a href="#2-2-2-特质" class="headerlink" title="2.2.2 特质"></a>2.2.2 特质</h3><p>分辨率决定了位图图像细节的精细程度。<br>通常情况下，图像的分辨率越高，所包含的像素就越多，图像就越清晰，印刷的质量也就越好。同时，它也会增加文件占用的存储空间。   </p>
<h3 id="2-2-3-单位"><a href="#2-2-3-单位" class="headerlink" title="2.2.3 单位"></a>2.2.3 单位</h3><p>描述分辨率的单位有：dpi（点每英寸）、lpi（线每英寸）和ppi（像素每英寸）。但只有lpi是描述光学分辨率的尺度的。虽然dpi和ppi也属于分辨率范畴内的单位，但是他们的含义与lpi不同。而且lpi与dpi无法换算，只能凭经验估算。<br>另外，ppi和dpi经常都会出现混用现象。但是他们所用的领域也存在区别。从技术角度说，“像素”只存在于电脑显示领域，而“点”只出现于打印或印刷领域。  </p>
<h3 id="2-2-4-换算"><a href="#2-2-4-换算" class="headerlink" title="2.2.4 换算"></a>2.2.4 换算</h3><p>ppi和lpi可以换算，lpi等于ppi的一半，但是取决于纳奎斯特极限。<br><strong>DPI</strong><br>设备分辨率(DeviceResolution)又称输出分辨率，指的是各类输出设备每英寸上可产生的点数，如显示器、喷墨打印机、激光打印机、绘图仪的分辨率。这种分辨率通过DPI来衡量，PC显示器的设备分辨率在60至120DPI之间，打印设备的分辨率在360至2400DPI之间。<br><strong>PPI</strong><br>图像分辨率(ImageResolution)指图像中存储的信息量。这种分辨率有多种衡量方法，典型的是以每英寸的像素数(PPI，pixel per inch)来衡量。当然也有以每厘米的像素数(PPC，pixel per centimeter)来衡量的。图像分辨率决定了图像输出的质量，图像分辨率和图像尺寸(高宽)的值一起决定了文件的大小，且该值越大图形文件所占用的磁盘空间也就越多。图像分辨率以比例关系影响着文件的大小， 即文件大小与其图像分辨率的平方成正比。如果保持图像尺寸不变，将图像分辨率提高一倍，则其文件大小增大为原来的四倍。<br><strong>LPI</strong><br>网屏分辨率(ScreenResolution)又称网幕频率(是印刷术语)，指的是印刷图像所用网屏的每英寸的网线数(即挂网网线数)，以(LPI)来表示。例如150LPI是指每英寸加有150条网线。<br><strong>位分辨率</strong><br>图像的位分辨率(BitResolution)又称位深，是用来衡量每个像素储存信息的位数。这种分辨率决定可以标记为多少种色彩等级的可能性。一般常见的有8位、16位、24位或32位色彩。有时我们也将位分辨率称为颜色深度。所谓”位”，实际上是指”2”的平方次数，8位即是2的八次方，也就是8个2相乘，等于256。所以，一幅8位色彩深度的图像，所能表现的色彩等级是256级。  </p>
<h2 id="2-3-刷新率"><a href="#2-3-刷新率" class="headerlink" title="2.3 刷新率"></a>2.3 刷新率</h2><p>刷新率指的是图像在屏幕上更新的速度，也即屏幕上的图像每秒钟出现的次数，它的单位是赫兹（Hz）。刷新频率越高，屏幕上图像闪烁感就越小，稳定性也就越高，换言之对视力的保护也越好。  </p>
<h3 id="2-3-1-定义"><a href="#2-3-1-定义" class="headerlink" title="2.3.1 定义"></a>2.3.1 定义</h3><p>刷新率就是屏幕每秒画面被刷新的次数。<br>你可以这么理解，看电影时我们看到的其实是一副一副静止的画面。但我们能感觉画面在动，是因为人的眼睛有视觉停留效应，前一幅画面留在大脑中的印象还没消失，紧接着后一幅画面就跟上来了，且两者差别很小。一个动作要用很多幅画面来显示，这样我们就感觉画面在动了。<br>这一幅一幅地更换画面，就是在刷新。假设一个动作由20张画面完成，我们看上去就有点像动画片，而这个动作增加到30张的话，看上去就自然多了。<br><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Test/3-2017-04-24-VR-terminology.png" alt="图二"> </p>
<h3 id="2-3-2-分类"><a href="#2-3-2-分类" class="headerlink" title="2.3.2 分类"></a>2.3.2 分类</h3><p>刷新率分为垂直刷新率和水平刷新率，一般提到的刷新率通常指垂直刷新率。<br>垂直刷新率表示屏幕的图象每秒钟重绘多少次，也就是每秒钟屏幕刷新的次数，以Hz（赫兹）为单位。刷新率越高越好，图象就越稳定，图像显示就越自然清晰，对眼睛的影响也越小。刷新频率越低，图像闪烁和抖动的就越厉害，眼睛疲劳得就越快。一般来说，如能达到80Hz以上的刷新频率就可完全消除图像闪烁和抖动感，眼睛也不会太容易疲劳。<br>显然刷新率越高越好，但是建议你不要让显示器一直以最高刷新率工作，那样会加速CRT显像管的老化，一般比最高刷新率低一到两档是比较合适的，建议85Hz。<br>而液晶显示器(LCD)的发光原理与传统的CRT是不一样的，由于液晶显示器每一个点在收到信号后就一直保持那种色彩和亮度，恒定发光，而不象阴极射线管显示器（CRT）那样需要不断刷新亮点。<br>因此，液晶显示器画质高而且绝对不会闪烁，把眼睛疲劳降到了最低。而刷新率对CRT的意义比较突出，有时，LCD刷新高了,反而会影响其使用寿命般保持在60-75就可以了。  </p>
<h3 id="2-3-3-影响因素"><a href="#2-3-3-影响因素" class="headerlink" title="2.3.3 影响因素"></a>2.3.3 影响因素</h3><p>从硬件角度来说，影响刷新率最主要的因素就是显示器的带宽。<br>现在一般17寸的彩显带宽在100左右，完全能上85Hz，屏幕越大，带宽越大，19寸的在200左右，21寸的在300左右，同品牌同尺寸的彩显，带宽越高，价格越贵。<br>其次影响刷新率的还有显卡。显卡也有可用的刷新率和分辨率，但是就刷新率来说，这点现在完全可以忽略不计。因为这主要针对老一代的显卡，现在哪怕古董级的TNT2显卡，也能支持1024×768分辨率下达到85Hz的效果，1024×768是17寸CRT显示器的 标准分辨率。所以，影响刷新率最主要的还是显示器的带宽。<br>从软件角度来说，影响刷新率最大的是屏幕的分辨率。<br>举个例子，同样是17寸彩显，带宽108，将分辨率调至1024×768，最高能达到85Hz，调高至1280×1024，最高只能达到70Hz，调低至800×600，却能达到100Hz。<br>分辨率越高，在带宽不变的情况下，刷新率就越低，要想保持高刷新率，只有采用高的带宽，所以大屏幕显示器的带宽都很高。  </p>
<h3 id="2-3-4-VR刷新率"><a href="#2-3-4-VR刷新率" class="headerlink" title="2.3.4 VR刷新率"></a>2.3.4 VR刷新率</h3><p>就目前的VR产品而已，有一个致命的“硬伤”：晕眩感太强。要想体验时不头晕，刷新率和帧数最少需要达到90大关才勉强能做到，而都达到120时，才可能不头晕。遗憾的是，现在的VR大多都在60左右，甚至有的帧数才30fps，所以头晕是一定的。</p>
<h2 id="2-4-沉浸感"><a href="#2-4-沉浸感" class="headerlink" title="2.4 沉浸感"></a>2.4 沉浸感</h2><h3 id="2-4-1-定义"><a href="#2-4-1-定义" class="headerlink" title="2.4.1 定义"></a>2.4.1 定义</h3><p>沉浸感就是让人专注在当前的目标情境下感到愉悦和满足，而忘记真实世界的情境。沉浸感往往包括人的感官体验和人的认知体验，是强烈的正负情绪交替的过程。  </p>
<h3 id="2-4-2-沉浸理论"><a href="#2-4-2-沉浸理论" class="headerlink" title="2.4.2 沉浸理论"></a>2.4.2 沉浸理论</h3><p>早期沉浸理论指出，挑战与技巧是影响沉浸的主要因素。若挑战太高，使用者对环境会缺少控制能力，而产生焦虑或挫折感；反之会觉得无聊而失去兴趣。沉浸状态主要发生在两者平衡的情况下。两者均低时，使用者的心态为冷漠。<br>后续的研究则开始着重沉浸经验带来的自我肯定，促使使用者的后续学习行为。<br>随计算机科技的发展，沉浸理论延伸至人机互动上的讨论，Webster等人视这种互动具游戏和探索的特质。Ghani和Deshpande(1994)以人机互动对工作的影响进行研究，提出两个沉浸的主要特征：心理享受和完全专注。<br>之后Novak等人研究发现，网络使用行为中，信息寻求最容易进入沉浸，其次为阅读与书写。不同的网络活动型式，如在线游戏、在线购物、E-mail等，也会带来沉浸经验的差异。<br>沉浸体验的发生伴随着九个因素：每一步有明确的目标；对行动有迅速的反馈；挑战和技巧之间的平衡；行动和意识相融合；摒除杂念；不必担心失败；自我意识消失；时间感歪曲；行动具有自身的目的。  </p>
<h2 id="2-5-时延"><a href="#2-5-时延" class="headerlink" title="2.5 时延"></a>2.5 时延</h2><p>指”Motion-To-Photon Latency”, 指的是从用户运动开始到相应画面显示到屏幕上所花的时间.<br><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Test/4-2017-04-24-VR-terminology.png" alt="时延"><br>这中间经过了大概这么几个步骤:  </p>
<ul>
<li>1.传感器采集运动输入数据</li>
<li>2.采集到的数据进行过滤并通过线缆传输到主机</li>
<li>3.游戏引擎根据获取的输入数据更新逻辑和渲染视口</li>
<li>4.提交到驱动并由驱动发送到显卡进行渲染</li>
<li>5.把渲染的结果提交到屏幕, 像素进行颜色的切换</li>
<li>6.用户在屏幕上看到相应的画面  </li>
</ul>
<p>这其中的每一个步骤都会产生一定的延迟, 而目前公认的大众能接受的延迟是20ms以下, 这基本上可以做为衡量一个VR头显是不是合格的一个标准.  </p>
<h2 id="2-6-视角平衡点"><a href="#2-6-视角平衡点" class="headerlink" title="2.6 视角平衡点"></a>2.6 视角平衡点</h2><h2 id="2-7-余晖效应"><a href="#2-7-余晖效应" class="headerlink" title="2.7 余晖效应"></a>2.7 余晖效应</h2><p>人眼在观察景物时，光信号传人大脑神经，需经过一段短暂的时间，光的作用结束后，视觉形象并不立即消失，这种残留的视觉称“后像”，视觉的这一现象则被称为“视觉暂留”.<br>是光对视网膜所产生的视觉在光停止作用后，仍保留一段时间的现象，其具体应用是电影的拍摄和放映。原因是由视神经的反应速度造成的，其时值是二十四分之一秒。是动画、电影等视觉媒体形成和传播的根据。视觉实际上是靠眼睛的晶状体成像，感光细胞感光，并且将光信号转换为神经电流，传回大脑引起人体视觉。感光细胞的感光是靠一些感光色素，感光色素的形成是需要一定时间的，这就形成了视觉暂停的机理.<br>视觉暂留现象首先被中国人发现，走马灯便是据历史记载中最早的视觉暂留运用。宋时已有走马灯 ，当时称 “马骑灯 ”.随后法国人保罗·罗盖在1828年发明了留影盘，它是一个被绳子在两面穿过的圆盘。盘的一个面画了一只鸟，另一面画了一个空笼子。当圆盘旋转时，鸟在笼子里出现了。这证明了当眼睛看到一系列图像时，它一次保留一个图像.<br>物体在快速运动时, 当人眼所看到的影像消失后，人眼仍能继续保留其影像0.1-0.4秒左右的图像，这种现象被称为视觉暂留现象。是人眼具有的一种性质。人眼观看物体时，成像于视网膜上，并由视神经输入人脑，感觉到物体的像。但当物体移去时，视神经对物体的印象不会立即消失，而要延续0.1 -0.4秒的时间，人眼的这种性质被称为“眼睛的视觉暂留”.<br><strong>余晖效应其他例子</strong>：  </p>
<ul>
<li>1.人类死后,普遍认为大脑依然在活动,并且临死前的几分钟记忆死后还会在大脑停留一段时间,这便也是”余晖效应”  </li>
<li>2.旧式电灯关掉电源后,仍然还会亮一小会.这也被称为”余晖效应”</li>
</ul>
<h1 id="3-显示问题"><a href="#3-显示问题" class="headerlink" title="3. 显示问题"></a>3. 显示问题</h1><table>
<thead>
<tr>
<th>显示问题</th>
<th>现象</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td>01.卡顿</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>02.漂移</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>03.倾斜</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>04.跳屏</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>05.闪屏</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>06.花屏</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>07.冻屏</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>08.烧屏</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>09.平面撕裂</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>10.畸变</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>11.拖影</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>VR</tag>
      </tags>
  </entry>
  <entry>
    <title>APP电量消耗测试</title>
    <url>/2017/04/20/2017-04-20-Performance-Battery/</url>
    <content><![CDATA[<p>测试一款APP导致手机发热异常严重，从而想要看一下这款APP所耗电量是一个什么情况，于是就有了下面测试APP电能消耗的相关数据收集。</p>
<h1 id="1-battery"><a href="#1-battery" class="headerlink" title="1. battery"></a>1. battery</h1><p>通过下面的命令可以获取目前手机(SAMSUNG S6)电池信息。</p>
<pre><code>adb shell dumpsys battery</code></pre><p>得到如下返回数据:</p>
<pre><code>Current Battery Service state:
    mBootCompleted: true
    AC powered: false
    USB powered: true
    Wireless powered: false
    Max charging current: 0
    status: 2                              //当前电池状态
    health: 2                              //当前电池健康
    present: true                          //是否提供电池功能；有些手机在使用USB电源的情况下，即使拔出了电池，仍然可以正常工作
    level: 16                              //当前电池剩余容量%
    scale: 100                             //电池最大值；通常为100
    voltage: 3805                          //当前电池电压；单位mV
    temperature: 289                       //当前电池温度；(289/10)℃
    technology: Li-ion                     //当前电池技术；比如，对于锂电池是Li-ion
    batterySWSelfDischarging: false
    batterySecEvent: 0
    LED Charging: false
    LED Low Battery: false
    current now: 325
    Adaptive Fast Charging Settings: true
BatteryInfoBackUp
      mSavedBatteryAsoc: 96
     mSavedBatteryMaxTemp: 677
     mSavedBatteryMaxCurrent: 2638
      mSavedBatteryUsage: 44991
      FEATURE_SAVE_BATTERY_CYCLE: true
USE_FAKE_BATTERY: false
SEC_FEATURE_BATTERY_SIMULATION: false
FEATURE_WIRELESS_FAST_CHARGER_CONTROL: false
      mWasUsedWirelessFastChargerPreviously: false
      mWirelessFastChargingSettingsEnable: true</code></pre><h1 id="2-batterystats"><a href="#2-batterystats" class="headerlink" title="2. batterystats"></a>2. batterystats</h1><pre><code>adb shell dumpsys batterystats &gt; d:\batterystats.txt</code></pre><p>通过文本编辑器打开刚刚保存的文件，并查看Estimated power use (mAh)相关信息，并查看对应uid的耗电信息。 通过batterystats 在Android 6.0以上已可以获取具体APP所消耗的电量值。  </p>
<pre><code>Estimated power use (mAh):
    Capacity: 3000, Computed drain: 436, actual drain: 300-360
    Uid 0: 157 ( cpu=50.2 wake=107 wifi=0.00128 )
    Idle: 154
    Uid 1000: 45.6 ( cpu=43.4 wake=0.616 wifi=0.142 gps=0.228 sensor=1.21 )
    Screen: 22.3
    Cell standby: 14.2 ( radio=14.2 )
    Uid u0a155: 11.2 ( cpu=11.0 wifi=0.0000144 sensor=0.00107 camera=0.152 )
    Uid u0a146: 6.82 ( cpu=6.71 wake=0.00399 wifi=0.000565 sensor=0.107 )
    Wifi: 6.28 ( cpu=0.359 wifi=5.92 )
    Uid 9802: 4.48 ( cpu=2.64 wake=1.54 wifi=0.305 )
    Uid 1036: 3.89 ( cpu=3.89 )
    Uid u0a148: 1.76 ( cpu=0.781 wake=0.982 wifi=0.0000860 )
    Uid 1001: 1.73 ( cpu=1.72 wake=0.0148 )
    Uid u0a10: 1.17 ( cpu=1.17 wifi=0.0000860 )
    Uid u0a102: 0.475 ( cpu=0.467 wake=0.00818 wifi=0.000203 )
    Uid 1023: 0.473 ( cpu=0.473 )
    Uid u0a68: 0.445 ( cpu=0.0219 wake=0.000160 wifi=0.423 )
    Uid u0a54: 0.366 ( cpu=0.248 wake=0.118 )
    Uid u0a74: 0.246 ( cpu=0.246 wifi=0.0000493 )
    Uid u0a157: 0.189 ( cpu=0.189 )
    Uid u0a110: 0.163 ( cpu=0.161 wake=0.00143 wifi=0.000336 )   </code></pre><p>可以通过uid对应到指定的APP，可以获取到对应APP所消耗的电量，并且可以查看到电量主要消耗在哪些部分。</p>
<h1 id="3-电量数据统计"><a href="#3-电量数据统计" class="headerlink" title="3. 电量数据统计"></a>3. 电量数据统计</h1><p>获取了batterystats的数据后，要连续不间断获取对应APP电量消耗的曲线图以查看对应APP电量消耗态势。</p>
<h1 id="4-historian数据分析"><a href="#4-historian数据分析" class="headerlink" title="4. historian数据分析"></a>4. historian数据分析</h1><ol>
<li>下载historian.py脚本，下载地址:<a href="https://github.com/google/battery-historian" target="_blank" rel="noopener">https://github.com/google/battery-historian</a>.</li>
<li>执行步骤:<br> 1)初始化batterystats数据<br> <code>adb shell dumpsys batterystats --reset</code><br> 2）拔掉手机，操作app，操作完成后，重新连接手机，执行下面的命令，收集系统整体的Battery数据:<br> <code>adb shell dumpsys batterystats &gt; batterystats.txt</code><br> 3）得到这些数据后，这个时候使用我们的battery-historian来生成我们可见HTML报告:<br> <code>Python historian.py batterystats.txt &gt; batterystats.html</code><br> 4）用浏览器打开此文件即可  </li>
</ol>
<p>通过脚本historan.py生成对应的HTML可视化数据。<br><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Test/1-2017-04-20-Performance-Battery.png" alt="batterystats可视化数据"><br><a href="./resource/Test/batterystats-2017-04-20-Performance-Battery.html">Check HTML</a></p>
<h1 id="5-电量统计小工具"><a href="#5-电量统计小工具" class="headerlink" title="5. 电量统计小工具"></a>5. 电量统计小工具</h1><h2 id="1-PowerTutor"><a href="#1-PowerTutor" class="headerlink" title="1.PowerTutor"></a>1.PowerTutor</h2><p>Google强大的功耗测试工具。1.显示系统电量消耗水平，包括LCD/OLED，CPU,WiFi，3G，GPS和Audio；2.查看某段时间内所有运行中的应用程序的耗电量。<br>详见<a href="http://ziyang.eecs.umich.edu/projects/powertutor/" target="_blank" rel="noopener">http://ziyang.eecs.umich.edu/projects/powertutor/</a>。</p>
<h2 id="2-Battery-Monitor-Widget"><a href="#2-Battery-Monitor-Widget" class="headerlink" title="2.Battery Monitor Widget"></a>2.Battery Monitor Widget</h2><p>高度可定制化的电量监控小工具，不仅可以显示当前电量，估算剩余电量支撑时间，还可以一目了然地检测出各个APP的耗电历史，从而方便进行比较。详见<a href="https://play.google.com/store/apps/details?id=ccc71.bmw" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=ccc71.bmw</a>。</p>
<h2 id="3-Smart-Battery-Monitor"><a href="#3-Smart-Battery-Monitor" class="headerlink" title="3.Smart Battery Monitor"></a>3.Smart Battery Monitor</h2><p>除了可以在状态栏显示电池消耗百分比外，还可以显示电池的温度，以及已充电时间。详见<a href="https://play.google.com/store/apps/details?id=at.aauer1.battery" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=at.aauer1.battery</a>。</p>
<h2 id="4-Battery-Indicator"><a href="#4-Battery-Indicator" class="headerlink" title="4.Battery Indicator"></a>4.Battery Indicator</h2><p>亮点是轻便、小巧，甚至使用它时不会消耗电池。当然，它可以显示电池的电量百分比、电池的温度、以及电池的健康信息。详见<a href="https://play.google.com/store/apps/details?id=com.darshancomputing.BatteryIndicator" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.darshancomputing.BatteryIndicator</a>。</p>
<h2 id="5-Battery-Widget"><a href="#5-Battery-Widget" class="headerlink" title="5.Battery Widget"></a>5.Battery Widget</h2><p>这个工具不仅是一个电池Widget，还可以作为显示选项，GPS，WiFi，蓝牙选项等的快捷方式。详见<a href="https://play.google.com/store/apps/details?id=com.geekyouup.android.widgets.battery" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.geekyouup.android.widgets.battery</a>。</p>
<h2 id="6-Battery-Saver"><a href="#6-Battery-Saver" class="headerlink" title="6.Battery Saver"></a>6.Battery Saver</h2><p>被称为管理电池的最强大应用之一。除了显示电量信息，电池温度和健康信息外，它还可以快速管理一些耗电量大的应用如：GPS，WiFi，蓝牙等。另外：该工具可以查看一天之内的哪个时间点电池的耗电量最大。详见<a href="https://play.google.com/store/apps/details?id=com.antutu.powersaver" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.antutu.powersaver</a></p>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>性能测试</tag>
      </tags>
  </entry>
  <entry>
    <title>VR发展过程中产品的市场形态与优缺点</title>
    <url>/2017/04/24/2017-04-24-VR-history/</url>
    <content><![CDATA[<h1 id="1-VR"><a href="#1-VR" class="headerlink" title="1. VR"></a>1. VR</h1><p>Virtual Reality，即虚拟现实，简称VR。是利用电脑模拟产生一个三维空间的虚拟世界，提供用户关于视觉等感官的模拟，让用户感觉仿佛身历其境，可以及时、没有限制地观察三维空间内的事物。用户进行位置移动时，电脑可以立即进行复杂的运算，将精确的三维世界视频传回产生临场感。该技术集成了计算机图形、计算机仿真、人工智能、感应、显示及网络并行处理等技术的最新发展成果，是一种由计算机技术辅助生成的高技术模拟系统。</p>
<h1 id="2-VR发展历史"><a href="#2-VR发展历史" class="headerlink" title="2. VR发展历史"></a>2. VR发展历史</h1><p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Test/1-2017-04-24-VR-history.png" alt="VR发展历史"></p>
<h1 id="3-VR产品市场形态"><a href="#3-VR产品市场形态" class="headerlink" title="3. VR产品市场形态"></a>3. VR产品市场形态</h1><p>按照目前VR的硬件形态来划分，VR头戴设备主要分为三种： </p>
<ul>
<li>1、移动端头显(俗称手机VR)  </li>
<li>2、一体机头显（VR一体机）  </li>
<li>3、外接头戴式设备（需要外接主机）  <h2 id="3-1-移动端头显"><a href="#3-1-移动端头显" class="headerlink" title="3.1 移动端头显"></a>3.1 移动端头显</h2>移动端头显也就是所谓的VR眼镜盒子，只要放入手机即可观看。如小宅z4，暴风魔镜等等，相当于纸盒vr的进阶，价格在几十到数百不等。  <h2 id="3-2-一体机头显"><a href="#3-2-一体机头显" class="headerlink" title="3.2 一体机头显"></a>3.2 一体机头显</h2>一体机头显，它具有独立CPU、输入和输出显示功能，完全摆脱外置设备。如现在比较火的大朋vr。一体机形态，算得上是真正意义上的VR独立产品，不受空间约束和其他外部影响，但目前VR一体机的问题在于技术门槛过高、成本过高，做起来还是有一定难度的。  <h2 id="3-3-外接头戴式设备"><a href="#3-3-外接头戴式设备" class="headerlink" title="3.3 外接头戴式设备"></a>3.3 外接头戴式设备</h2>外接头戴式设备也称为PC端头显，需要将其连接电脑才能进行观看，如htc vive，oculus.这一类的vr目前是最好的，属于专业级的眼镜，用户体验非常好，但是价格也非常昂贵，而且需要一般需要搭配970以上显卡，使用成本很高。想要玩的话，不光是要买一个VR，还需要采购配套的主机设备。除此之外，由于外接头戴式设备，需连接PC、PS4等主机设备进行互动，在体验一些可活动的游戏时必将受到数据线的束缚，PC端VR也许将来会广泛应用于vr体验馆之类的地方。<h2 id="3-4-优缺点比较"><a href="#3-4-优缺点比较" class="headerlink" title="3.4 优缺点比较"></a>3.4 优缺点比较</h2></li>
</ul>
<table>
<thead>
<tr>
<th>产品</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>移动端头显</td>
<td>1.简便  2.价格便宜</td>
<td>1.效果差  2.需要外联设备</td>
</tr>
<tr>
<td>一体机头显</td>
<td>1.完全摆脱外置设备  2.携带方便</td>
<td>1.价格偏高</td>
</tr>
<tr>
<td>外接头戴式设备</td>
<td>1.体验好，效果逼真  2.辅助设备要求高</td>
<td>1.潜在成本高  2.需要外联设备，使用局限性较大</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>VR</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell带颜色输出</title>
    <url>/2017/04/25/2017-04-25-Shell-ColorOutput/</url>
    <content><![CDATA[<p>如何在Linux下Shell脚本输出带颜色文字：<br>    echo -e “\033[44;37;5m ME \033[0m”<br><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Tools/1-2017-04-25-Shell-ColorOutput.gif" alt="Output"><br>以上命令设置作用如下：背景色为蓝色，前景色为白色，字体闪烁，输出字符ME，然后重新设置屏幕到缺省设置，输出字符me后颜色回复正常。</p>
<ul>
<li>e ：是echo的一个可选项，它用于激活特殊字符的解析器。</li>
<li>\033 ：引导非常规字符序列。意味着设置属性然后结束非常规字符序列，这个例子里真正有效的字符是44;37;5。</li>
<li>44;37;5和0 ： 修改44;37;5可以生成不同颜色的组合，数值和编码的前后顺序没有关系</li>
</ul>
<p>可以选择的编码如下所示：</p>
<table>
<thead>
<tr>
<th>编码</th>
<th>颜色/动作</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>重新设置属性到缺省设置</td>
</tr>
<tr>
<td>1</td>
<td>设置粗体</td>
</tr>
<tr>
<td>2</td>
<td>设置一半亮度(模拟彩色显示器的颜色)</td>
</tr>
<tr>
<td>4</td>
<td>设置下划线(模拟彩色显示器的颜色)</td>
</tr>
<tr>
<td>5</td>
<td>设置闪烁</td>
</tr>
<tr>
<td>7</td>
<td>设置反向图象</td>
</tr>
<tr>
<td>22</td>
<td>设置一般密度</td>
</tr>
<tr>
<td>24</td>
<td>关闭下划线</td>
</tr>
<tr>
<td>25</td>
<td>关闭闪烁</td>
</tr>
<tr>
<td>27</td>
<td>关闭反向图象</td>
</tr>
<tr>
<td>30</td>
<td>设置黑色前景</td>
</tr>
<tr>
<td>31</td>
<td>设置红色前景</td>
</tr>
<tr>
<td>32</td>
<td>设置绿色前景</td>
</tr>
<tr>
<td>33</td>
<td>设置棕色前景</td>
</tr>
<tr>
<td>34</td>
<td>设置蓝色前景</td>
</tr>
<tr>
<td>35</td>
<td>设置紫色前景</td>
</tr>
<tr>
<td>36</td>
<td>设置青色前景</td>
</tr>
<tr>
<td>37</td>
<td>设置白色前景</td>
</tr>
<tr>
<td>38</td>
<td>在缺省的前景颜色上设置下划线</td>
</tr>
<tr>
<td>39</td>
<td>在缺省的前景颜色上关闭下划线</td>
</tr>
<tr>
<td>40</td>
<td>设置黑色背景</td>
</tr>
<tr>
<td>41</td>
<td>设置红色背景</td>
</tr>
<tr>
<td>42</td>
<td>设置绿色背景</td>
</tr>
<tr>
<td>43</td>
<td>设置棕色背景</td>
</tr>
<tr>
<td>44</td>
<td>设置蓝色背景</td>
</tr>
<tr>
<td>45</td>
<td>设置紫色背景</td>
</tr>
<tr>
<td>46</td>
<td>设置青色背景</td>
</tr>
<tr>
<td>47</td>
<td>设置白色背景</td>
</tr>
<tr>
<td>49</td>
<td>设置缺省黑色背景</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  Author:    Tester</span></span><br><span class="line"><span class="meta">#</span><span class="bash">comments:    Start the services and the sites with shell</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    Date:    2016-05-11</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="keyword">function</span>:    重启tomcat中在执行或未执行的程序或服务示例.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">获取配置文件中需要重启的程序，记录示例：on    /tomcat/tomcat_TestService | off    /tomcat/tomcat_TestService</span></span><br><span class="line">service_conf="/tomcat/tomcat_conf/service.config"</span><br><span class="line">count=1</span><br><span class="line">cat $&#123;service_conf&#125; | grep -v "^#" | while read is_on service_dir</span><br><span class="line">do</span><br><span class="line">    exe_start_dir="$&#123;service_dir&#125;/bin/startup.sh"</span><br><span class="line">    exe_shutdown_dir="$&#123;service_dir&#125;/bin/shutdown.sh"</span><br><span class="line">    if [[ $&#123;is_on&#125; = "on" ]]</span><br><span class="line">    then</span><br><span class="line">        num=$(ps -ef | grep $&#123;service_dir&#125; | grep -v "grep" | wc -l)    </span><br><span class="line">        echo -e "\033[41;32;1m共有$&#123;num&#125;个运行进程:$&#123;service_dir&#125;\033[0m"</span><br><span class="line">        if [[ $&#123;num&#125; -ge 1 ]]</span><br><span class="line">        then</span><br><span class="line">            echo -e "\033[40;32;1m结束已存在的进程:\033[0m"        </span><br><span class="line">            bash $exe_shutdown_dir</span><br><span class="line">            echo -e "\033[40;32;1m重新启动程序$&#123;service_dir&#125;:\033[0m"</span><br><span class="line">            sleep 5</span><br><span class="line">            bash $exe_start_dir</span><br><span class="line">        else</span><br><span class="line">            if [[ $&#123;num&#125; -gt 1 ]]</span><br><span class="line">            then</span><br><span class="line">                echo -e "\033[47;32;1m存在$&#123;num&#125;个运行的同一线程，结束端口号为：$&#123;tmp2&#125;的进程：\033[0m"</span><br><span class="line">                kill $&#123;tmp2&#125;</span><br><span class="line">            else                    </span><br><span class="line">                echo -e "\033[40;32;1m程序$&#123;service_dir&#125;未启动，现启动程序...\033[0m"</span><br><span class="line">                    bash $exe_start_dir</span><br><span class="line">            fi</span><br><span class="line">        fi</span><br><span class="line">        result_num=$(ps -ef | grep $&#123;service_dir&#125; | grep -v "grep" | wc -l)</span><br><span class="line">        echo -e "\033[40;34;1m***************Query Result : $&#123;result_num&#125;***********************\033[0m"</span><br><span class="line">        ps -ef | grep $&#123;service_dir&#125; | grep -v "grep"</span><br><span class="line">        echo -e "\033[40;34;1m************************************************************\033[0m"</span><br><span class="line">    else        </span><br><span class="line">        echo -e "\033[40;34;1m*************************** Tips $&#123;count&#125;**************************\033[0m"</span><br><span class="line">        echo -e "\033[40;31;1mThis program $&#123;service_dir&#125; is turned off.\033[0m"</span><br><span class="line">        echo -e "\033[40;34;1m************************************************************\033[0m"</span><br><span class="line">        ((count++))</span><br><span class="line">    fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>筛选指定尺寸的图片</title>
    <url>/2017/04/26/2017-04-26-Python-FilterPicture/</url>
    <content><![CDATA[<p>筛选出指定文件夹下指定尺寸的图片，需要用到python <a href="http://www.pythonware.com/products/pil/" target="_blank" rel="noopener">PIL库</a>.<br><strong>注：</strong>  </p>
<ul>
<li>在安装PIL库的过程中碰到过python未注册的情况，提示：<code>python version 2.7 required,which was not found in the registry.</code>  </li>
<li>处理办法,本地执行如下代码 <a href="./resource/Programing/Register.py">Register</a>  </li>
</ul>
<p>通过如下代码获取对应图片尺寸：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">img = Image.open(self.pic_path)</span><br><span class="line"><span class="keyword">print</span> img.size</span><br></pre></td></tr></table></figure>

<p>通过遍历文件夹下所有图片尺寸，筛选出符合要求的图片.</p>
<p>代码示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="comment"># Copyright 2017 yaitza. All Rights Reserved.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     https://yaitza.github.io/</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># My Code hope to usefull for you.</span></span><br><span class="line"><span class="comment"># ===================================================================</span></span><br><span class="line"></span><br><span class="line">__author__ = <span class="string">"yaitza"</span></span><br><span class="line">__date__ = <span class="string">"2017-04-26 13:59"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImageHandler</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, pic_path)</span>:</span></span><br><span class="line">        self.pic_path = pic_path</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getPicSize</span><span class="params">(self, maxSize, minSize)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            img = Image.open(self.pic_path)</span><br><span class="line">        <span class="keyword">except</span> IOError:</span><br><span class="line">            <span class="keyword">print</span> self.pic_path + <span class="string">" Error!"</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> max(img.size) &lt;= maxSize <span class="keyword">and</span> max(img.size) &gt;= minSize <span class="keyword">and</span> min(img.size) &gt;= minSize <span class="keyword">and</span> min(img.size) &lt;= maxSize:</span><br><span class="line">            <span class="keyword">return</span> img.size</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileHandler</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, file_path)</span>:</span></span><br><span class="line">        self.file_path = file_path</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getAllFiles</span><span class="params">(self)</span>:</span></span><br><span class="line">        fileList = os.listdir(self.file_path)</span><br><span class="line">        file_dir = []</span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> fileList:</span><br><span class="line">            file_dir.append(self.file_path + <span class="string">"/"</span> + file)</span><br><span class="line">        useFileList = []</span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> file_dir:</span><br><span class="line">            im = ImageHandler(file)</span><br><span class="line">            <span class="keyword">if</span> im.getPicSize(<span class="number">1204</span>, <span class="number">480</span>) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                useFileList.append(file)</span><br><span class="line">        <span class="keyword">return</span> useFileList</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    file_path = <span class="string">"E:/内容素材/图片/美女图"</span></span><br><span class="line">    uipath = unicode(file_path, <span class="string">"utf8"</span>)</span><br><span class="line">    fh = FileHandler(uipath)</span><br><span class="line">    fh.getAllFiles()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Robot Framwork环境搭建</title>
    <url>/2017/04/27/2017-04-27-RF-Install/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;工作中接触到Robot Framework这个测试框架，突然发现其既可以进行UI自动化测试也可以进行接口自动化测试；发现真是一个不错的测试框架，于是就把学习的过程记录下来，希望对阅读到这片文章的人有用。  </p>
<h1 id="1-Robot-Framwork环境准备"><a href="#1-Robot-Framwork环境准备" class="headerlink" title="1. Robot Framwork环境准备"></a>1. Robot Framwork环境准备</h1><ul>
<li>1.<a href="https://www.python.org/downloads/" target="_blank" rel="noopener">Python</a><br>python安装过程中记得勾选将python加入环境变量PATH的选项。添加环境变量成功后，在windows cmd命令窗口下输入python会有如下图信息显示。<br><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Tools/1-2017-04-27-RF-Install.png" alt="提示信息"><br>正常情况Windows对应python的安装包均带有如下两个模块，如没有请自行安装如下类库。 <ul>
<li><a href="https://pypi.python.org/pypi/setuptools" target="_blank" rel="noopener">SetupTools</a>  </li>
<li><a href="https://pypi.python.org/pypi/pip/" target="_blank" rel="noopener">pip</a></li>
</ul>
</li>
<li>2.<a href="https://github.com/robotframework/robotframework/releases" target="_blank" rel="noopener">Robot Framework</a><br>安装方法：解压缩tar.gz文件，在cmd命令行窗口进入解压出来的目录，输入<code>python setup.py install</code>,然后按回车键等待安装完成。或者直接运行<code>pip install robotframework</code>。<br><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Tools/2-2017-04-27-RF-Install.png" alt="pip install RobotFramework">  </li>
<li>3.<a href="https://wxpython.org/download.php" target="_blank" rel="noopener">wxPython</a><br>wxPython用于支持Python图形化界面，安装它主要是用来运行RIDE。<br>官方下载也罪行微信Python版本已迭代至3.0.2.0版本，但是RIDE本身并未说明是否支持3.0版本；但是安装wxPython 3.0.2.0版本后运行RIDE后提示如下信息：<br><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Tools/4-2017-04-27-RF-Install.png" alt="Ride Error"><br>于是只有按照提示信息安装2.8.12.1版本wxPython。</li>
<li>4.<a href="https://github.com/robotframework/RIDE/releases" target="_blank" rel="noopener">robotframework-ride</a><br>安装方法：解压缩tar.gz文件，在cmd命令行窗口进入解压出来的目录，输入<code>python setup.py install</code>,然后按回车键等待安装完成。或者直接运行<code>pip install robotframework-ride</code>。<br><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Tools/3-2017-04-27-RF-Install.png" alt="pip install RobotFramework-ride"></li>
</ul>
<p>运行如下脚本：<br><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Tools/5-2017-04-27-RF-Install.png" alt="ride start"><br>RIDE图像界面如下图显示，代表Robot Framework环境搭建完成。<br><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Tools/6-2017-04-27-RF-Install.png" alt="ride"> </p>
<h1 id="2-设置图标显示"><a href="#2-设置图标显示" class="headerlink" title="2.设置图标显示"></a>2.设置图标显示</h1><ul>
<li>新建-&gt;快捷方式；</li>
<li>“请键入对象位置(T):”输入命令<code>C:\Python27\pythonw.exe -c &quot;from robotide import main; main()&quot;</code>；<br><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Tools/7-2017-04-27-RF-Install.png" alt="ride"> </li>
<li>“键入快捷方式的名称(T):”输入<code>RIDE</code>；   </li>
<li>双击图标将弹出RIDE主界面。<br><code>当然可以更改快捷方式的图标，RIDE提供图标目录C:\Python27\Lib\site-packages\robotide\widgets\robot.ico</code><br><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Tools/8-2017-04-27-RF-Install.png" alt="ride"> </li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Robot Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>UML用例图</title>
    <url>/2017/05/13/2017-05-13-UML-Case/</url>
    <content><![CDATA[<h1 id="1-概要"><a href="#1-概要" class="headerlink" title="1. 概要"></a>1. 概要</h1><p><strong>用例图</strong>主要用来描述“用户、需求、系统功能单元”之间的关系。它展示了一个外部用户能够观察到的系统功能模型图。<br>【用途】：帮助开发团队以一种可视化的方式理解系统的功能需求。</p>
<h1 id="2-UML用例图构成"><a href="#2-UML用例图构成" class="headerlink" title="2. UML用例图构成"></a>2. UML用例图构成</h1><h2 id="2-1-参与者-Actor"><a href="#2-1-参与者-Actor" class="headerlink" title="2.1 参与者(Actor)"></a>2.1 参与者(Actor)</h2><pre><code>表示与您的应用程序或系统进行交互的用户、组织或外部系统。用一个小人表示。  </code></pre><p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Tools/1-2017-05-13-UML-Case.png" alt="Actor"> </p>
<h2 id="2-2-用例-Use-Case"><a href="#2-2-用例-Use-Case" class="headerlink" title="2.2 用例(Use Case)"></a>2.2 用例(Use Case)</h2><pre><code>用例就是外部可见的系统功能，对系统提供的服务进行描述。用椭圆表示。  </code></pre><p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Tools/2-2017-05-13-UML-Case.png" alt="UserCase"> </p>
<h2 id="2-3-子系统-Subsystem"><a href="#2-3-子系统-Subsystem" class="headerlink" title="2.3 子系统(Subsystem)"></a>2.3 子系统(Subsystem)</h2><pre><code>用来展示系统的一部分功能，这部分功能联系紧密。  </code></pre><p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Tools/3-2017-05-13-UML-Case.png" alt="Subsystem"> </p>
<h2 id="2-4-关系-Relationship"><a href="#2-4-关系-Relationship" class="headerlink" title="2.4 关系(Relationship)"></a>2.4 关系(Relationship)</h2><pre><code>用例图中涉及的关系有：关联、范化、包含、扩展。  </code></pre><p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Tools/4-2017-05-13-UML-Case.png" alt="Relationship">  </p>
<h3 id="2-4-1-关联-Association"><a href="#2-4-1-关联-Association" class="headerlink" title="2.4.1 关联(Association)"></a>2.4.1 关联(Association)</h3><pre><code>表示参与者与用例之间的通信，任何一方都可发送或接受消息。  </code></pre><p>【箭头指向】：指向消息接收方(Microosoft Visio 2013提供的UML用例图绘制没有箭头指向)   </p>
<p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Tools/5-2017-05-13-UML-Case.png" alt="Association">  </p>
<h3 id="2-4-2-泛化-Inheritance"><a href="#2-4-2-泛化-Inheritance" class="headerlink" title="2.4.2 泛化(Inheritance)"></a>2.4.2 泛化(Inheritance)</h3><pre><code>就是通常理解的继承关系，子用例和父用例相似，但表现出更特别的行为；子用例将继承父用例的所有结构、行为和关系。  
子用例可以使用父用例的一段行为，也可以重载它。父用例通常是抽象的。</code></pre><p>【箭头指向】：指向父用例(Microosoft Visio 2013提供的UML用例图绘制没有箭头指向)  </p>
<p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Tools/6-2017-05-13-UML-Case.png" alt="Inheritance">    </p>
<h3 id="2-4-3-包含-Include"><a href="#2-4-3-包含-Include" class="headerlink" title="2.4.3 包含(Include)"></a>2.4.3 包含(Include)</h3><pre><code>包含关系用来把一个较复杂用例所表示的功能分解成较小的步骤。  </code></pre><p>【箭头指向】：指向分解出来的功能用例  </p>
<p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Tools/7-2017-05-13-UML-Case.png" alt="Include">    </p>
<h3 id="2-4-4-扩展-Extend"><a href="#2-4-4-扩展-Extend" class="headerlink" title="2.4.4 扩展(Extend)"></a>2.4.4 扩展(Extend)</h3><pre><code>扩展关系是指用例功能的延伸，相当于为基础用例提供一个附加功能。</code></pre><p>【箭头指向】：指向基础用例  </p>
<p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Tools/8-2017-05-13-UML-Case.png" alt="Extend">    </p>
<h3 id="2-4-5-依赖-Dependency"><a href="#2-4-5-依赖-Dependency" class="headerlink" title="2.4.5 依赖(Dependency)"></a>2.4.5 依赖(Dependency)</h3><pre><code>表示源用例依赖于目标用例。</code></pre><p>【箭头指向】：指向被依赖项  </p>
<p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Tools/9-2017-05-13-UML-Case.png" alt="Dependency">  </p>
<h1 id="3-包含-include-、扩展-extend-、泛化-Inheritance-的区别"><a href="#3-包含-include-、扩展-extend-、泛化-Inheritance-的区别" class="headerlink" title="3. 包含(include)、扩展(extend)、泛化(Inheritance) 的区别"></a>3. 包含(include)、扩展(extend)、泛化(Inheritance) 的区别</h1><p>条件性：泛化中的子用例和include中的被包含的用例会无条件发生，而extend中的延伸用例的发生是有条件的。<br>直接性：泛化中的子用例和extend中的延伸用例为参与者提供直接服务，而include中被包含的用例为参与者提供间接服务。<br>对extend而言，延伸用例并不包含基础用例的内容，基础用例也不包含延伸用例的内容。<br>对Inheritance而言，子用例包含基础用例的所有内容及其和其他用例或参与者之间的关系。</p>
<p>一个用例图示例:  </p>
<p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Tools/10-2017-05-13-UML-Case.png" alt="Example"></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title>adb介绍</title>
    <url>/2017/05/03/2017-05-03-Intro-adb/</url>
    <content><![CDATA[<h1 id="1-概要"><a href="#1-概要" class="headerlink" title="1. 概要"></a>1. 概要</h1><p><code>Android Debug Bridge(adb)</code>是一个Android的命令行工具，可以用来连接模拟器或实际的移动设备。做过Android开发的朋友一定对<strong>adb logcat</strong>, <strong>adb shell</strong>命令不陌生，<strong>Dalvik Debug Monitor Server(DDMS)</strong>后台也是运行的adb来实现监控调试移动设备。</p>
<p>总体而言，adb有两个用途：</p>
<ul>
<li><p><strong>监控连接设备</strong> adb会监控所有已经连接设备(包括模拟器)，譬如设备所处的状态：ONLINE，OFFLINE, BOOTLOADER或RECOVERY。</p>
</li>
<li><p><strong>提供操作命令</strong> adb提供了很多命令(adb shell, adb pull)，来实现对设备的操控。这些操作命令在adb的体系里面，都称为“服务”。</p>
</li>
</ul>
<hr>
<h1 id="2-工作原理"><a href="#2-工作原理" class="headerlink" title="2. 工作原理"></a>2. 工作原理</h1><p>adb的工作原理可以用下图来表示：</p>
<div align="center"><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Tools/1-2017-05-03-Intro-adb.png" /></div>

<p>adb命令执行会涉及到三个组成部分(client, server，daemon)和两个数据通道，下面我们将深入对adb的工作原理进行介绍。</p>
<h2 id="2-1-adb的三个组成元素"><a href="#2-1-adb的三个组成元素" class="headerlink" title="2.1 adb的三个组成元素"></a>2.1 adb的三个组成元素</h2><ul>
<li><p><strong>adb client</strong><br>在本地客户端的可执行程序，下载Android SDK便可获取这个执行程序，通过在命令行执行adb，就启动了adb的本地客户端程序。我们常用的命令，<strong>adb devices, adb shell, adb logcat</strong>，都是先交由本地客户端程序处理的。</p>
</li>
<li><p><strong>adb server</strong><br>本地客户端并不能独立完成工作，当我们输入adb命令时，客户端会尝试连接本地的服务端程序。如果服务端程序没有启动，则启动一个本地的服务端程序。为什么客户端输入adb命令能够自动启动服务端呢？因为客户端和服务端实际上是集成在一个可执行程序里面的，在Linux系统上，是<code>adb</code>；在Windows系统上，是<code>adb.exe</code></p>
</li>
<li><p><strong>adb daemon(adbd)</strong><br>在模拟器或移动设备上运行的后台服务。当Android系统起机的时候，由init程序启动adbd。如果adbd挂了，则adbd会由init重新启动。换言之，只要Android系统在运行，那<code>adbd</code>就是“不死的”，常年在伺服状态。</p>
</li>
</ul>
<p>client和server虽然是同一个执行程序，但在命令行输入一条adb命令后，实际上完成了一次通信。在server启动的时候，会将自己绑定到本地的<code>5037</code>端口，当client有请求到来时，便通过TCP连接server的5037端口。</p>
<p>通过以下命令，可以看到server的启动日志：</p>
<p>bash<br>$ adb kill-server &amp;&amp; adb devices</p>
<ul>
<li>daemon not running. starting it now on port 5037 *</li>
<li>daemon started successfully *<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">通过以下命令，可以看到TCP的5037端口，在侦听连接：</span><br><span class="line"></span><br><span class="line">bash</span><br><span class="line">$ netstat -l | grep 5037</span><br><span class="line">Proto Recv-Q Send-Q    Local Address   Foreign Address     State</span><br><span class="line">tcp        0      0    127.0.0.1:5037  0.0.0.0:*           LISTEN</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>当我们执行一些常用的adb命令时，譬如<strong>adb devices，adb shell</strong>, server就自动启动了，也可以通过adb start-server来启动；如果想要停止server的运行，可以通过adb kill-server来杀掉server进程。</p>
<p>server只有一个，但client是可以有多个的。打开两个命令行，都输入<strong>adb shell</strong>命令，然后，再在第三个命令行输入以下命令，查看输出结果：</p>
<p>bash<br>$ lsof -i | grep adb<br>COMMAND   PID   TYPE DEVICE NODE NAME<br>adb     23613   IPv4 402225 TCP  localhost:38491-&gt;localhost:5037 (ESTABLISHED)<br>adb     23710   IPv4 407399 TCP  localhost:38494-&gt;localhost:5037 (ESTABLISHED)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">可以看到，建立了两个TCP连接，端口号的对应关系分别是：38491到5037, 38494到5037。这说明，多个clients可以同时和server建立连接。</span><br><span class="line"></span><br><span class="line">## 2.2 adb的两个数据通道</span><br><span class="line"></span><br><span class="line">### 2.2.1 client与server的数据通道</span><br><span class="line"></span><br><span class="line">这个数据通道是一个本地TCP连接，adb server启动以后，在本地的5037端口侦听。adb client通过本地的随机端口与5037端口建立连接。</span><br><span class="line"></span><br><span class="line">在这个通道上，client向server发送的命令都遵循如下格式：</span><br><span class="line"></span><br><span class="line">1. 命令的长度(Length)，由四位的十六进制表示</span><br><span class="line">2. 实际的命令(Payload)，通过ASCII编码</span><br><span class="line"></span><br><span class="line">譬如，查看adb当前的版本，client会发起如下命令：</span><br><span class="line"></span><br><span class="line">    000Chost:version</span><br><span class="line"></span><br><span class="line">000C表示&quot;host:version&quot;这条命令的长度为12个字节。命令中使用了host前缀，目的是为了区分其他类型的命令(后面还会看到shell前缀的命令)，host前缀的命令可以理解为只在client与server这个数据通道上存在。</span><br><span class="line"></span><br><span class="line">server收到client的请求后，返回的数据遵循如下格式：</span><br><span class="line"></span><br><span class="line">1. 如果成功，则返回四个字节的字符串&quot;OKAY&quot;</span><br><span class="line">2. 如果失败，则返回四个字节的字符串&quot;FAIL&quot;和出错原因</span><br><span class="line">3. 如果异常，则返回错误码</span><br><span class="line"></span><br><span class="line">当Client收到Server返回的&quot;OKAY&quot;后，就可以发继续发起其他操作命令了。</span><br><span class="line"></span><br><span class="line">### 2.2.2 **server与adbd的数据通道**</span><br><span class="line"></span><br><span class="line">这个数据通道对client而言，完全是透明的，client不关注这个通道怎么建立以及怎么进行数据传输。</span><br><span class="line"></span><br><span class="line">当连接模拟器时，这个数据通道也是一个本地的TCP连接;当连接实际的设备时，这个数据通道通常是USB数据线的连接，当前，adb也支持远程的TCP连接。</span><br><span class="line"></span><br><span class="line">adb server启动后，会在5037端口侦听从client发起的TCP连接，同时，也会试图与**5555~5585**这些端口建立TCP连接。当Android模拟器启动或者手机连接上PC时，就会用到**5555~5585**这些端口，简单理解就是adbd在PC上占用的端口号。每一个adbd都会占用两个端口，一个偶数号端口，用于命令行的连接；一个奇数号端口，用于adb的连接。</span><br><span class="line"></span><br><span class="line">client与adbd的数据传输是需要用到两个通道的，当与server建立第一个通道的连接后，需要向server发送**transport**命令，表示接下来，要与adbd进行数据传输。**transport**命令有以下一些形式：</span><br><span class="line"></span><br><span class="line">- **host:transport:&lt;serial-number&gt;** 用于向指定的设备发送transport命令</span><br><span class="line">- **host:transport-usb** 用于向USB连接的设备发送transport命令，当有多个设备通过USB连接时，server会返回“FAIL”</span><br><span class="line">- **host:transport-local** 用于向模拟器发送transport命令，当有多个模拟器启动时，server会返回“FAIL”</span><br><span class="line">- **host:transport-any** 用于向任何连接的设备或模拟器发送transport命令，有多个连接时，server会返回“FAIL”</span><br><span class="line"></span><br><span class="line">当server返回“OKAY”后，client后续发送的数据，就直接传输到adbd了。譬如&#96;shell:command arg1 arg2 ...&#96;命令，表示client往adbd发送的shell命令。</span><br><span class="line"></span><br><span class="line">下图是在客户端输入&#96;adb shell ls&#96;命令后，adb的一个工作时序：</span><br><span class="line"></span><br><span class="line">&lt;div align&#x3D;&quot;center&quot;&gt;&lt;img src&#x3D;&quot;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;yaitza&#x2F;yaitza.github.io&#x2F;master&#x2F;images&#x2F;images&#x2F;&#x2F;Tools&#x2F;2-2017-05-03-Intro-adb.png&quot; &#x2F;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">***</span><br><span class="line"></span><br><span class="line"># 3. 其他</span><br><span class="line"></span><br><span class="line">## 3.1 源码目录</span><br><span class="line"></span><br><span class="line">adb的源码在system&#x2F;core&#x2F;adb目录下，adb和adbd两个二进制程序都是从这个目录下的代码中编译出来的，通过宏编译开关**ADB_HOST**来控制：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96; c</span><br><span class="line">#if ADB_HOST</span><br><span class="line">&#x2F;* code for adb *&#x2F;</span><br><span class="line">#else</span><br><span class="line">&#x2F;* code for adbd *&#x2F;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>


<h2 id="3-2-USB-Vendor-ID"><a href="#3-2-USB-Vendor-ID" class="headerlink" title="3.2 USB Vendor ID"></a>3.2 USB Vendor ID</h2><p>当通过USB线连接手机时，adb需要检查手机厂商的ID，即Vendor ID。<br>adb已经内置了很多Vendor ID，但仍然不能涵盖所有的手机厂商。</p>
<p>当出现adb无法找到设备时，我们需要手工添加Vendor ID，如何知道手机厂商的Vendor ID是多少呢？ 通过<code>lsusb</code>命令可以查看：</p>
<p>bash<br>duanqizhi@xo:~$ lsusb<br>Bus 002 Device 005: ID 413c:2107 Dell Computer Corp.<br>Bus 002 Device 004: ID 046d:c077 Logitech, Inc.<br>Bus 002 Device 003: ID 0424:2514 Standard Microsystems Corp. USB 2.0 Hub<br>Bus 002 Device 002: ID 8087:8000 Intel Corp.<br>Bus 002 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub<br>Bus 001 Device 021: ID 2a45:0003<br>Bus 001 Device 002: ID 8087:8008 Intel Corp.<br>Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub</p>
<pre><code>
无法识别设备的Vendor ID就是**2a45**，在**$HOME/.android/adb_usb.ini**文件末尾，将添加一行**2a45**即可。

## 3.3 几条有趣的adb命令

bash
$ adb hell
$ adb lolcat</code></pre><p>本文引用至 <a href="http://duanqz.github.io/2015-05-21-Intro-adb" target="_blank" rel="noopener">http://duanqz.github.io/2015-05-21-Intro-adb</a>.</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>单点登陆SSO（Single Sign-On）</title>
    <url>/2017/05/15/2017-05-15-SSO/</url>
    <content><![CDATA[<h1 id="1-概要"><a href="#1-概要" class="headerlink" title="1. 概要"></a>1. 概要</h1><p><strong>单点登录（Single Sign On）</strong>，简称为 SSO，是目前比较流行的企业业务整合的解决方案之一。是一种统一认证和授权机制，指访问同一服务器不同应用中的受保护资源的同一用户，只需要登录一次，即通过一个应用中的安全验证后，再访问其他应用中的受保护资源时，不再需要重新登录验证。</p>
<p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Tools/1-2017-05-15-SSO.gif" alt="SSO1"></p>
<h1 id="2-实现原理"><a href="#2-实现原理" class="headerlink" title="2. 实现原理"></a>2. 实现原理</h1><p>当用户第一次访问应用系统1的时候，因为还没有登录，会被引导到认证系统中进行登录；根据用户提供的登录信息，认证系统进行身份效验，如果通过效验，应该返回给用户一个认证的凭据－－ticket；用户再访问别的应用的时候，就会将这个ticket带上，作为自己认证的凭据，应用系统接受到请求之后会把ticket送到认证系统进行效验，检查ticket的合法性（4,6）。如果通过效验，用户就可以在不用再次登录的情况下访问应用系统2和应用系统3了。</p>
<p>从上图可以看出sso的实现技术点：<br>1）所有应用系统共享一个身份认证系统。</p>
<p>　　　　统一的认证系统是SSO的前提之一。认证系统的主要功能是将用户的登录信息和用户信息库相比较，对用户进行登录认证；认证成功后，认证系统应该生成统一的认证标志（ticket），返还给用户。另外，认证系统还应该对ticket进行效验，判断其有效性。</p>
<p>2）所有应用系统能够识别和提取ticket信息</p>
<p>　　　　要实现SSO的功能，让用户只登录一次，就必须让应用系统能够识别已经登录过的用户。应用系统应该能对ticket进行识别和提取，通过与认证系统的通讯，能自动判断当前用户是否登录过，从而完成单点登录的功能。</p>
<h2 id="2-1-身份认证机制"><a href="#2-1-身份认证机制" class="headerlink" title="2.1 身份认证机制"></a>2.1 身份认证机制</h2><p>关于统一身份认证机制：如下图  </p>
<p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Tools/2-2017-05-15-SSO.jpg" alt="SSO2">  </p>
<p>①用户请求访问业务系统。</p>
<p>②业务系统在系统中查看是否有对应请求的有效令牌，若有，则读取对应的身份信息，允许其访问；若没有或令牌无效，则把用户重定向到统一身份认证平台，并携带业务系统地址，进入第③步。</p>
<p>③在统一身份认证平台提供的页面中，用户输入身份凭证信息，平台验证此身份凭证信息，若有效，则生成一个有效的令牌给用户，进入第④步；若无效，则继续进行认证，直到认证成功或退出为止。</p>
<p>④用户携带第③步获取的令牌，再次访问业务系统。</p>
<p>⑤业务系统获取用户携带的令牌，提交到认证平台进行有效性检查和身份信息获取。</p>
<p>⑥若令牌通过有效性检查，则认证平台会把令牌对应的用户身份信息返回给业务系统，业务系统把身份信息和有效令牌写入会话状态中，允许用户以此身份信息进行业务系统的各种操作；若令牌未通过有效性检查，则会再次重定向到认证平台，返回第③步。</p>
<p>通过统一身份认证平台获取的有效令牌，可以在各个业务系统之间实现应用漫游。</p>
<h1 id="3-单点登录的优点"><a href="#3-单点登录的优点" class="headerlink" title="3. 单点登录的优点"></a>3. 单点登录的优点</h1><h2 id="3-1-提高用户的效率。"><a href="#3-1-提高用户的效率。" class="headerlink" title="3.1 提高用户的效率。"></a>3.1 提高用户的效率。</h2><p>　　　　用户不再被多次登录困扰，也不需要记住多个 ID 和密码。另外，用户忘记密码并求助于支持人员的情况也会减少。 </p>
<h2 id="3-2-提高开发人员的效率。"><a href="#3-2-提高开发人员的效率。" class="headerlink" title="3.2 提高开发人员的效率。"></a>3.2 提高开发人员的效率。</h2><p>　　　　SSO 为开发人员提供了一个通用的身份验证框架。实际上，如果 SSO 机制是独立的，那么开发人员就完全不需要为身份验证操心。他们可以假设，只要对应用程序的请求附带一个用户名，身份验证就已经完成了。 </p>
<h2 id="3-3-简化管理。"><a href="#3-3-简化管理。" class="headerlink" title="3.3 简化管理。"></a>3.3 简化管理。</h2><p>　　　　如果应用程序加入了单点登录协议，管理用户帐号的负担就会减轻。简化的程度取决于应用程序，因为 SSO 只处理身份验证。所以，应用程序可能仍然需要设置用户的属性（比如访问特权）。</p>
<h1 id="4-单点登录的缺点"><a href="#4-单点登录的缺点" class="headerlink" title="4. 单点登录的缺点"></a>4. 单点登录的缺点</h1><h2 id="4-1-不利于重构"><a href="#4-1-不利于重构" class="headerlink" title="4.1 不利于重构"></a>4.1 不利于重构</h2><p>　　　　因为涉及到的系统很多，要重构必须要兼容所有的系统，可能很耗时</p>
<h2 id="4-2-无人看守桌面"><a href="#4-2-无人看守桌面" class="headerlink" title="4.2 无人看守桌面"></a>4.2 无人看守桌面</h2><p>　　　　因为只需要登录一次，所有的授权的应用系统都可以访问，可能导致一些很重要的信息泄露。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>SSO</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenFileDialog和SaveFileDialog使用</title>
    <url>/2017/05/17/2017-05-17-CSharp-OpenFileDialogAndSaveFileDialog/</url>
    <content><![CDATA[<h1 id="1-概要"><a href="#1-概要" class="headerlink" title="1. 概要"></a>1. 概要</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;写一个小工具实现文件的浏览，奈何很久没有碰过C#了，导致相关组件使用都忘掉了。今天借此机会补充起来，OpenFileDialog和SaveFileDialog的运用。</p>
<h1 id="2-OpenFileDialog"><a href="#2-OpenFileDialog" class="headerlink" title="2. OpenFileDialog"></a>2. OpenFileDialog</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;使用OpenFileDialog主要想实现如下图的功能.  </p>
<p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Programing/1-2017-05-17-CSharp-OpenFileDialogAndSaveFileDialog.gif" alt="OpenFileDialog">  </p>
<h2 id="2-1-添加控件"><a href="#2-1-添加控件" class="headerlink" title="2.1 添加控件"></a>2.1 添加控件</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;在设计页面直接添加对话框组件；然后设置其对应属性.  </p>
<p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Programing/2-2017-05-17-CSharp-OpenFileDialogAndSaveFileDialog.png" alt="control">  </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;按照设计需要进行相关属性设置.   </p>
<p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Programing/3-2017-05-17-CSharp-OpenFileDialogAndSaveFileDialog.png" alt="Setting"> </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;然后按照需求添加一个Button控件，并绑定该控件的Click事件，实现代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void getFilePathBtn_Click(object sender, EventArgs e)</span><br><span class="line">&#123;</span><br><span class="line">    if (openFileDialog.ShowDialog() &#x3D;&#x3D; DialogResult.OK)</span><br><span class="line">    &#123;</span><br><span class="line">        filePathTb.Text &#x3D; openFileDialog.FileName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-代码实现"><a href="#2-2-代码实现" class="headerlink" title="2.2 代码实现"></a>2.2 代码实现</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;代码实现只是将属性设置的模块进行代码设置而已。依旧需要添加Button控件，并绑定该控件Click事件，并在该事件内实现代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void getFilePathBtn_Click(object sender, EventArgs e)</span><br><span class="line">&#123;</span><br><span class="line">	OpenFileDialog openFileDialog &#x3D; new OpenFileDialog();</span><br><span class="line">    openFileDialog.InitialDirectory &#x3D; &quot;c:\\&quot;;&#x2F;&#x2F;注意这里写路径时要用c:\\而不是c:\</span><br><span class="line">    openFileDialog.Filter &#x3D; &quot;xml(*.xml)|*.xml|Excel 2003(*.xls)|*.xls|Excel 2007Plus(*.xlsx)|*.xlsx&quot;;</span><br><span class="line">    openFileDialog.RestoreDirectory &#x3D; true;</span><br><span class="line">    openFileDialog.FilterIndex &#x3D; 1;</span><br><span class="line">    if (openFileDialog.ShowDialog() &#x3D;&#x3D; DialogResult.OK)</span><br><span class="line">    &#123;</span><br><span class="line">        filePathTb.Text &#x3D; openFileDialog.FileName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>git使用细则</title>
    <url>/2017/05/17/2017-05-17-GIT/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>git</strong>使用细则。</p>
<h1 id="1-git环境配置"><a href="#1-git环境配置" class="headerlink" title="1. git环境配置"></a>1. git环境配置</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;一般在新的系统上，我们都需要先配置下自己的 Git 工作环境。配置工作只需一次，以后升级时还会沿用现在的配置。当然，如果需要，你随时可以用相同的命令修改已有的配置。  </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Git 提供了一个叫做 git config 的工具，专门用来配置或读取相应的工作环境变量。而正是由这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方：  </p>
<ul>
<li><p>/etc/gitconfig文件：系统中对所有用户都普遍适用的配置。若使用 git config 时用 –system 选项，读写的就是这个文件。 </p>
</li>
<li><p>~/.gitconfig文件：用户目录下的配置文件只适用于该用户。若使用 git config 时用 –global 选项，读写的就是这个文件。  </p>
</li>
<li><p>当前项目的 git 目录中的配置文件（也就是工作目录中的 .git/config 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 .git/config 里的配置会覆盖/etc/gitconfig 中的同名变量。  </p>
</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;第一个要配置的是你个人的用户名称和电子邮件地址。这两条配置很重要，每次 Git 提交时都会引用这两条信息，说明是谁提交了更新，所以会随更新内容一起被永久纳入历史记录：  </p>
<pre><code>$ git config --global user.name &quot;John Doe&quot; $ git config --global user.email johndoe@example.com  </code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;如果用了 –global 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 –global 选项重新配置即可，新的设定保存在当前项目的 .git/config 文件里。  </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;接下来要设置的是默认使用的文本编辑器。Git 需要你输入一些额外消息的时候，会自动调用一个外部文本编辑器给你用。默认会使用操作系统指定的默认编辑器，一般可能会是 Vi 或者 Vim。如果你有其他偏好，比如 Emacs 的话，可以重新设置：  </p>
<pre><code>$ git config --global core.editor emacs</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;还有一个比较常用的是，在解决合并冲突时使用哪种差异分析工具。比如要改用 vimdiff 的话： </p>
<pre><code>$ git config --global merge.tool vimdiff  </code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;Git可以理解 kdiff3，tkdiff，meld，xxdiff，emerge，vimdiff，gvimdiff，ecmerge，和 opendiff 等合并工具的输出信息。当然，你也可以指定使用自己开发的工具。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;查看配置信息,要检查已有的配置信息，可以使用 git config –list 命令：  </p>
<pre><code>$ git config --list user.name=Scott Chacon 
user.email=schacon@gmail.com  </code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;也可以直接查阅某个环境变量的设定，只要把特定的名字跟在后面即可，例如：  </p>
<pre><code>git config user.name 
Scott Chacon</code></pre><h1 id="2-git常用命令"><a href="#2-git常用命令" class="headerlink" title="2. git常用命令"></a>2. git常用命令</h1><table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>备注</strong></th>
</tr>
</thead>
<tbody><tr>
<td>git init</td>
<td>从当前目录初始化，要对现有的某个项目开始用 Git 管理，只需到此项目所在的目录，执行：git init；初始化后，在当前目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。</td>
</tr>
<tr>
<td>git clone <a href="mailto:git@github.com">git@github.com</a>:yaitza/python-guide.git</td>
<td>从现有仓库克隆。</td>
</tr>
<tr>
<td>git add [file]</td>
<td>跟踪新文件和暂存已修改文件。</td>
</tr>
<tr>
<td>git commit</td>
<td>提交更新，这种方式会启动文本编辑器以便输入本次提交的说明。</td>
</tr>
<tr>
<td>git commit -m “Initial commit of test repo”</td>
<td>使用 -m 参数后跟提交说明的方式，在一行命令中提交更新。</td>
</tr>
<tr>
<td>git diff</td>
<td>查看已暂存和未暂存的修改，git diff 此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容。</td>
</tr>
<tr>
<td>git diff –cached</td>
<td>看已经暂存起来的文件和上次提交时的快照之间的差异。</td>
</tr>
<tr>
<td>git rm [file]</td>
<td>移除文件,要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。</td>
</tr>
<tr>
<td>git rm –cached [file]</td>
<td>把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。 可以用–cached选项。</td>
</tr>
<tr>
<td>git mv [file] [newfile]</td>
<td>移动文件。</td>
</tr>
<tr>
<td>git status</td>
<td>检查当前文件状态。</td>
</tr>
<tr>
<td>git log</td>
<td>查看提交历史。</td>
</tr>
<tr>
<td>git commit –amend</td>
<td>修改最后一次提交，有时候我们提交完了才发现漏掉了几个文件没有加，或者提交信息写错了。想要撤消刚才的提交操作，可以使用 –amend 选项重新提交：git commit –amend如果刚才提交完没有作任何改动，直接运行此命令的话，相当于有机会重新编辑提交说明，而所提交的文件快照和之前的一样。如果刚才提交时忘了暂存某些修改，可以先补上暂存操作，然后再运行 –amend 提交。</td>
</tr>
<tr>
<td>git reset HEAD [file]</td>
<td>取消已经暂存的文件。</td>
</tr>
<tr>
<td>git checkout [file]</td>
<td>取消对文件的修改。</td>
</tr>
<tr>
<td>git checkout – [file]</td>
<td>一般与上面的命令效果相同，但如果有一个分支名与文件名相同，就不一样了；加–来消除歧义。</td>
</tr>
<tr>
<td>git stash</td>
<td>把所有没有提交的修改暂存到stash里面。可用git stash pop恢复。</td>
</tr>
<tr>
<td>git clean -df</td>
<td>返回到某个节点，-n 显示将要删除的文件和目录，-f 删除文件，-df 删除文件和目录。</td>
</tr>
<tr>
<td>git remote</td>
<td>查看当前的远程库。</td>
</tr>
<tr>
<td>git remote -v</td>
<td>也可以加上 -v 选项，显示对应的克隆地址。</td>
</tr>
<tr>
<td>git remote add [shortname] [url]</td>
<td>添加远程仓库。</td>
</tr>
<tr>
<td>git fetch [remotename]</td>
<td>从远程仓库抓取数据；此命令会到远程仓库中拉取所有你本地仓库中还没有的数据。运行完成后，你就可以在本地访问该远程仓库中的所有分支，将其中某个分支合并到本地，或者只是取出某个分支，一探究竟。</td>
</tr>
<tr>
<td>git push [remotename] [localbranch]:[remotebranch]</td>
<td>推送数据到远程仓库。</td>
</tr>
<tr>
<td>git remote show [remotename]</td>
<td>查看远程仓库信息。</td>
</tr>
<tr>
<td>git remote rename [remotename] [new-remotename]</td>
<td>远程仓库重命名</td>
</tr>
<tr>
<td>git remote rm [remotename]</td>
<td>远程仓库删除。</td>
</tr>
<tr>
<td>git tag</td>
<td>显示已有的标签。</td>
</tr>
<tr>
<td>git tag -a [tagname] –m [comments]</td>
<td>新建标签，如果想为以前的某次提交打标签，只要在打标签的时候跟上对应提交对象的校验和（或前几位字符）即可 。</td>
</tr>
<tr>
<td>git checkout –b [branchname] [tagname]</td>
<td>用某个标签新建分支。</td>
</tr>
<tr>
<td>git push [remotename] [tagname]</td>
<td>分享标签；默认情况下，git push 并不会把标签传送到远端服务器上，只有通过显式命令才能分享标签到远端仓库。</td>
</tr>
<tr>
<td>git push [remotename] –tags</td>
<td>如果要一次推送所有（本地新增的）标签上去，可以使用 –tags 选项。</td>
</tr>
<tr>
<td>git branch [branchname]</td>
<td>创建分支。</td>
</tr>
<tr>
<td>git checkout [branchname]</td>
<td>切换分支。</td>
</tr>
<tr>
<td>git checkout -b [branchname]</td>
<td>新建并切换到该分支。</td>
</tr>
<tr>
<td>git branch -d [branchname]</td>
<td>删除分支。</td>
</tr>
<tr>
<td>git merge [branchname]</td>
<td>合并分支，以上命令将[branchname]分支合并到当前分支。</td>
</tr>
<tr>
<td>git branch</td>
<td>查看分支。</td>
</tr>
<tr>
<td>git checkout -b [branchname] [remotename]/[branchname]</td>
<td>远程分支和创建跟踪分支；远程分支（remote branch）是对远程仓库状态的索引。它们是一些无法移动的本地分支；只有在进行 Git 的网络活动时才会更新。远程分支就像是书签，提醒着你上次连接远程仓库时上面各分支的位置。我们用 (远程仓库名)/(分支名) 这样的形式表示远程分支。从远程分支检出的本地分支成为跟踪分支。</td>
</tr>
<tr>
<td>git checkout –track [remotename]/[branchname]</td>
<td>同上。</td>
</tr>
<tr>
<td>git branch -r -d origin/[branchname]</td>
<td>删除远程分支。</td>
</tr>
<tr>
<td>git rebase [branchname]</td>
<td>衍合。</td>
</tr>
<tr>
<td>git pull</td>
<td>从远程仓库抓取数据并merge。</td>
</tr>
<tr>
<td>git clean -f</td>
<td>删除untracked files。</td>
</tr>
<tr>
<td>git clean -fd</td>
<td>连untracked的目录一起删除。</td>
</tr>
<tr>
<td>git clean -xfd</td>
<td>连gitignore的untracked文件，目录一起删除(慎用，一般用这个是来删掉编译出来的.o之类的文件)。</td>
</tr>
<tr>
<td>git clean -nxfd、-nf、-nfd</td>
<td>在git clean前，加上-n参数会先显示删除哪些文件，防止重要文件被删除。</td>
</tr>
<tr>
<td>git blame [file]</td>
<td>显示文件的每一行是在哪个版本修改的。</td>
</tr>
<tr>
<td>git whatchanged [file]</td>
<td>显示某个文件的每个版本提交信息：提交日期，提交人员，版本号，提交备注。</td>
</tr>
<tr>
<td>git log –pretty=oneline [file]</td>
<td>显示某个文件的每个版本提交信息：版本号，提交备注。</td>
</tr>
<tr>
<td>git show [commit_no]</td>
<td>显示某个版本的修改详情。</td>
</tr>
<tr>
<td>git log -p [commit_no]</td>
<td>显示某个版本的修改详情。</td>
</tr>
<tr>
<td>git cherry-pick [commit_no]</td>
<td>从一个分支合并特定的commits到当前所在分支。</td>
</tr>
<tr>
<td>git checkout -b newbranch [commit_no2]</td>
<td>新建分支拉取到当前分支commit_no2节点。</td>
</tr>
<tr>
<td>git rebase –ontomaster [commit_no1]^</td>
<td>rebase这个新分支的commit到master（–ontomaster）。[commit_no1]^ 指明你想从哪个特定的commit开始。得到的结果就是feature分支的commit [commit_no1] ~[commit_no2] 都被合并到了master分支。</td>
</tr>
<tr>
<td>git log branchA ^branchB</td>
<td>查看branchA有,而branchB中没有的提交记录；分支也可替换为tag。</td>
</tr>
<tr>
<td>git log branchA..branchB</td>
<td>查看branchA与branchB之间提交的差异；分支也可替换为tag。</td>
</tr>
<tr>
<td>git diff –stat tagA tagB</td>
<td>查看tagA与tagB之间的文件差异。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>TestLinkConverter编程纪要</title>
    <url>/2017/05/21/2017-05-21-CSharp-TestLink/</url>
    <content><![CDATA[<p>TestLinkConverter小工具主要是为了解决XML以及Excel之间相互转换的问题。测试管理工具导出用例文件格式为XML，而一般测试人员习惯用Excel设计测试用例，导致设计的测试用例无法导入到TestLink以及TestLink导出的测试用例无法提供Excel视图;支持XML转换为Excel后，对应Excel转换为XML；XML和Excel相互转换。<br><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Programing/1-2019-09-18-CSharp-TestLink.png" alt="1-2017-05-21-CSharp-TestLink"><br><strong><a href="https://github.com/yaitza/TestLinkConverter/releases" target="_blank" rel="noopener">点击下载</a></strong></p>
<h1 id="1-概要"><a href="#1-概要" class="headerlink" title="1. 概要"></a>1. 概要</h1><p>支持解析的XML为TestLink默认导出的XML结构；经过工具生成后对应Excel展示用例如下图：<br><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Programing/2-2019-09-18-CSharp-TestLink.png" alt="2-2017-05-21-CSharp-TestLink"><br>支持解析的Excel格式默认为导出的Excel格式，见上图。<br><strong>注：</strong> 支持导出文件的相互转换，即导出XML再转为Excel或者导出Excel再次转为XML。</p>
<h1 id="2-XML-gt-Excel"><a href="#2-XML-gt-Excel" class="headerlink" title="2. XML -&gt; Excel"></a>2. XML -&gt; Excel</h1><p>首先解决的问题是如何将TestLink导出的XML文件进行转换提供给测试人员习惯使用的Excel视图。一般的XML格式TestLink一般导出后结构如下，对应XML各个字段定义参考<a href="http://wangsx.cn/?p=648" target="_blank" rel="noopener">TestLink字段解析</a>：<br><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Programing/4-2019-09-18-CSharp-TestLink.png" alt="4-2017-05-21-CSharp-TestLink"><br>TestLinkConverter采用C#自带的XmlDocument对xml文件进行解析，但是有的xml可能存在多个testsuite嵌套的情况，就需要获取所有嵌套下的TestCase，这里采用递归的方法获取所有testcase。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 递归获取测试套下所有测试用例</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;xmlNodes&quot;&gt;根节点下子节点集合&lt;&#x2F;param&gt;</span><br><span class="line">private void RecursionGetNodes(List&lt;XmlNode&gt; xmlNodes)</span><br><span class="line">&#123;</span><br><span class="line">    foreach (XmlNode node in xmlNodes)</span><br><span class="line">    &#123;</span><br><span class="line">        if (node.Name.Equals(&quot;testsuite&quot;))</span><br><span class="line">        &#123;</span><br><span class="line">            List&lt;XmlNode&gt; childNodes &#x3D; node.ChildNodes.Cast&lt;XmlNode&gt;().ToList();</span><br><span class="line">            RecursionGetNodes(childNodes);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">           if (node.Name.Equals(&quot;testcase&quot;))</span><br><span class="line">           &#123;</span><br><span class="line">              this._nodesList.Add(node);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-Excel-gt-XML"><a href="#3-Excel-gt-XML" class="headerlink" title="3. Excel -&gt; XML"></a>3. Excel -&gt; XML</h1><p>同理Excel转换为XML，对应Excel的格式必须与提供的模板格式保持一致，方能将相应的Excel中的测试用例转化为对应的XML。<br>此处Excel对应的测试用例为List结构，转为XML对应的结构要转化为树形结构。根据Excel中对应测试用例的层级机构，从最低的层级(即测试套最多的测试用例)依次网上迭代，构造对应的树形结构。</p>
<h1 id="4-功能实现"><a href="#4-功能实现" class="headerlink" title="4. 功能实现"></a>4. 功能实现</h1><h2 id="4-1-进度条功能"><a href="#4-1-进度条功能" class="headerlink" title="4.1 进度条功能"></a>4.1 进度条功能</h2><p>对应进度条的功能，首先不确定解析文件以及生成文件具体耗时，进度条而且需要与之同步；进度条采用系统自带的ProgressBar控件。  </p>
<p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Programing/7-2017-05-21-CSharp-TestLink.gif" alt="7-2017-05-21-CSharp-TestLink">   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private delegate void SetPos(int ipos);</span><br><span class="line"></span><br><span class="line">public Form()</span><br><span class="line">&#123;</span><br><span class="line">    InitializeComponent();    </span><br><span class="line">    ProgressBarShow.SetProgressValue +&#x3D; this.SetProgressValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void SetProgressValue(int ipos)</span><br><span class="line">&#123;</span><br><span class="line">    if (this.InvokeRequired)</span><br><span class="line">    &#123;</span><br><span class="line">        SetPos setPos &#x3D; new SetPos(SetProgressValue);</span><br><span class="line">        this.Invoke(setPos, new object[] &#123;ipos&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        this.progressBar.Value &#x3D; Convert.ToInt32(ipos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新增类用于绑定进度条实时更新。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static class ProgressBarShow</span><br><span class="line">&#123;</span><br><span class="line">    public delegate void SetProgressHandler(int ipos);</span><br><span class="line"></span><br><span class="line">    public static SetProgressHandler SetProgressValue &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">    public static void ShowProgressValue(int ipos)</span><br><span class="line">    &#123;</span><br><span class="line">        if (SetProgressValue !&#x3D; null)</span><br><span class="line">        &#123;</span><br><span class="line">            SetProgressValue.Invoke(ipos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-参考引用"><a href="#5-参考引用" class="headerlink" title="5. 参考引用"></a>5. 参考引用</h1><h2 id="5-1-log4net"><a href="#5-1-log4net" class="headerlink" title="5.1 log4net"></a>5.1 log4net</h2><p><strong>下载地址：</strong>  <a href="https://logging.apache.org/log4net/download_log4net.cgi" target="_blank" rel="noopener">https://logging.apache.org/log4net/download_log4net.cgi</a><br><strong>参考博客：</strong>  <a href="http://www.cnblogs.com/kissazi2/p/3389551.html" target="_blank" rel="noopener">http://www.cnblogs.com/kissazi2/p/3389551.html</a>  </p>
<h2 id="5-2-EPPlus"><a href="#5-2-EPPlus" class="headerlink" title="5.2 EPPlus"></a>5.2 EPPlus</h2><p><strong>下载地址：</strong>  <a href="https://github.com/JanKallman/EPPlus" target="_blank" rel="noopener">https://github.com/JanKallman/EPPlus</a><br><strong>参考博客：</strong>  <a href="http://blog.csdn.net/ejinxian/article/details/52315950" target="_blank" rel="noopener">http://blog.csdn.net/ejinxian/article/details/52315950</a><br><strong>资源地址：</strong>  <a href="https://archive.codeplex.com/?p=epplus" target="_blank" rel="noopener">https://archive.codeplex.com/?p=epplus</a></p>
<h2 id="5-3-TestLink字段解析"><a href="#5-3-TestLink字段解析" class="headerlink" title="5.3 TestLink字段解析"></a>5.3 TestLink字段解析</h2><p><strong>参见博客：</strong>  <a href="http://wangsx.cn/?p=648" target="_blank" rel="noopener">http://wangsx.cn/?p=648</a></p>
<h2 id="5-4-EXE打包教程"><a href="#5-4-EXE打包教程" class="headerlink" title="5.4 EXE打包教程"></a>5.4 EXE打包教程</h2><p><strong>参见博客：</strong>  <a href="http://www.cnblogs.com/yinsq/p/5254893.html" target="_blank" rel="noopener">http://www.cnblogs.com/yinsq/p/5254893.html</a><br><strong>参见博客：</strong>  <a href="https://blog.csdn.net/L120305q/article/details/98210048" target="_blank" rel="noopener">https://blog.csdn.net/L120305q/article/details/98210048</a><br><strong>参见博客：</strong>  <a href="https://blog.csdn.net/DonetRen/article/details/88766135" target="_blank" rel="noopener">https://blog.csdn.net/DonetRen/article/details/88766135</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>UML活动图</title>
    <url>/2017/07/03/2017-07-03-UML-Activity/</url>
    <content><![CDATA[<h1 id="1-活动图"><a href="#1-活动图" class="headerlink" title="1. 活动图"></a>1. 活动图</h1><p><strong>活动图</strong>类似于传统意义上的流程图，它是用来描述一个过程或者操作的工作步骤，类似于Flow Diagram。活动图主要用于两个场景：<br>    1）业务建模时，用于详述业务用例，描述一项业务的执行过程；<br>    2）设计时，描述操作的流程。<br><strong>活动图</strong>用来描述系统的动态行为。包含活动状态(ActionState)，活动状态是指业务用例的一个执行步骤或一个操作，不是普通对象的状态。活动图适合描述在没有外部事件触发的情况下的系统内部的逻辑执行过程；否则，状态图更容易描述。</p>
<h1 id="2-事务"><a href="#2-事务" class="headerlink" title="2. 事务"></a>2. 事务</h1><p>活动图中的事物，包括活动，起点，终点，对象流，发送信号和接收信号，以及泳道等，如下所示：<br><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Tools/1-2017-05-13-UML-Activity.png" alt="pic1"><br>在泳道中又细分为水平泳道和垂直泳道，这里不再展开做描述。</p>
<h1 id="3-关系"><a href="#3-关系" class="headerlink" title="3. 关系"></a>3. 关系</h1><p>活动图中的关系，相对于事物来说比较简单，如下：<br><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Tools/2-2017-05-13-UML-Activity.png" alt="pic2">  </p>
<h1 id="4-普通示例"><a href="#4-普通示例" class="headerlink" title="4. 普通示例"></a>4. 普通示例</h1><p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Tools/3-2017-05-13-UML-Activity.png" alt="pic3">  </p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title>用例设计之判定表</title>
    <url>/2017/07/14/2017-07-14-TestCase-DecisionTable/</url>
    <content><![CDATA[<h1 id="1-判定表的介绍"><a href="#1-判定表的介绍" class="headerlink" title="1. 判定表的介绍"></a>1. 判定表的介绍</h1><p>在对软件进行需求分析时, 市场部人员需要跟用户进行不断的沟通, 这时可能会根据软件功能的期望让用户填一些调查表格, 用户会根据条件选择自己期望达到的效果。如果将条件称为输入, 将期望效果称为输出, 这就非常接近于软件测试中的测试用例。如果由于条件的不同组合会得到不同的一些输出, 那么这样的问题就适合使用<strong>判定表</strong>来进行测试用例的设计。  </p>
<h2 id="1-1-判定表通常由四个部分组成"><a href="#1-1-判定表通常由四个部分组成" class="headerlink" title="1.1 判定表通常由四个部分组成"></a>1.1 判定表通常由四个部分组成</h2><pre><code>(1)、条件桩(Condition Stub): 列出了问题的所有条件。除特别说明, 认为列出的条件的次序无关紧要。  
(2)、动作桩(Action Stub) : 根据条件的组合可能导致的动作。一般排列顺序没有约束。  
(3)、条件项(Condition Entry) : 由条件桩列出条件的可能取值, 即条件的真和假。  
(4)、动作项(Action Entry) : 列出在不同条件排列组合下可能采取的操作。   </code></pre><h2 id="1-2-规则及规则合并"><a href="#1-2-规则及规则合并" class="headerlink" title="1.2 规则及规则合并"></a>1.2 规则及规则合并</h2><pre><code>(1)、规则: 由不同的条件导致不同的动作就称为规则, 一般体现在判定表中就是不同的输入得到不同的输出。在判定表中贯穿条件项和动作项的一列就是一条规则。
(2)、化简: 因为初始化判定表包括条件的所有组合, 这时有些组合可能是不能实现的, 有些动作可能是由一些相似的条件组成的, 这时就需要按照等价类划分的原则进行化简。</code></pre><h1 id="2-普通示例"><a href="#2-普通示例" class="headerlink" title="2. 普通示例"></a>2. 普通示例</h1><h2 id="2-1-判定表建立步骤"><a href="#2-1-判定表建立步骤" class="headerlink" title="2.1 判定表建立步骤"></a>2.1 判定表建立步骤</h2><pre><code>1、分析功能说明书, 确定条件、规则的个数。
2、根据分析, 列出所有的条件桩和动作桩。
3、根据分析输入填入条件项。  
4、根据输出填入动作项, 根据排列组合得到初始决策表。
5、简化,合并相似规则(相同动作)。</code></pre><h2 id="2-2-判定表举例"><a href="#2-2-判定表举例" class="headerlink" title="2.2 判定表举例"></a>2.2 判定表举例</h2><p>“对功率大于50马力的机器、维修记录不全或已运行10年以上的机器，应给予优先的维修处理……” 。这里假定，“维修记录不全”和“优先维修处理”均已在别处有更严格的定义；请建立判定表。   </p>
<p><strong>步骤：</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;1.确定规则的个数：这里有3个条件，每个条件有两个取值，故应有2<em>2</em>2=8种规则。   </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;2.列出所有的条件桩和动作桩：  </p>
<p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Test/1-2017-07-14-TestCase-DecisionTable.png" alt="pic1">   </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;3.填入条件项。  </p>
<p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Test/2-2017-07-14-TestCase-DecisionTable.png" alt="pic2">  </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;4.填入动作桩和动作顶。这样便得到形如图的初始判定表。  </p>
<p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Test/3-2017-07-14-TestCase-DecisionTable.png" alt="pic3">  </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;5.化简。合并相似规则后得到图。  </p>
<p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Test/4-2017-07-14-TestCase-DecisionTable.png" alt="pic4">  </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;6.然后根据最后化简的结果，生成相应的测试用例。  </p>
<h1 id="3-判定表的优缺点"><a href="#3-判定表的优缺点" class="headerlink" title="3.判定表的优缺点"></a>3.判定表的优缺点</h1><p><strong>优点：</strong>把复杂的问题按各种可能的情况一一列举，简明而易于理解，也避免遗漏。  </p>
<p><strong>缺点：</strong>    </p>
<ul>
<li><p>不能表达重复执行的动作，如循环结构。  </p>
</li>
<li><p>判定表不能很好的伸缩。如有n个条件的判定表有2n个规则。  </p>
</li>
</ul>
<h1 id="4-适合使用判定表设计测试用例的条件："><a href="#4-适合使用判定表设计测试用例的条件：" class="headerlink" title="4.适合使用判定表设计测试用例的条件："></a>4.适合使用判定表设计测试用例的条件：</h1><ol>
<li>规格说明以判定表形式给出，或很容易转换成判定表的。</li>
<li>条件的排列顺序不会也不影响执行哪些操作。</li>
<li>规则的排列顺序不会也不影响执行哪些操作。</li>
<li>每当某一规则的条件已近满足，并确定要执行的操作后，不必检验别的规则。</li>
<li>如果某一规则得到满足要执行多个操作，这些操作的执行顺序无关紧要。</li>
</ol>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>用例设计</tag>
      </tags>
  </entry>
  <entry>
    <title>测试分析</title>
    <url>/2017/07/18/2017-07-18-TestAnalysis-Model/</url>
    <content><![CDATA[<h1 id="1-需求分析概念"><a href="#1-需求分析概念" class="headerlink" title="1.需求分析概念"></a>1.需求分析概念</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;在系统工程及软件工程中，需求分析指的是在创建一个新的或改变一个现存的系统或产品时，确定新系统的目的、范围、定义和功能时所要做的所有工作。需求分析是软件工程中的一个关键过程。在这个过程中，系统分析员和软件工程师确定顾客的需要。只有在确定了这些需要后他们才能够分析和寻求新系统的解决方法。<br>&nbsp;&nbsp;&nbsp;&nbsp;需求分析的质量，考虑是否周全将直接关系到后续工作的开展。</p>
<h1 id="2-需求分析视角"><a href="#2-需求分析视角" class="headerlink" title="2. 需求分析视角"></a>2. 需求分析视角</h1><h2 id="2-1-视角的分类"><a href="#2-1-视角的分类" class="headerlink" title="2.1 视角的分类"></a>2.1 视角的分类</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;作为一名测试人员，我们接触到更多的是产品经理的需求文档，每当我们从产品经理手中接过需求文档时，往往心中的第一个疑问就是怎么“看”，在解答这个问题之前，我们先来了解下关于“需求三个视角”的描述：</p>
<p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Test/1-2017-07-18-TestAnalysis-Model.png" alt="pic1"> </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;将需求分为三个视角解读：数据视角、功能视角和行为视角，并分别列举了类图，活动图和状态图，同时还特别强调了三种视角并非独立存在而是具有一定融合、交叉的关系。</p>
<pre><code>数据视图：描述输入输出数据结构、静态结构及依赖关系(也称为结构视图)。  
功能视图：描述系统实现的功能，输入输出数据的处理。  
行为视图：描述系统如何运行和具体功能实现。  </code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;因此，当接到一个业务需求、产品特性或是整个系统时，我们可以通过这三个视角来解读被测系统。那么，每一种视角究竟有哪些工具可以让我们进行选择使用呢？</p>
<pre><code>从结构上来说，有类图[1]，E-R图[2]，组件图[3]；  
从功能上来说，有用例图[4]，因果图[5]，决策表[6]；  
从行为上来说，有活动图[7]，状态图[8]，序列图[9]。  </code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;特定的视角惯以常用的分析图，为了达到更加便捷，清晰地阐明需求，使得需求覆盖更加完全。</p>
<h2 id="2-2-视角的选择"><a href="#2-2-视角的选择" class="headerlink" title="2.2 视角的选择"></a>2.2 视角的选择</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;选择合适的切入口对产品需求进行快速有效地分析。</p>
<h3 id="2-2-1-根据需求特点选择"><a href="#2-2-1-根据需求特点选择" class="headerlink" title="2.2.1 根据需求特点选择"></a>2.2.1 根据需求特点选择</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;“名词”较多的优先选择结构视图。<br>&nbsp;&nbsp;&nbsp;&nbsp;“功能、逻辑、算法”较多的优先选择功能视图。</p>
<h3 id="2-2-2-根据项目阶段来判断"><a href="#2-2-2-根据项目阶段来判断" class="headerlink" title="2.2.2 根据项目阶段来判断"></a>2.2.2 根据项目阶段来判断</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;需求评审阶段：这个阶段的目标是消除歧义、达成一致，测试建模的主要功能也是促进理解和交流，因此，这个阶段我们使用各类视图建模时不易过度关注细节，大体描述主要流程即可，我们可以随着项目的开展对模型进行迭代更新。<br>&nbsp;&nbsp;&nbsp;&nbsp;产品实现阶段：产品实现过程中，同时关注各种视图中的细节更有利于理解和评审真实实现逻辑，修正测试模型，生成高质量测试方案。根据产品设计构建的模型还可以用来检验设计的正确性合理性。但是要注意避免通过代码实现来推到测试模型。<br>&nbsp;&nbsp;&nbsp;&nbsp;产品提测阶段：提测时主要是对照已有模型（如果前期有建模准备）进行更新补充；或者直接应用探索式测试相关的启发式边建模边测试边反馈修正。</p>
<h3 id="2-2-3-根据个人喜好"><a href="#2-2-3-根据个人喜好" class="headerlink" title="2.2.3 根据个人喜好"></a>2.2.3 根据个人喜好</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;“当你无从下手的时候，就从活动图开始”。其实道理很简单，活动图（流程图）似乎与生俱来一直都很熟悉。熟悉的视角肯定能让我们更快的入手，但更重要的一点是一定不能忽视从其他的视角去做一些补充。<br>&nbsp;&nbsp;&nbsp;&nbsp;通过以上视角对需求的理解与分析，将测试思路与内容转化为条理清晰，覆盖全面的测试用例是我们的诉求。</p>
<h2 id="2-3-测试模型"><a href="#2-3-测试模型" class="headerlink" title="2.3 测试模型"></a>2.3 测试模型</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;对于上文提到不同视角对需求进行分析提炼，最终生成对于我们有用的测试用例；将这个过程方法论就是我们的测试模型。</p>
<h3 id="2-3-1-测试模型的概念"><a href="#2-3-1-测试模型的概念" class="headerlink" title="2.3.1 测试模型的概念"></a>2.3.1 测试模型的概念</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;测试建模，将测试思路或内容形成条理清晰、系统全面的模型而展开的测试（MBT）。</p>
<pre><code>SUT：System Under Test，被测系统模型，也称类比模型。
TRM：Test Ready Model，测试准备模型，也称分析模型。</code></pre><h4 id="2-3-1-1-SUT模型"><a href="#2-3-1-1-SUT模型" class="headerlink" title="2.3.1.1 SUT模型"></a>2.3.1.1 SUT模型</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;SUT模型是心智模型（对产品的理解、设想和体验）的外化（以及与现有模型的整合），是一种图形化或形式化的类比模型。它涉及到不同的层次（如系统、组件和工作环境）、不同视角（如语境/上下文、组件与结构、功能、行为和用户体验）和不同关注点（如数据类型、因果关联、程序结构、任务控制、动作、事件和接口）等。</p>
<p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Test/2-2017-07-18-TestAnalysis-Model.png" alt="pic2"> </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;经过抽象、泛化和删减后，SUT模型只保留有助于实现特定测试目的的特征。在生成可执行测试用例前，SUT模型的实例化可能用到的技术（如Figure 2）包括Finite State Machine (FSM)，Message Sequence Chart (MSC)， Control Flow Graph (CFG)，Event Flow Diagram，MarkovChains和UML Testing Profile 等。</p>
<h4 id="2-3-1-2-TRM模型"><a href="#2-3-1-2-TRM模型" class="headerlink" title="2.3.1.2 TRM模型"></a>2.3.1.2 TRM模型</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;TRM模型是对SUT模型的扩展和转化，以使模型达到可测试的标准；该模型也可独立使用，即给出相关信息，我们就可以设计或使用一套测试设计算法，用来产生可以运行的测试用例。它根据SUT模型特征和项目实际情况增加或凸显质量风险信息。必要时TRM需要创建新的模型，这是测试建模的主要难点之一，但也体现了我们价值所在。另外，它转化SUT模型以达到可测试标准，并增加“怎么测”的信息，同时为SUT模型修改重构提供反馈。</p>
<h4 id="2-3-1-3-SUT与TRM区别"><a href="#2-3-1-3-SUT与TRM区别" class="headerlink" title="2.3.1.3 SUT与TRM区别"></a>2.3.1.3 SUT与TRM区别</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;SUT和TRM模型有密切的关系，那么它们的侧重点有哪些区别呢？相对来说，SUT层次更高，更温和，以描述被测对象为己任（更抽象）；而TRM更接地气，更直接，以揭露风险为使命（更具体）。实践中，TRM模型一般以发现SUT的潜在风险为导向。与SUT建模相比，TRM缺少现成的系统的方法论指导，缺少可参考借鉴的方法，更倚重经验，却缺少经验积累。</p>
<table>
<thead>
<tr>
<th>SUT</th>
<th>TRM</th>
</tr>
</thead>
<tbody><tr>
<td>描绘了测试对象</td>
<td>体现测试策略，如测什么，测多少及怎么测</td>
</tr>
<tr>
<td>系统思维</td>
<td>创造性思维</td>
</tr>
<tr>
<td>“面”(等价类，平均值)</td>
<td>“点”(边界值)</td>
</tr>
<tr>
<td>构建为目的，重点关注可能产生质量风险的地方</td>
<td>直接为“破坏”，“攻击”服务，关注如何揭露质量问题</td>
</tr>
</tbody></table>
<h3 id="2-3-2-测试建模的方法"><a href="#2-3-2-测试建模的方法" class="headerlink" title="2.3.2 测试建模的方法"></a>2.3.2 测试建模的方法</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;测试建模的方法从宏观上来看，主要分为SUT建模和TRM建模。从微观上来看又派生了很多的模型。在实际工作中，我们拿到被测系统后，会在脑海里进行瞬时画像建模，也就是构建了心智模型。而从心智模型过渡到测试用例，中间过程的不同决定了不同的测试设计，如下图所示。</p>
<p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Test/3-2017-07-18-TestAnalysis-Model.png" alt="pic3"> </p>
<pre><code>路径一[红色箭头]：从心智模型（Mental Model）直接得到测试用例（Ad-hoc Test Design，基于临时需求）；
路径二[黄色箭头]：从心智模型得到TRM模型，再由TRM模型生成测试用例（TraditionalExploratory传统测试设计）；
路径三[蓝色箭头&amp;紫色箭头]：从心智模型到SUT模型，再由SUT模型生成测试用例（教科书式）；
路径四[蓝色箭头]：从心智模型到SUT模型，再由SUT模型到TRM模型，最终由TRM模型生成测试用例（MBT）。</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;由上图所示，MBT强调中间过程。特别说明的是，MBT是一个循序渐进、逐步完善的过程，需要将被测系统的各个方面进行考虑，在发布周期之前形成完善的模型有利于整个产品的开发、测试和发布等工作，如下图所示。</p>
<p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Test/4-2017-07-18-TestAnalysis-Model.png" alt="pic4"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;我们拿到被测需求后，首先会进行SUT抽象建模；分析需求进行TRM建模；初步模型验证；基于模型可控地生成测试用例；优化并生成可执行测试用例。根据用户关注重点的差异，第一步可以对被测系统进行功能建模，也可以进行用户使用环境建模；第四步可以针对一些模式（Patterns）或测试特异性（Test specifications）来生成用例，也可以根据测试覆盖率等软件测试度量规则（Criteria）来生成测试用例。</p>
<h3 id="2-3-3-怎样展开测试建模"><a href="#2-3-3-怎样展开测试建模" class="headerlink" title="2.3.3 怎样展开测试建模"></a>2.3.3 怎样展开测试建模</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;在实际测试过程中，我们拿到的输入通常是需求说明书或是开发的实现代码等，经过测试人员的建模加工后，最终生成测试用例。针对需求分析从整体角度，我们往往会使用相关模型分析深入理解被测需求（包括识别关键变量），基于分析结果再进行具体的模型构建，如业务流程图、决策树等等；接着，结合关键变量进行风险分析，完善模型；最终将模型通过自动化或手工方式转换成用例。</p>
<p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Test/5-2017-07-18-TestAnalysis-Model.png" alt="pic5"></p>
<h3 id="2-3-4-实例解析"><a href="#2-3-4-实例解析" class="headerlink" title="2.3.4 实例解析"></a>2.3.4 实例解析</h3><p><strong>需求描述</strong></p>
<p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Test/6-2017-07-18-TestAnalysis-Model.png" alt="pic6"> </p>
<p><strong>需求理解</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;SUT建模</p>
<p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Test/7-2017-07-18-TestAnalysis-Model.png" alt="pic7"> </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;SUT转化为TRM模型</p>
<p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Test/8-2017-07-18-TestAnalysis-Model.png" alt="pic8"> </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;根据TRM各个节点测判断依据生成对应的测试用例。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><pre><code>[1]类图：http://www.uml.org.cn/oobject/201211231.asp
[2]E-R图：https://zh.wikipedia.org/wiki/ER%E6%A8%A1%E5%9E%8B
[3]组件图：http://blog.csdn.net/fanxiaobin577328725/article/details/51647248
[4]因果图：http://blog.csdn.net/vincetest/article/details/1475414
[5]活动图：http://www.cnblogs.com/ywqu/archive/2009/12/14/1624082.html
[6]决策表：http://www.51testing.com/html/70/n-3578470.html
[7]状态图：http://www.cnblogs.com/ywqu/archive/2009/12/17/1626043.html
[8]用例图：https://yaitza.github.io/2017-05-13-UML-Case
[9]序列图：http://blog.csdn.net/tianhai110/article/details/6361338</code></pre>]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>Test</tag>
      </tags>
  </entry>
  <entry>
    <title>The NLP Meta Model</title>
    <url>/2017/07/20/2017-07-20-TestAnalysis-NLP/</url>
    <content><![CDATA[<p><strong>What can the NLP Meta Model do for testers?</strong> </p>
<pre><code>“…the goal of the Meta Model is not to find the ‘right’ answers, but rather to
ask better questions – to widen our map of the world rather than to find the
‘right map of the world’. The purpose of the Meta Model inquiry system is to
help identify missing links, unconscious assumptions and reference experiences
that make up the ‘deeper structure’ of our conscious models of the world.”
                                           NLP Encyclopaedia,Robert Dilts </code></pre><p>The process of software development is a process of human communication. Beliefs about software are communicated as requirements. Software specifications are based on the requirements and are in turncommuni cated to programmers. Programmers communicate their beliefs about the software specifications to the computer in the form of program code. </p>
<p>Each of these communication steps may involve several different people and different communication media, both written and verbal. Each communication step is subject to ambiguity, and ambiguity can result in software defects. </p>
<p>The Meta Model provides testers with a simple model of:</p>
<ul>
<li><p>3 ambiguity generating transformations – deletion, distortion and generalization</p>
</li>
<li><p>12 easily identifiable communication violations resulting from the transformations </p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Test/1-2017-07-20-TestAnalysis-NLP.png" alt="pic1"> </p>
<p>The paper will provide an overview of the NLP Meta Model and explore ways in which knowledge of the Meta Model can be useful to testers: </p>
<ul>
<li><p>Apply the Meta Model to the communication we receive, identify ambiguity and possible mistakes early, before being encoded in the system</p>
</li>
<li><p>Apply the Meta Model to the communication we give to,</p>
</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;o Improve defect reporting</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;o Help people understand what we aim to do</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;o Improve development team/test team relationships</p>
<ul>
<li>Apply the Meta Model to the system to identify areas of test and as a test derivation aid</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;o “The docs say the system will always do this, if I can find a situation under which it doesn’t then…”</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;o What is presupposed by this dialog? How can I invalidate that presupposition?</p>
<ul>
<li><p>Teach testers an easy, effective and repeatable approach to documentation analysis</p>
</li>
<li><p>Apply the Meta Model to our beliefs about our environment and provide a framework for thinking about our context of testing</p>
</li>
</ul>
<p><strong>What is the NLP Meta Model?</strong></p>
<p>The NLP Meta Model is a system of inquiry to explore areas of communication that are susceptible to ambiguity. </p>
<p><strong>An introduction</strong>  </p>
<p>“The Structure of Magic” [SoM1], by Richard Bandler and John Grinder, is a study of the language and the application of language in therapy of the 1970s. [SoM1] provides a formal model of the language used, enabling it to be easily understood, taught and used by therapist and non-therapists alike.<br>The formal model produced, called the Meta Model, was constructed using the theories of transformational grammar. Under transformational grammar, our communication, what we say and write, are surface structure representations of a richer model of the world (deep structure). And we map<br>our deep structure onto the surface structure by a process of transformation. </p>
<p>The formal model produced, called the Meta Model, was constructed using the theories of transformational grammar. Under transformational grammar, our communication, what we say and write, are surface structure representations of a richer model of the world (deep structure). And we map our deep structure onto the surface structure by a process of transformation. </p>
<p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Test/2-2017-07-20-TestAnalysis-NLP.png" alt="pic2"> </p>
<p>For example, if I tell you that “I bought a computer”. Then the statement “I bought a Computer” is a surface structure representation of a richer deep structure. The deep structure contains all my memories of buying a computer, including:</p>
<ul>
<li><p>The strategies I used to decide which computer to buy,</p>
</li>
<li><p>Memories of all the computers I discarded before choosing the one that I chose,</p>
</li>
<li><p>How I felt buying the computer,</p>
</li>
<li><p>How much it cost,</p>
</li>
<li><p>If I thought it value for money,</p>
</li>
<li><p>What the shop/salesman was like,</p>
</li>
<li><p>Where I bought it from,</p>
</li>
<li><p>What the shop smelt like,</p>
</li>
<li><p>How I felt carrying the computer home. </p>
</li>
</ul>
<p>All of this information has been deleted in my transformation from the Deep Structure to the surface structure statement. But all that information is accessible to you if you ask the right questions.</p>
<p>Over time, my computer may crash, have problems with the hardware, and I may come to feel that the computer wasn’t as good a deal as I thought and I may start saying “I bought a bad computer” and may start feeling bad about it. At this point I am not only deleting information, about it being the best computer I could buy at the time, I am distorting my deep structure; and that distortion is having an effect on my real world interaction. But the deep structure is still accessible, and with the correct questioning, I may come to realise that “I bought the best computer at the time”, and that “the computer I bought, now has some problems” which is a different surface structure representation of the same deep structure and may have a different effect on my outlook. </p>
<p>The Meta Model categorises the transformations from deep structure to surface structure as deletions, generalizations and distortions.</p>
<p>Recognition of Distortion, Deletion and Generalization in a communication allows us to apply a high level analysis to a statement and ask questions to identify:</p>
<ul>
<li>What is missing from this communication that might cause problems,  </li>
<li>What is distorted in this communication, and presented, without adequate definition  </li>
<li>What is generalized in this communication and what is implied by that generalization  </li>
</ul>
<p>The Meta Model categories are further divided into 12 elements: nominalization, cause and effect, mind reading, complex equivalence, lost performative, universal quantifier, modal operator, presupposition, simple deletion, comparative deletion, referential index and unspecified verbs. Each of these elements will be discussed and explained later in the paper.</p>
<p>Each of the 12 elements correspond to recognizable language patterns that are found in human communication and have associated questions that can be asked in order to derive more information about the deep structure associated with the communication. </p>
<p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Test/3-2017-07-20-TestAnalysis-NLP.png" alt="pic3"> </p>
<p>Some reasons why all of this is important are:  </p>
<ul>
<li>Human communication can be ambiguous  </li>
<li>Ambiguity can adversely affect the communication and the communicator  </li>
<li>It is possible to be taught to recognize ambiguity  </li>
<li>It is possible to respond to ambiguity to gain clarification  </li>
<li>Clarification can help both the communicator and the communication  </li>
<li>Software development is a process of human communication   </li>
</ul>
<p>Most software testers will have encountered requirements, which seemed to be understood by everyone but, which every role in the development process had a different interpretation of. This probably resulted in software defects, delays, unhappy users, rework and a whole host of follow on problems.</p>
<p>This is not just a problem with requirements; specifications, defect reports, test strategies, in fact all communication in the software development process can be impacted by ambiguity.</p>
<p>Communication problems in software development are not limited to the artifacts produced and the ‘Chinese whispers’ effect along the software development lifecycle. Many inter-team problems are a result of communication issues, and a practical knowledge of the Meta Model can help testers<br>understand and deal with these issues.</p>
<p>This paper primarily concentrates on artifact analysis with the Meta Model because:</p>
<ul>
<li>I am not about to train you to be a therapist, because I am not a therapist.  </li>
<li>The use of the Meta Model to deal with human belief systems is well covered in the NLP literature.  </li>
<li>The application to artifacts and software systems is a novel use of the Meta Model, and easily applied by Software Testers.  </li>
</ul>
<p><strong>More information on the Meta Model and Software Testing</strong></p>
<p>Now that I have provided an overview of the Meta Model, I will describe some correspondences with Software Testing.</p>
<p>In much the same way that testing is an open-ended task, there is always another test that could be run. The Meta Model is open-ended in that it is a method of inquiry and each application of the Meta Model elicits another surface structure description of the client’s deep structure. This surface structure description can then be subjected to another Meta Model inquiry.</p>
<p>Just as we do not test for the sake of testing, the Meta Model is not use to get information for the sake of information. Testers get information to effect change in the development team’s beliefs about the system. The Meta Model is used to get information to allow therapists to effect a change in the client.<br>Testers can ask questions to get information if it seems to them that a transformation has resulted in a communication that may be ambiguous enough to cause problems of understanding.</p>
<p>When I analyse previous testing projects that I have been on from the point of view of the Meta Model, I find that much of the testing use I have derived from the Meta Model is associated with Generalizations and Deletions. I have designed tests specifically to target these two types of<br>transformations.</p>
<p>Many of the requirements and specification issues that I identify have also associated with Generalization and Deletion, and I have asked simple Meta Model questions to have them clarified. This has resulted in the nature of the testing about to be performed changing and helped achieve better collaboration with other roles involved in the development process.</p>
<p>However, much of the inter-team communication problems have been recognised by distortion.</p>
<pre><code>Note: Each of the Meta Model elements are not wrong or bad. Depending on the
context, they may be highly appropriate and exactly right. They can be sources of
ambiguity, and ambiguity, in software development communication, can be a source of error. </code></pre><p>Copy From <a href="http://www.compendiumdev.co.uk/nlp/NLPForTesters(MetaModel).pdf" target="_blank" rel="noopener">http://www.compendiumdev.co.uk/nlp/NLPForTesters(MetaModel).pdf</a></p>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>Test</tag>
      </tags>
  </entry>
  <entry>
    <title>用例设计之因果图</title>
    <url>/2017/07/18/2017-07-18-TestCase-CauseAndEffectDiagram/</url>
    <content><![CDATA[<h1 id="1-因果图的介绍"><a href="#1-因果图的介绍" class="headerlink" title="1. 因果图的介绍"></a>1. 因果图的介绍</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;因果图法是一种利用图解法分析输入的各种组合情况，从而设计测试用例的方法，它适合于检查程序输入条件的各种组合情况。  </p>
<h2 id="1-1-主要的因果关系"><a href="#1-1-主要的因果关系" class="headerlink" title="1.1 主要的因果关系"></a>1.1 主要的因果关系</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;因果图中主要有两种节点：原因节点与结果节点，这两种节点分别有两种状态：0状态，1状态。若原因为假，则为0状态，否则为1状态；若结果发生，则为1状态，否则为0状态。通常情况下，原因节点用符号ci(i≥1)表示，结果节点用符号ei(i≥1)表示。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在因果图中，原因与结果的主要关系有：与，或，非，恒等。</p>
<pre><code>(1)恒等关系表示原因与结果的一对一关系。若原因为真，则结果就为真；若原因为假，则结果就为假。  
(2)非关系表示原因与结果间的否定，若原因为真，结果就为假；若原因为假，结果就为真。  
(3)或关系表示只要有一个原因为真，结果就为真；当且仅当所有的原因为假，结果才为假。  
(4)与关系表示当且仅当所有原因都为真，结果才为真；只要有一个原因为假，结果就为假。 </code></pre><p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Test/1-2017-07-18-TestCase-CauseAndEffectDiagram.png" alt="pic1">   </p>
<h2 id="1-2-原因之间的约束"><a href="#1-2-原因之间的约束" class="headerlink" title="1.2 原因之间的约束"></a>1.2 原因之间的约束</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;原因之间的约束是指输入条件之间存在的依赖关系(如某些输入条件本身不可能同时出现，或者必须同时出现等)。例如某企业的库存控制管理系统，其功能是跟踪企业产品的库存变化情况。对于每种产品库存的3种状态：库存正常，库存不足，库存为空，在任何情况下这3种状态最多只能有一个为真。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在因果图种原因之间的约束主要有排异约束，包容约束，唯一约束，要求约束。</p>
<pre><code>(1)互斥约束，表示在任何情况下，各个原因之间只能有一个为真（不能同时为真），但可以同时为假，在因果图种用符号E表示。
(2)包含约束，存在包容约束的各个原因中总有一个为真（可以同时为真），但不可以同时为假，在因果图种用符号I表示。
(3)唯一性约束表示各个原因中有且仅有一个为真，在因果图种用符号O表示。
(4)要求约束又称必要性约束，若原因c1，c2之间存在要求约束，表示若c1为真，则c2也必须为真，在因果图中用符号R表示。</code></pre><p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Test/2-2017-07-18-TestCase-CauseAndEffectDiagram.png" alt="pic2"> </p>
<h1 id="2-普通示例"><a href="#2-普通示例" class="headerlink" title="2. 普通示例"></a>2. 普通示例</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;有一个处理单价为1元5角钱的盒装饮料的自动售货机软件。若投入1元5角硬币，按下“可乐”、“雪碧”、或“红茶”按钮，相应的饮料就送出来。若投入的是2元硬币，在送出饮料的同时退还5角硬币。</p>
<p><strong>步骤：</strong>   </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;1.确定需求中的原因与结果   </p>
<p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Test/3-2017-07-18-TestCase-CauseAndEffectDiagram.png" alt="pic3"> </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;2.确定原因与结果的逻辑关系   </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;C1与C2需要一个中间结果Cm1(已投币)，C3、C4、C5需要一个中间结果Cm2(已按钮)。 </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;3.确定因果图中的约束  </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;C1与C2是或的关系，C3、C4、C5是或的关系。 </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;4.画出因果图  </p>
<p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Test/4-2017-07-18-TestCase-CauseAndEffectDiagram.png" alt="pic4">  </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;5.根据因果图并得到决策表  </p>
<p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Test/5-2017-07-18-TestCase-CauseAndEffectDiagram.png" alt="pic5">  </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;6.化简决策表  </p>
<p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Test/6-2017-07-18-TestCase-CauseAndEffectDiagram.png" alt="pic6">  </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;6.根据决策表生成测试用例</p>
<p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Test/7-2017-07-18-TestCase-CauseAndEffectDiagram.png" alt="pic7"> </p>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>用例设计</tag>
      </tags>
  </entry>
  <entry>
    <title>PicRandShow编程纪要</title>
    <url>/2017/08/20/2017-08-20-CSharp-PicRandShow/</url>
    <content><![CDATA[<h1 id="PicRandShow"><a href="#PicRandShow" class="headerlink" title="PicRandShow"></a>PicRandShow</h1><p>Picture Random Show 用于随机或者固定展示图片信息，并在展示过程中不断变换图片位置；主要用于人脸识别测试。</p>
<h3 id="Single-Mode"><a href="#Single-Mode" class="headerlink" title="Single Mode"></a>Single Mode</h3><p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Programing/2017-08-20-CSharp-PicRandShow-1.gif" alt="Single"></p>
<h3 id="Multiple-Mode"><a href="#Multiple-Mode" class="headerlink" title="Multiple Mode"></a>Multiple Mode</h3><p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Programing/2017-08-20-CSharp-PicRandShow-2.gif" alt="Multiple"></p>
<h3 id="Random-Mode"><a href="#Random-Mode" class="headerlink" title="Random Mode"></a>Random Mode</h3><p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Programing/2017-08-20-CSharp-PicRandShow-3.gif" alt="Random"></p>
<h2 id="Settings"><a href="#Settings" class="headerlink" title="Settings"></a>Settings</h2><p>相关模式的设置主要采用配置文件的方式，对文件PicRandShow.exe.config进行相关设置，可以达到目前支持的三种效果展示。<br><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Programing/2017-08-20-CSharp-PicRandShow-4.png" alt="Setting"></p>
<h2 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h2><p>主要采用容器Panel添加PictureBox实现的图片的展示的功能。</p>
<h2 id="ToDo"><a href="#ToDo" class="headerlink" title="ToDo"></a>ToDo</h2><ul>
<li>需要进一步了解委托，事件的相关原理以及实现方式。</li>
<li>需要了解线程的原理，以及实际实现细节。</li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP Connections Status</title>
    <url>/2017/10/16/2017-10-16-TCPConnections/</url>
    <content><![CDATA[<h1 id="1-序言"><a href="#1-序言" class="headerlink" title="1. 序言"></a>1. 序言</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;最近工作进行性能测试时发现，对应VR设备在与服务端建立连接后，用netstat -ano | grep “Port”，发现在推送不同大小的数据时，分别出现了CLOSE_WAIT和FIN_WAIT的状态，于是就有了此文。此前一直知道有网络连接的几次握手，但是平时工作中没有去具体排查如此底层的东西，概念基本就忘得差不多了。知识也只有在平时使用中积累，然后再具体问题出现时进一步加深印象。</p>
<h1 id="2-TCP连接"><a href="#2-TCP连接" class="headerlink" title="2. TCP连接"></a>2. TCP连接</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>TCP（Transmission Control Protocol 传输控制协议）</strong>是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。在简化的计算机网络OSI模型中，它完成第四层传输层所指定的功能，用户数据报协议（UDP）是同一层内另一个重要的传输协议。在因特网协议族（Internet protocol suite）中，TCP层是位于IP层之上，应用层之下的中间层。不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是IP层不提供这样的流机制，而是提供不可靠的包交换。  </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，然后TCP把数据流分区成适当长度的报文段（通常受该计算机连接的网络的数据链路层的最大传输单元（MTU）的限制）。之后TCP把结果包传给IP层，由它来通过网络将包传送给接收端实体的TCP层。TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。TCP用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和。  </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;当我们向服务器发送HTTP请求，获取数据、修改信息时，都需要建立TCP连接，包括三次握手，四次分手。为实现数据的可靠传输，TCP要在应用进程间建立传输连接。它是在两个传输用户之间建立一种逻辑联系，使得通信双方都确认对方为自己的传输连接端点。  </p>
<h2 id="2-1-建立连接"><a href="#2-1-建立连接" class="headerlink" title="2.1 建立连接"></a>2.1 建立连接</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;建立连接前，服务器端首先被动打开其熟知的端口，对端口进行侦听。当客户端要和服务器端建立连接时，发起一个主动打开端口的请求（该端口一般为临时端口）；然后进入三次握手的过程。  </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>Client连接Server</strong>  </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;当Client端调用socket函数调用时，相当于Client端产生了一个处于Closed状态的套接字。  </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;(1）第一次握手：Client端又调用connect函数调用，系统为Client随机分配一个端口，连同传入connect中的参数(Server的IP和端口)，这就形成了一个连接四元组，客户端发送一个带SYN标志的TCP报文到服务器。这是三次握手过程中的报文1。connect调用让Client端的socket处于SYN_SENT状态，等待服务器确认；SYN：同步序列编号(Synchronize Sequence Numbers)。  </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;(2）第二次握手： 服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态。  </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;(3）第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户器和客务器进入ESTABLISHED状态，完成三次握手。连接已经可以进行读写操作。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;一个完整的三次握手也就是：<strong>请求—应答—再次确认</strong>。  </p>
<h2 id="2-2-释放连接"><a href="#2-2-释放连接" class="headerlink" title="2.2 释放连接"></a>2.2 释放连接</h2><p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Tools/2017-10-16-TCPConnections-1.png" alt="pic1">   </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;（1）客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;（2）服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;（3）服务器B关闭与客户端A的连接，发送一个FIN给客户端A。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;（4）客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>NetWork</tag>
      </tags>
  </entry>
  <entry>
    <title>Selenium之XPath元素定位</title>
    <url>/2018/01/29/2018-01-29-Selenium-XPathLocation/</url>
    <content><![CDATA[<h2 id="1-XPath节点"><a href="#1-XPath节点" class="headerlink" title="1. XPath节点"></a>1. XPath节点</h2><p>  XPath语言中提供了7种节点：文档节点(根节点)、元素、属性、文本、命名空间、处理指令、以及注释。XML文档被作为节点树对待，树的根被称作文档节点或根节点。</p>
<h3 id="1-1-节点"><a href="#1-1-节点" class="headerlink" title="1.1 节点"></a>1.1 节点</h3><p>  <strong>XML实例文档</strong>   </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version = "1.0" encoding = "utf-8" ?&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- 这是一个注释节点--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">booklist</span> <span class="attr">type</span> = <span class="string">"kongfu"</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="name">book</span> <span class="attr">category</span> = <span class="string">"kongfu"</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>葵花宝典<span class="tag">&lt;/<span class="name">title</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">author</span>&gt;</span>东方不败<span class="tag">&lt;/<span class="name">author</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">pageNumber</span>&gt;</span>400<span class="tag">&lt;/<span class="name">pageNumber</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;/<span class="name">book</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">booklist</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>  在上面的XML文档实例中展示的节点如下：   </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">booklist</span>&gt;</span>:文档节点  </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>:元素节点   </span><br><span class="line">type = "kongfu":属性节点</span><br></pre></td></tr></table></figure>
<h3 id="1-2-节点间的关系"><a href="#1-2-节点间的关系" class="headerlink" title="1.2 节点间的关系"></a>1.2 节点间的关系</h3><h4 id="1-父节点-Parent"><a href="#1-父节点-Parent" class="headerlink" title="(1)父节点(Parent)"></a>(1)父节点(Parent)</h4><p>  每个元素以及属性都有一个父节点。上面的XML文档实例中，book元素是title、author以及pageNumber元素的父节点。  </p>
<h4 id="2-子节点-Children"><a href="#2-子节点-Children" class="headerlink" title="(2)子节点(Children)"></a>(2)子节点(Children)</h4><p>  一个元素节点可有零个，一个或多个子节点。上面的XML文档实例中，title、author以及pageNumber元素是book元素的子节点。  </p>
<h4 id="3-同胞节点-Sibling"><a href="#3-同胞节点-Sibling" class="headerlink" title="(3)同胞节点(Sibling)"></a>(3)同胞节点(Sibling)</h4><p>  同胞节点表示拥有相同父节点的节点。上面的XML文档实例中，title、author以及pageNumber元素都是同胞节点。  </p>
<h4 id="4-先辈节点-Ancestor"><a href="#4-先辈节点-Ancestor" class="headerlink" title="(4)先辈节点(Ancestor)"></a>(4)先辈节点(Ancestor)</h4><p>  先辈节点表示的某节点的父节点，父节点的父节点，以及父节点的所有祖先节点。上面XML文档实例中，title元素的先辈节点有book和booklist。  </p>
<h4 id="5-后代节点-Descendant"><a href="#5-后代节点-Descendant" class="headerlink" title="(5)后代节点(Descendant)"></a>(5)后代节点(Descendant)</h4><p>  后代节点表示某个节点的子节点，子节点的子节点，以及子节点的所有后代节点。上面的XML文档实例中，booklist元素的后代节点有book、title、author以及pageNumber元素。  </p>
<h2 id="2-Xpath定位语法"><a href="#2-Xpath定位语法" class="headerlink" title="2. Xpath定位语法"></a>2. Xpath定位语法</h2><p>  由于用于Web开发的的HTML语言的语法结构跟XML很相似，所以XPath也支持在HTML代码中定位HTML树状文档结构中的节点。<br>  <strong>被测试网页的HTML代码：</strong>   </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div1"</span> <span class="attr">style</span>=<span class="string">"text-align: center"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">alt</span>=<span class="string">"dvi1-img1"</span> </span></span><br><span class="line"><span class="tag">                 <span class="attr">src</span>=<span class="string">"http://www.sougou.com/images/logo/new/sougou.png"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">href</span>=<span class="string">"http://www.sougou.com"</span>&gt;</span>搜狗图片<span class="tag">&lt;/<span class="name">img</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"div1input"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.sougou.com"</span>&gt;</span>搜狗搜索<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"查询"</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div2"</span> <span class="attr">style</span>=<span class="string">"text-align: center"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">alt</span>=<span class="string">"dvi2-img2"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">src</span>=<span class="string">"http://www.baidu.com/img/bdlogo.png"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">href</span>=<span class="string">"http://www.baidu.com"</span>&gt;</span>百度图片<span class="tag">&lt;/<span class="name">img</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"div1input"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.baidu.com"</span>&gt;</span>百度搜索<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"查询"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>  使用上面的HTML代码生成被测试网页，基于此网页来实践各种不同页面元素的XPath定位方法。  </p>
<h3 id="2-1-使用绝对路径来定位元素"><a href="#2-1-使用绝对路径来定位元素" class="headerlink" title="2.1 使用绝对路径来定位元素"></a>2.1 使用绝对路径来定位元素</h3><p>  绝对路径表示页面元素在被测网页的HTML代码结构中，从根节点一层层地搜索到需要被定位的页面元素，绝对路径起始于正斜杠(/)，每一步均被斜杠分割。<br>  <strong>目的：</strong> 在被测网页中，查找第一个div标签下的“查询”按钮。<br>  <strong>XPath定位表达式：</strong> /html/body/div/input[@value=”查询”]<br>  <strong>Python定位语句：</strong> query = driver.find_element_by_xpath(‘/html/body/div/input[@value=”查询”]’)<br>  <strong>代码解释：</strong><br>  上述XPath定位表达式从HTML DOM树的根节点(html节点)开始逐层查找，最后定位到“查询”按钮节点。路径表达式“/”表示根节点。<br>  <strong>更多说明:</strong><br>  使用绝对路径定位页面元素的好处在于可以验证页面是否发生变化。如果页面结构发生变化，可能会造成原先有效的XPath表达式失效。使用绝对路径定位是十分脆弱的，因为即使页面代码结构只发生微小的变化，也可能会造成原先有效的XPath定位表达式定位失效。因此，建议在自动化测试的定位实施环节中，优先考虑相对路径进行页面元素定位。  </p>
<h3 id="2-2-使用相对路径来定位元素"><a href="#2-2-使用相对路径来定位元素" class="headerlink" title="2.2 使用相对路径来定位元素"></a>2.2 使用相对路径来定位元素</h3><p>  相对路径的每一步都根据当前节点集之中的节点来进行计算，起始于双正斜杠(//)。<br>  <strong>目的：</strong> 在被测网页中，查找第一个div标签下的“查询”按钮。<br>  <strong>XPath定位表达式：</strong> //input[@value=”查询”]<br>  <strong>Python定位语句：</strong> query = driver.find_element_by_xpath(‘//input[@value=”查询”]’)<br>  <strong>代码解释：</strong><br>  上述XPath定位表达式中的“//”表示从匹配选择的当前节点开始选择文档中的节点，而不考虑它们的位置。input[@value=”查询”]表示定位value值为“查询”两个字的input页面元素。<br>  <strong>更多说明:</strong><br>  相对路径的XPath定位表达式更加简洁，不管页面发生了何种变化，只要input标签的value属性值没变，始终可以定位到。推荐使用相对路径的XPath表达式，并且越简洁越好，可大大降低测试脚本定位的表达式的维护成本。    </p>
<h3 id="2-3-使用索引号定位元素"><a href="#2-3-使用索引号定位元素" class="headerlink" title="2.3 使用索引号定位元素"></a>2.3 使用索引号定位元素</h3><p>  索引号表示某个被定位的页面元素在其父元素节点下的同名元素中的位置序号，需要从1开始。<br>  <strong>目的：</strong> 在被测网页中，查找第一个div标签下的“查询”按钮。<br>  <strong>XPath定位表达式：</strong> //input[2]<br>  <strong>Python定位语句：</strong> query = driver.find_element_by_xpath(‘//input[2]’)<br>  <strong>代码解释：</strong><br>  索引号定位方式是根据该页面元素在页面中相同标签名之间的出现的索引位置来进行定位的。上述XPath定位表达式表示查找页面中第二个出现的input元素，即测试页面上的“查询”按钮。<br>  <strong>更多说明:</strong><br>  若在Firefox浏览器的FirePath插件使用“//input[1]”定位表达式进行页面元素定位，可以发现在被测试网页的HTML代码区域高亮显示了两行代码，两个div标签下的第一个input标签都被定位到，这和只查找第一个input元素相冲突，这是由于被测试网页中的两个div标签下都包含了input标签，XPath在查找的时候把每个div节点都当作相同的起始层级开始查找，所以用“//input[1]”表达式会同时查找到两个div节点下的第一个input元素。如果在两个div标签下还有嵌套的div，并且嵌套的div下也有input标签，使用“//input[1]”定位表达式，也会定位到嵌套div下的input标签，也就是说无论嵌套多少层HTML标签，只要这些HTML标签的子标签里有input标签，第一个input标签都会被定位点。因此在使用索引号定位页面元素的时候，需要注意网页HTML代码中是否包含了多个层级完全相同的代码结构，若出现了这种情况，就需要修改定位表达式，以确保自动化测试脚本中使用的定位表达式能唯一定位所需要的页面元素。<br>  但如果想同时定位多个相同的input页面元素，可以使用如下Python语句：<br>  inputList = driver.find_elements_by_xpath(“//input[1]”)<br>  将定位的多个元素存储到list对象中，然后根据list对象的索引号获取想要的页面元素。但如果发现页面元素会经常增加或减少，就不建议使用索引号定位的方式，因为页面变化很可能会让使用索引号的XPath定位表达式失效。<br>  基于实例中的被测试网页，下面给出更多通过索引号定位的实例。  </p>
<table>
<thead>
<tr>
<th>预期定位的页面元素</th>
<th>定位表达式实例</th>
<th>使用的属性值</th>
</tr>
</thead>
<tbody><tr>
<td>定位第二个div下的超链接</td>
<td>//div[last()]/a</td>
<td>div[last()]表示最后一个div元素，last()函数获取的是指定元素的的最后索引号</td>
</tr>
<tr>
<td>定位第一个div中的超链接</td>
<td>//div[last()-1]/a</td>
<td>div[last()-1]表示倒数第二个div元素</td>
</tr>
<tr>
<td>定位最前面一个属于div元素的子元素中的input元素</td>
<td>//div/input[position()&lt;2]</td>
<td>position()函数获取当前元素input的位置序列号</td>
</tr>
</tbody></table>
<h3 id="2-4-使用页面元素的属性值定位元素"><a href="#2-4-使用页面元素的属性值定位元素" class="headerlink" title="2.4 使用页面元素的属性值定位元素"></a>2.4 使用页面元素的属性值定位元素</h3><p>  在定位页面元素的时候，经常会遇到各种复杂结构的被测试网页，并且很多页面元素也没有设计ID，Name等属性，同时又不想使用绝对路径或索引号来定位页面元素，但是发现要被定位的页面元素拥有某些固定不变的的属性和属性值，此时推荐使用属性定位方式来定位页面元素。<br>  <strong>目的：</strong> 在被测网页中，定位网页中的第一张img元素。<br>  <strong>XPath定位表达式：</strong> //img[@alt=”div1-img1”]<br>  <strong>Python定位语句：</strong> img = driver.find_element_by_xpath(‘//img[@alt=”div1-img1”]’)<br>  <strong>代码解释：</strong><br>  表达式使用了相对路径再结合元素拥有的特定属性的方法进行定位，定位元素img的属性是”alt”,其属性值为”div1-img1”，使用@符号指明后面接的是属性，并同属性及属性值一同写到元素后面的方括号中。<br>  <strong>更多说明:</strong><br>  被测试网页的元素通常会包含各种各样的属性值，并且很多属性值是唯一的。若能确认属性值不变且唯一，建议使用相对路径再结合属性值的定位方式来编写XPath定位表达式，使用此方法可以解决99%的页面元素定位难题。  </p>
<table>
<thead>
<tr>
<th>预期定位的页面元素</th>
<th>定位表达式实例</th>
<th>使用的属性值</th>
</tr>
</thead>
<tbody><tr>
<td>定位页面的第一张图片</td>
<td>//img[@href=’<a href="http://www.sougou.com&#39;]" target="_blank" rel="noopener">http://www.sougou.com&#39;]</a></td>
<td>使用img标签的href属性值</td>
</tr>
<tr>
<td>定位第二个div中的第一个input输入框</td>
<td>//div[@name=’div2’]/input[@name=’div2input’]</td>
<td>使用div标签的name属性值，使用input标签的name属性值</td>
</tr>
<tr>
<td>定位第一个div中的第一个链接</td>
<td>//div[@id=’div1’]/a[@href=’<a href="http://www.sougou.com&#39;]" target="_blank" rel="noopener">http://www.sougou.com&#39;]</a></td>
<td>使用div标签的ID属性值，使用a标签的href属性值</td>
</tr>
<tr>
<td>定位页面的查询按钮</td>
<td>//input[@type=’button’]</td>
<td>使用type属性值</td>
</tr>
</tbody></table>
<h3 id="2-5-使用模糊属性值定位元素"><a href="#2-5-使用模糊属性值定位元素" class="headerlink" title="2.5 使用模糊属性值定位元素"></a>2.5 使用模糊属性值定位元素</h3><p>  模糊属性值定位方式表示使用属性值的一部分内容进行定位。在自动化测试的实施过程中，常常会遇到页面元素的属性值是动态生成的，也就是时候每次访问属性值都不一样，此类页面元素会加大定位难度，使用模糊属性值定位方式可以解决一部分此类难题，但前提是属性值中有一部分内容保存不变。XPath提供了一些课实现模糊属性值定位的函数。  </p>
<table>
<thead>
<tr>
<th>XPath函数</th>
<th>定位表达式实例</th>
<th>使用的属性值</th>
</tr>
</thead>
<tbody><tr>
<td>start-with(str1,str2)</td>
<td>//img[start-with(@alt,’div1’)]</td>
<td>查找属性alt的属性值以“div1”关键字开始的页面元素</td>
</tr>
<tr>
<td>contains(str1,str2)</td>
<td>//img[contains(@alt,’img’)]</td>
<td>查找alt属性的属性值包含“img”关键字的页面元素，只要包含即可，无需考虑位置</td>
</tr>
</tbody></table>
<p>  contains()函数属于XPath的高级用法，使用场景较多，尽管页面元素的属性值经常发生变化，但只要其属性值有几个固定不变的关键字，就可以使用contains()函数进行定位。  </p>
<h3 id="2-6-使用XPath轴-Axes-定位元素"><a href="#2-6-使用XPath轴-Axes-定位元素" class="headerlink" title="2.6 使用XPath轴(Axes)定位元素"></a>2.6 使用XPath轴(Axes)定位元素</h3><p>  轴可以定义相对于当前节点的节点集。使用XPath(Axes)定位方式可根据在文档树中的元素相对位置关系进行页面元素定位。先找到一个相对好定位的元素，让它作为轴，根据它和要定位元素间的相对位置关系进行定位，可以解决一些元素难定位的问题。  </p>
<table>
<thead>
<tr>
<th>XPath轴关键字/轴的含义说明</th>
<th>定位表达式实例</th>
<th>使用的属性值</th>
</tr>
</thead>
<tbody><tr>
<td>parent:选择当前节点的上层父节点</td>
<td>//img[@alt=’div2-img2’]/parent::div</td>
<td>查找属性alt的属性值为div2-img2的img元素，并基于该img元素的位置找到它上一级的div页面元素</td>
</tr>
<tr>
<td>child:选择当前节点的下层所有子节点</td>
<td>//div[@id=’div1’]/child::img</td>
<td>查找到ID属性为div1的div元素，并基于div的位置找到它的下层节点中的img元素</td>
</tr>
<tr>
<td>ancestor:选择当前节点的所有上层的节点</td>
<td>//img[@alt=’div2-img2’]/ancestor::div</td>
<td>查找到属性alt的属性值为div2-img2的img元素，并基于该img元素的位置找到它上级的div页面元素</td>
</tr>
<tr>
<td>descendant:选择当前节点所有下层的节点(子，孙等)</td>
<td>//div[@name=’div2’]/descendant::img</td>
<td>查找到属性name的属性值为div2-img2的img元素，并基于该元素的位置查找到它的下级所有节点中的img页面元素</td>
</tr>
<tr>
<td>following:选择在当前节点之后显示的所有节点</td>
<td>//div[@id=’div1’]/following::img</td>
<td>查到到ID属性值为div1的div页面元素，并基于div的位置找到它后面节点中的img页面元素</td>
</tr>
<tr>
<td>following-sibling:选择当前节点后续所有兄弟节点</td>
<td>//a[@href=’<a href="http://www.sougou.com&#39;]/following-sibling::input" target="_blank" rel="noopener">http://www.sougou.com&#39;]/following-sibling::input</a></td>
<td>查找到链接地址为<a href="http://www.sougou.com的链接页面元素a,并基于链接的位置找到它后续的兄弟节点中的input页面元素" target="_blank" rel="noopener">http://www.sougou.com的链接页面元素a,并基于链接的位置找到它后续的兄弟节点中的input页面元素</a></td>
</tr>
<tr>
<td>preceding:选择当前节点前面的所有节点</td>
<td>//img[@alt=’div2-img2’]/preceding::div</td>
<td>查到到属性alt的属性值为div2-img2的图片页面元素img，并基于图片的位置找到它前面节点中的div页面元素</td>
</tr>
<tr>
<td>preceding-sibling:选择当前节点前面的所有兄弟节点</td>
<td>//input[@value=’查询’]/preceding-sibling::a[1]</td>
<td>查找到value属性值为“查询”的输入框页面元素，并基于该输入框的位置找到它前面同级节点中的第一个链接页面元素</td>
</tr>
</tbody></table>
<p>  <strong>更多说明:</strong><br>  有时候我们会在轴的后面加一个星号(<em>)，表示通配符，比如//input[@value=’查询’]/preceding-sibling::</em>,它表示查找属性value的值为“查询”的输入框input元素前面所有的同级元素，但不包括input元素本身。</p>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>AutoTest</tag>
      </tags>
  </entry>
  <entry>
    <title>测试数据分析</title>
    <url>/2017/11/12/2017-11-12-TestAnalysis-DataAnalysis/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;由于公司做了一个用于局域网交互的系统，此系统包含的设备包括VR设备(类似于手机)，平板电脑，电脑。主要通过电脑作为服务器，将相关课程数据(类似于视频，apk等)推送至VR设备，且能够发送一些指令对VR设备进行操控。当然平板电脑也能够作为控制所有VR设备的一个终端。这套系统中电脑一台，平板电脑一台，VR设备N台，就这样的一套系统，需要对其局域网的稳定性，以及在线率等进行测试，给出数据。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;电脑端有一个控制台，可以查看VR端以及平板电脑的各种状态，如下图。当然我，首先需要搭一个这样的局域网环境，很简单就是找个路由器，连接到路由器上就可以了，登陆服务端网站就能查看到对应设备是否在线。<br><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Test/1-2017-11-12-TestAnalysis-DataAnalysis.png" alt="pic1"> </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;要看设备是否保持在线，当然是通过上图的网站来查看设备是否在线；可是我不可能实时来刷新网站，并手动记录数据；于是这里就通过服务端开的接口对接口(<a href="http://localhost:8100/api/device)进行请求，并通过返回的json数据进行分析，保存记录下设备在线数据。" target="_blank" rel="noopener">http://localhost:8100/api/device)进行请求，并通过返回的json数据进行分析，保存记录下设备在线数据。</a></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://github.com/yaitza/RequestAnalysis" target="_blank" rel="noopener">https://github.com/yaitza/RequestAnalysis</a></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;通过上面工具记录下来的数据，就是最原始的数据；需要对原始数据进行各种分析，得到想要的结果；可是有的时候数据量很大，而且很繁琐；这时候无意中发现Excel，宏录制功能很好用，就录制了一段宏；处理十来个Excel数据，感觉还是很方便。可是突然有一天Excel上升到50个了，我再一个一个点开，尼玛就有点不现实了，于是我又开始了些VBA脚本了，写完之后发现功能很强大，以后可以节省好多工作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sub ExecuteAllFiles()</span><br><span class="line">&#39;统计当前文件夹下所有csv文件的测试数据</span><br><span class="line"></span><br><span class="line">    Dim DefaultPath, logFilePath As String</span><br><span class="line">    Dim fileDir(100) As String</span><br><span class="line">    </span><br><span class="line">    DefaultPath &#x3D; Application.ActiveWorkbook.Path &amp; &quot;\&quot;</span><br><span class="line">    logFilePath &#x3D; DefaultPath &amp; &quot;NoCount_OffLine_Count.csv&quot;</span><br><span class="line"></span><br><span class="line">    Dim counter As Long</span><br><span class="line">    counter &#x3D; Range(&quot;S3&quot;).Value</span><br><span class="line">    If counter &#x3D; 0 Then</span><br><span class="line">        Range(&quot;S3&quot;).Select</span><br><span class="line">        MsgBox (&quot;请在选中的单元格输入需要统计数据的行数。&quot; &amp; vbCrLf &amp; &quot;输入行数以Excel的行标记为准。 &quot;)</span><br><span class="line">    ElseIf Dir(logFilePath) &#x3D; &quot;&quot; &amp; Range(&quot;S9&quot;) &#x3D; 1 Then</span><br><span class="line">        MsgBox (&quot;对应目录中无Warn.log日志文件统计数据。&quot;)</span><br><span class="line">    Else</span><br><span class="line">        &#39;设置文档首行标题</span><br><span class="line">        Cells(1, &quot;A&quot;) &#x3D; &quot;SN号&quot;</span><br><span class="line">        Cells(1, &quot;B&quot;) &#x3D; &quot;掉线次数&quot;</span><br><span class="line">        Cells(1, &quot;C&quot;) &#x3D; &quot;掉线时长&quot;</span><br><span class="line">        Cells(1, &quot;D&quot;) &#x3D; &quot;设备对应IP&quot;</span><br><span class="line">        </span><br><span class="line">        If Range(&quot;S9&quot;) &#x3D; 1 Then</span><br><span class="line">            Cells(1, &quot;E&quot;) &#x3D; &quot;5s掉线1次&quot;</span><br><span class="line">            Cells(1, &quot;F&quot;) &#x3D; &quot;5s掉线2次&quot;</span><br><span class="line">            Cells(1, &quot;G&quot;) &#x3D; &quot;5s掉线3次&quot;</span><br><span class="line">        End If</span><br><span class="line"></span><br><span class="line">        filePath &#x3D; Dir(DefaultPath &amp; &quot;&quot;)</span><br><span class="line">        </span><br><span class="line">        Dim iCounter As Integer</span><br><span class="line">        iCounter &#x3D; 2</span><br><span class="line"></span><br><span class="line">        &#39;遍历当前目录下所有文件</span><br><span class="line">        While filePath &lt;&gt; &quot;&quot;</span><br><span class="line">            If Left(filePath, 8) &lt;&gt; &quot;NoCount_&quot; Then</span><br><span class="line">                Cells(iCounter, &quot;A&quot;).NumberFormatLocal &#x3D; &quot;@&quot;</span><br><span class="line">                Cells(iCounter, &quot;A&quot;) &#x3D; Left(filePath, 15)</span><br><span class="line">                fileDir(iCounter - 2) &#x3D; DefaultPath &amp; filePath</span><br><span class="line">                </span><br><span class="line">                Application.Workbooks.Open (fileDir(iCounter - 2))</span><br><span class="line">                Dim calData, offLineCounts, offLineSeconds, deviceIp As String</span><br><span class="line">                calData &#x3D; CountTestData(Application.ActiveSheet, 2, counter)</span><br><span class="line">                offLineCounts &#x3D; Split(calData, &quot;|&quot;)(1)</span><br><span class="line">                offLineSeconds &#x3D; Split(calData, &quot;|&quot;)(0)</span><br><span class="line">                deviceIp &#x3D; Split(calData, &quot;|&quot;)(2)</span><br><span class="line">                Application.ActiveWorkbook.Close SaveChanges:&#x3D;0</span><br><span class="line"></span><br><span class="line">                Cells(iCounter, &quot;B&quot;) &#x3D; offLineCounts</span><br><span class="line">                Cells(iCounter, &quot;C&quot;) &#x3D; offLineSeconds</span><br><span class="line">                Cells(iCounter, &quot;D&quot;) &#x3D; deviceIp</span><br><span class="line"></span><br><span class="line">                If Range(&quot;S9&quot;) &#x3D; 1 Then</span><br><span class="line">                    Application.Workbooks.Open (logFilePath)</span><br><span class="line">                    secondCount &#x3D; CountWarnOffLinebyfiveSeconds(Application.ActiveSheet, deviceIp)</span><br><span class="line">                    Application.ActiveWorkbook.Close SaveChanges:&#x3D;0</span><br><span class="line">                    </span><br><span class="line">                    Cells(iCounter, &quot;E&quot;) &#x3D; Split(secondCount, &quot;|&quot;)(0)</span><br><span class="line">                    Cells(iCounter, &quot;F&quot;) &#x3D; Split(secondCount, &quot;|&quot;)(1)</span><br><span class="line">                    Cells(iCounter, &quot;G&quot;) &#x3D; Split(secondCount, &quot;|&quot;)(2)</span><br><span class="line">                End If</span><br><span class="line">                iCounter &#x3D; iCounter + 1</span><br><span class="line">            End If</span><br><span class="line">            filePath &#x3D; Dir</span><br><span class="line">        Wend</span><br><span class="line">    End If</span><br><span class="line">End Sub</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;这段脚本中，对于遍历文件夹下所有文件的处理，肯定以后还会用到，此处特定说明。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Function TraverseFolder(folderPath As String)</span><br><span class="line">	folderDir &#x3D; folderPath &amp; &quot;\&quot;</span><br><span class="line">	filePath &#x3D; Dir(folderDir  &quot;&quot;)</span><br><span class="line">	while filePath &lt;&gt; &quot;&quot;</span><br><span class="line">		Debug.Print(filePath)</span><br><span class="line">		filePath &#x3D; Dir</span><br><span class="line">	Wend</span><br><span class="line">End Function</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;工具示例Demo：<a href="https://github.com/yaitza/RequestAnalysis/blob/master/Resource/2017-11-12-TestAnalysis-DataAnalysis.rar" target="_blank" rel="noopener">Demo Download</a></p>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>TestExample</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell For Windows</title>
    <url>/2017/09/24/2017-09-24-Shell-ShellForWindows/</url>
    <content><![CDATA[<h1 id="1-windows上unix工具"><a href="#1-windows上unix工具" class="headerlink" title="1. windows上unix工具"></a>1. windows上unix工具</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;工作中经常会使用一些命令来执行一些操作，由于Windows的命令功能没Linux命令功能强大，且在两个操作系统之间切换，使用命令也容易搞混淆；于是就发现了一款可以在Windows上使用Linux或Unix命令的工具。   </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>UnxUtils</strong> is a collection of ports of common GNU Unix-like utilities to native Win32, with executables only depending on the Microsoft C-runtime msvcrt.dll. The collection was last updated externally on April 15, 2003 by Karl M. Syring. The most recent release package available as of December 2016 was an open-source project, UnxUtils at SourceForge, with the latest binary release in March, 2007 (though the files within are dated from the year 2000). The independent distribution included a main zip archive (UnxUtils.zip, 3,365,638 bytes) complemented by more recent updates (UnxUpdates.zip, 878,847 bytes, brought some binaries up to year 2003), but the Sourceforge project has no UnxUpdates.zip package. An alternative source of Unix-like utilities for Windows is GnuWin32; it has later versions of many programs, but requires supporting files (e.g. DLLs) in many cases.</p>
<h1 id="2-UnxUtils安装"><a href="#2-UnxUtils安装" class="headerlink" title="2. UnxUtils安装"></a>2. UnxUtils安装</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;按照提供的<a href="https://sourceforge.net/projects/unxutils/" target="_blank" rel="noopener">DownLoad Address</a>下载UnxUtils，解压UnxUtils得到：<br><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Tools/2017-09-24-Shell-ShellForWindows-1.png" alt="pic1">  </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;然后将D:\UnxUtils\usr\local\wbin设置于Windows操作系统环境变量Path中，然后就可以像Linux或Unix一样使用相关命令了。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>手机天府通卡开卡教程【电信】</title>
    <url>/2018/10/23/2018-10-23-NFC-Setting/</url>
    <content><![CDATA[<h1 id="1-首先我们需要检查手机是否具备NFC功能"><a href="#1-首先我们需要检查手机是否具备NFC功能" class="headerlink" title="1.首先我们需要检查手机是否具备NFC功能"></a>1.首先我们需要检查手机是否具备NFC功能</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;一般在通知栏 会有NFC开关；以华为手机为例 找到NFC的路径 依次为 设置-&gt;设备连接-&gt;NFC。<br>&nbsp;&nbsp;&nbsp;&nbsp;以小米手机为例，找到NFC的路径，依次为：设置-&gt;更多连接方式-&gt;打开NFC。<br>&nbsp;&nbsp;&nbsp;&nbsp;以三星手机为例，找到NFC路径，依次为：设置-&gt;连接-&gt;NFC和支付。<br>&nbsp;&nbsp;&nbsp;&nbsp;以魅族手机为例，找到NFC 路径，依次为：设置-&gt;其它连接方式-&gt;NFC。<br>&nbsp;&nbsp;&nbsp;&nbsp;其他型号手机，请自行百度。<br><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Tools/1-2018-10-23-NFC-Setting.png" alt="NFC">   </p>
<h1 id="2-电信营业厅更换NFC-SIM卡"><a href="#2-电信营业厅更换NFC-SIM卡" class="headerlink" title="2.电信营业厅更换NFC-SIM卡"></a>2.电信营业厅更换NFC-SIM卡</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;以下是电信官方出示的换卡营业厅；已经经过测试热心群友亲自能换到卡的营业厅。一般情况下标杆营业厅都能换到卡。电信的NFC卡有一些注意事项，请务必注意清楚，否则无法完成开卡和次卡刷乘(次卡貌似需要到公交卡充值点去充值，不能像电子钱包一样直接线上充值，是不是很坑)。详见下图。<br><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Tools/2-2018-10-23-NFC-Setting.jpg" alt="NFC"> </p>
<h1 id="3-电信换卡注意事项"><a href="#3-电信换卡注意事项" class="headerlink" title="3.电信换卡注意事项"></a>3.电信换卡注意事项</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;ICCID结尾必须为XQ或Y或BQ不能为HQ或H BQ为新版卡所以服务器R9对应图中R1 R10对应R2；其实也没这么麻烦，你只需要到营业厅说，我要刷天府通的NFC卡，营业员就知道了。<br><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Tools/3-2018-10-23-NFC-Setting.jpg" alt="NFC"><br><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Tools/4-2018-10-23-NFC-Setting.jpg" alt="NFC"><br><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Tools/5-2018-10-23-NFC-Setting.jpg" alt="NFC"></p>
<h1 id="4-手机插卡事项"><a href="#4-手机插卡事项" class="headerlink" title="4.手机插卡事项"></a>4.手机插卡事项</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;换好卡以后，双卡手机，请务必把NFC卡插到卡槽一；特殊的有华为荣耀V10、三星S9双卡槽都支持NFC、可以先到双卡设置中将卡二关闭、并把默认拨号和网络切换到卡一上面 然后在NFC设置中，将默认付款(华为手机)设置为SIM卡。<br>注:华为手机NFC SIM模式和应用已经结合在一起，因系统版本不同NFC安全芯片设置为有所不同；有SIM就选SIM，有安全芯片位置就选卡一。如果上述都没有请下载，翼支付钱包APP，默认付款选择钱包 ，手机会自动切换到NFCSIM模式上。<br>&nbsp;&nbsp;&nbsp;&nbsp;其他手机请自行百度如何解决。<br><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Tools/6-2018-10-23-NFC-Setting.jpg" alt="NFC"><br><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Tools/7-2018-10-23-NFC-Setting.jpg" alt="NFC"><br><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Tools/8-2018-10-23-NFC-Setting.jpg" alt="NFC"></p>
<h1 id="5-APP设置"><a href="#5-APP设置" class="headerlink" title="5.APP设置"></a>5.APP设置</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;一切设置完毕以后，我们下载天府通APP，并下载OPENNFC插件。以华为手机为例，在手机管家-&gt;应用启动管理-&gt;将open Nfc插件的自启动和关联启动打开;在设置中 将应用权限设置为信任。<br><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Tools/9-2018-10-23-NFC-Setting.jpg" alt="NFC"><br><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Tools/10-2018-10-23-NFC-Setting.jpg" alt="NFC"><br><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Tools/11-2018-10-23-NFC-Setting.jpg" alt="NFC"></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>NFC</tag>
      </tags>
  </entry>
  <entry>
    <title>Android电量测试方法研究与总结</title>
    <url>/2019/02/20/2019-02-20-Android-Quantity/</url>
    <content><![CDATA[<h1 id="1-研究背景"><a href="#1-研究背景" class="headerlink" title="1. 研究背景"></a>1. 研究背景</h1><p>在2017年Google I/O大会上，Google发布了Google Play管理中心的新功能：Android vitals。当app在大量设备上运行时，Android vitals会收集与应用性能相关的各种匿名数据，比如：与app稳定性相关的数据、app启动时间、电量使用情况、渲染时间以及权限遭拒等等，这些数据会被分析整理后展示在Google Play管理中心的Android vitals dashboard中。Android vitals 中需要开发者重点关注的核心指标有：crash率、ANR率、excessive wakeups（过渡唤醒）、stuck wake locks（唤醒锁定卡住）。其他指标，需根据应用类型选择性关注（Android vitals中的指标总览见图1-1）。若app某些指标表现很差，会影响用户体验，并且会导致应用在Google Play商店中的等级很低、排名靠后（APP指标异常示例图见图1-2）。开发者可以通过分析Android vitals中提供的一些参照指标，采取相应的措施来优化app。<br><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Test/2019-02-20-Android-Quantity-1.jpg" alt="Android vitals平台检测指标总览">   </p>
<p>  图1-1 Android vitals平台检测指标总览</p>
<p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Test/2019-02-20-Android-Quantity-2.jpg" alt="某APP指标异常示例图">   </p>
<p>  图1-2 某APP指标异常示例图</p>
<h1 id="2-核心指标详细信息"><a href="#2-核心指标详细信息" class="headerlink" title="2. 核心指标详细信息"></a>2. 核心指标详细信息</h1><p>要对APP的指标进行监控，首先要明确该指标在Android vitals中是如何进行统计的，这一节主要介绍电量相关核心指标的基本概念和计算方式。</p>
<h2 id="2-1-Stuck-partial-wake-locks（部分唤醒锁定卡住）"><a href="#2-1-Stuck-partial-wake-locks（部分唤醒锁定卡住）" class="headerlink" title="2.1 Stuck partial wake locks（部分唤醒锁定卡住）"></a>2.1 Stuck partial wake locks（部分唤醒锁定卡住）</h2><h3 id="A-WakeLock（唤醒锁）基本概念："><a href="#A-WakeLock（唤醒锁）基本概念：" class="headerlink" title="A.WakeLock（唤醒锁）基本概念："></a>A.WakeLock（唤醒锁）基本概念：</h3><p>Android系统本身为了优化电量的使用，会在没有操作时进入休眠状态, 来节省电量。为了便于开发(很多应用不可避免的希望在灭屏后还能运行一些事儿，或是要保持屏幕一直亮着–比如播放视频)，Android提供了一个PowerManager.WakeLock的东西。我们可以用WakeLock来保持CPU运行，或是防止屏幕变暗/关闭，让手机可以在用户不操作时依然可以做一些事儿。然而，获取WakeLock很容易，释放不好就会成为难题，消耗电量。  </p>
<p>例如我们获取了一个WakeLock来保持CPU运转，做一个复杂运算并将数据上传到后台服务器, 然后释放该WakeLock。然而这个过程可能并不像我们想象的那么快，可能因为比如服务器挂掉，计算出了异常等等WakeLock没有释放。问题就来了，CPU会一直得不到休眠，而大大增加耗电。</p>
<p>唤醒锁可划分为并识别四种用户唤醒锁：</p>
<p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Test/2019-02-20-Android-Quantity-3.jpg" alt="四种用户唤醒锁"> </p>
<p>自 API 等级 17 开始，FULL_WAKE_LOCK 将被弃用。应用应使用FLAG_KEEP_SCREEN_ON。</p>
<p>相关链接： <a href="https://developer.android.com/reference/android/os/PowerManager" target="_blank" rel="noopener">https://developer.android.com/reference/android/os/PowerManager</a></p>
<h3 id="B-Partial-wake-locks（部分唤醒锁）："><a href="#B-Partial-wake-locks（部分唤醒锁）：" class="headerlink" title="B.Partial wake locks（部分唤醒锁）："></a>B.Partial wake locks（部分唤醒锁）：</h3><p>部分唤醒锁可确保CPU正常运行，但屏幕和键盘背光可以关闭。如果运行在后台的APP长时间持有某个部分唤醒锁，就导致部分唤醒锁卡住。这种情况十分消耗设备电量，因为它会阻止设备进入低电量状态。Android vitals重点关注了stuck partial wake locks这项指标，当你的APP存在唤醒锁定卡住的现象时，它会通过Play管理中心给出告警（APP出现部分唤醒锁定卡住示例图见图2-1），并从各个维度给出相关的详细统计图（如图2-2中给出每个工作时段后台wake lock最长持续时间分布图）。当出现以下情况时，Android vitals会报告唤醒锁定卡住：</p>
<p>至少70%以上的battery sessions发生过至少一次、长达一小时以上的部分唤醒锁定。<br>当只在后台运行时，至少10%以上的battery sessions发生过至少一次、长达一小时以上的部分唤醒锁定。</p>
<p>（ps：battery session指两次电池充满电之间的时间间隔，Android vitals展示的battery sessions是所有app测试用户的battery session合计。）</p>
<p>相关链接： <a href="https://developer.android.google.cn/topic/performance/vitals/wakelock" target="_blank" rel="noopener">https://developer.android.google.cn/topic/performance/vitals/wakelock</a> </p>
<p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Test/2019-02-20-Android-Quantity-4.jpg" alt="某APP出现部分唤醒锁定卡住"> </p>
<p>图2-1 某APP出现部分唤醒锁定卡住（后台）示例图  </p>
<p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Test/2019-02-20-Android-Quantity-5.jpg" alt="每个工作时段后台wake lock最长持续时间的分布图"> </p>
<p>图2-2 每个工作时段后台wake lock最长持续时间的分布图</p>
<h2 id="2-2-Excessive-wakeups（过渡唤醒）"><a href="#2-2-Excessive-wakeups（过渡唤醒）" class="headerlink" title="2.2 Excessive wakeups（过渡唤醒）"></a>2.2 Excessive wakeups（过渡唤醒）</h2><h3 id="A-Wakeups-基本概念"><a href="#A-Wakeups-基本概念" class="headerlink" title="A.Wakeups 基本概念"></a>A.Wakeups 基本概念</h3><p>Wakeups 是AlarmManager API中的一种机制，开发者可以设置一个alarm在特定的时间来唤醒设备。当某个唤醒alarm触发，设备会走出低电量模式，在执行alarm的onRecieve（）或onAlarm（）方法的时候，Alarm Manager会持有一个部分唤醒锁。如果wake alarms频繁触发，会耗尽设备电量。Android vitals中展示了app的过渡唤醒次数。</p>
<p>Alarm有以下四种类型：</p>
<h4 id="1-RTC-WAKEUP"><a href="#1-RTC-WAKEUP" class="headerlink" title="1. RTC_WAKEUP"></a>1. RTC_WAKEUP</h4><p>在指定的时刻（设置Alarm的时候），唤醒设备来触发Intent。</p>
<h4 id="2-RTC"><a href="#2-RTC" class="headerlink" title="2. RTC"></a>2. RTC</h4><p>在一个显式的时间触发Intent，但不唤醒设备。</p>
<h4 id="3-ELAPSED-REALTIME"><a href="#3-ELAPSED-REALTIME" class="headerlink" title="3. ELAPSED_REALTIME"></a>3. ELAPSED_REALTIME</h4><p>从设备启动后，如果流逝的时间达到总时间，那么触发Intent，但不唤醒设备。流逝的时间包括设备睡眠的任何时间。注意一点的是，时间流逝的计算点是自从它最后一次启动算起。</p>
<h4 id="4-ELAPSED-REALTIME-WAKEUP"><a href="#4-ELAPSED-REALTIME-WAKEUP" class="headerlink" title="4. ELAPSED_REALTIME_WAKEUP"></a>4. ELAPSED_REALTIME_WAKEUP</h4><p>从设备启动后，达到流逝的总时间后，如果需要将唤醒设备并触发Intent。</p>
<p>在Android vitals中只列出了RTC_WAKEUP和ELAPSED_REALTIME_WAKEUP两种类型的唤醒数据，Google会统计每小时发生10次以上wakeup的电池工作时段百分比（APP发生过渡唤醒示例见图2-3）。分别从应用版本、wakeup标记、设备、Android版本等几个维度统计每小时的Alarm Manager wakeup次数（每个工作时段中每小时的wackup分布图见图2-4）</p>
<p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Test/2019-02-20-Android-Quantity-6.jpg" alt="某APP发生过渡唤醒示例图"> </p>
<p>图2-3 某APP发生过渡唤醒示例图</p>
<p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Test/2019-02-20-Android-Quantity-7.jpg" alt="每个工作时段每小时wakeup次数分布图"> </p>
<p>图2-4 每个工作时段每小时wakeup次数分布图</p>
<h1 id="3、测试方法研究"><a href="#3、测试方法研究" class="headerlink" title="3、测试方法研究"></a>3、测试方法研究</h1><h2 id="3-1-传统电量测试方法回顾"><a href="#3-1-传统电量测试方法回顾" class="headerlink" title="3.1 传统电量测试方法回顾"></a>3.1 传统电量测试方法回顾</h2><p>我们之前也对腾讯视频主线版本进行过电量测试，之前关注的重点在于APP在各场景中耗电量是否正常，是从比较宏观的角度去进行测试的，采取的测试方法主要是物理仪器测试法和GT测试法。</p>
<h3 id="A-物理仪器测试法（电流表等）"><a href="#A-物理仪器测试法（电流表等）" class="headerlink" title="A.物理仪器测试法（电流表等）"></a>A.物理仪器测试法（电流表等）</h3><p>在保持电压恒定的情况下，获取各场景平均电流值来统计系统耗电情况，通过此方法可以从大体上看出APP电量消耗是否正常，若仪器精度大，此方法测出的电量值是最准确的。<br>缺陷：此方法只能测试整个手机的电流，不能区分APP，受影响的因素多，如屏幕亮度大小、音量大小等等，要保证每次测试的环境完全一致是不可能的。  </p>
<p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Test/2019-02-20-Android-Quantity-8.jpg" alt="物理仪器测电量"> </p>
<p>图3-1 物理仪器测电量</p>
<h3 id="B-GT测试法"><a href="#B-GT测试法" class="headerlink" title="B.GT测试法"></a>B.GT测试法</h3><p>GT（随身调）是由MIG专项测试组自主研发的APP随身调测平台，它是直接运行在手机上的“集成调测环境”(IDTE, Integrated Debug Environment)。利用GT，仅凭一部手机，无需连接电脑，您即可对APP进行快速的性能测试(CPU、内存、流量、电量、帧率/流畅度等等)、开发日志的查看、Crash日志查看、网络数据包的抓取、APP内部参数的调试、真机代码耗时统计等。<br>通过GT，可以采集手机耗电量相关数据：电流、电压、电量、温度等，通过分析这些数据，可以对整个手机的电量使用情况进行分析。</p>
<p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Test/2019-02-20-Android-Quantity-9.jpg" alt="物理仪器测电量">  </p>
<p>缺点：和物理仪器测试方法一样，采用GT测试也只能获取到整个手机的电量数据，无法只关注单独APP，且受各种因素影响较大。</p>
<h2 id="3-2-国际版电量测试方法预研"><a href="#3-2-国际版电量测试方法预研" class="headerlink" title="3.2 国际版电量测试方法预研"></a>3.2 国际版电量测试方法预研</h2><p>由于国际版APP在Google Play上发布，我们做电量测试不仅仅需要关注整个APP的电量使用情况是否正常，还需要关注APP持有 wack lock和使用alarm的情况。因此，传统的电量测试方法已经无法满足我们的需求，我们需要在此基础上增加额外的测试方法。</p>
<h3 id="A-Batterystats-bugreport"><a href="#A-Batterystats-bugreport" class="headerlink" title="A. Batterystats/ bugreport"></a>A. <strong>Batterystats/ bugreport</strong></h3><p>Android5.0后，电量数据可通过dumpsys batterystats获取。Android系统统计耗电量的基本公式是W=U<em>I</em>t。在手机中，U一般恒定不变，因此可以单独通过Q（电容量）=I*t来表示电量。核心类BatterStatsImpl提供App各部件运行时间、PowerProfile提供部件电流数值。Android部件电流信息存于：power_profile.xml文件中，每个OEM厂商都有私有的power_profile.xml文件，PowerProfile通过读取该文件获取访问部件电流数值（图3-3是samsung某型号的power_profile.xml）。Android系统以uid为单位，依次统计每个apk的使用cpu使用耗电量、wake lock耗电量、移动数据耗电量、wifi数据耗电量、wifi维持耗电量、wifi扫描耗电量、各传感器耗电量。其中wake lock消耗的电量只统计了持有Partial wake lock的耗电量，正好是我们需要关注的唤醒类型，因此我们可以通过分析batterystats获得的电量数据来测试app持有Partial wake lock情况。<br>Android为了方便开发人员分析整个系统平台和某个app在运行一段时间之内的所有信息，专门开发了bugreport工具。bugreport文件中记录了系统允许过程中的各种log信息，其中也包括了耗电量信息。通过分析bugreport中的电量相关数据也能获取APP持有Partial wake lock的信息。<br>ps：Uid与App关系：2个App签名和sharedUserId相同，则在运行时，他们拥有相同Uid。就是说processAppUsage统计的可能是多个App的耗电量数据，对于普通App，出现这种情况的几率较少，而对于Android系统应用则较为常见。<br><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Test/2019-02-20-Android-Quantity-10.jpg" alt="wack lock耗电量计算源代码"><br>图3-2 wack lock耗电量计算源代码<br><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Test/2019-02-20-Android-Quantity-11.jpg" alt="sumsung某型号power_profile.xml"><br>图3-3 sumsung某型号power_profile.xml<br>数据准备：<br>先断开adb服务，然后开启adb服务。</p>
<p><strong>(1)adb kill-server</strong><br><strong>(2)adb start-server</strong><br>由于开发时做电量记录时会打开很多可能造成冲突的东西，为了保险起见，重启adb命令。<br>重置电池数据、收集数据<br><strong>(3) adb shell dumpsys batterystats  –enable full-wake-history</strong><br><strong>(4) adb shell dumpsys batterystats –reset</strong><br><strong>(5) adb shell logcat -c</strong><br>通过以上命令来打开电池数据的获取以及重置，清除干扰的数据，清除历史日志。<br>获取电量报告<br>把数据线拔掉，防止数据线造成充放电数据干扰。然后做一些测试的case，经过一段时间后，重新连接手机确认adb连上了，运行以下命令来将bugreport的信息保存到txt文件中。<br><strong>(6) adb bugreport &gt;D:/bugreport.txt</strong><br>或者用下面的命令也可以，官网上记述的内容，经实践，无法被读取…<br><strong>(7) adb shell dumpsys batterystats &gt; batterystats.txt</strong><br><strong>(8) adb shell dumpsys batterystats &gt; com.example.app(包名) &gt;batterystats.txt</strong><br>ps：在此注意一定要等到该条命令执行完(稍微会有些慢)后，再打开bugreport.txt文件，之前遇到过没有导出完，就点开，信息缺失的情况，导致无法成功生成图表。  </p>
<h3 id="B-battery-historian"><a href="#B-battery-historian" class="headerlink" title="B. battery historian"></a>B. <strong>battery historian</strong></h3><p>生成的bugreport文件有的时候异常庞大，能够达到15M+，想一想对于一个txt文本格式的文件内容长度达到了15M+是一个什么概念，如果使用文本工具打开查看将是一个噩梦。因此google针对android 5.0（api 21）以上的系统开发了一个叫做battery historian的分析工具，这个工具就是用来解析这个txt文本文件，然后使用web图形的形式展现出来，这样出来的效果更加人性化，更加可读。我们可以使用该工具对bugreport文件进行解析，更轻松的获取电量相关数据。<br>battery historian的安装可以参考以下链接：<br><a href="https://github.com/google/battery-historian" target="_blank" rel="noopener">https://github.com/google/battery-historian</a><br><a href="https://developer.android.com/studio/profile/battery-historian" target="_blank" rel="noopener">https://developer.android.com/studio/profile/battery-historian</a><br>也可以直接使用在线版本：<br><a href="https://bathist.ef.lc/" target="_blank" rel="noopener">https://bathist.ef.lc/</a></p>
<p>数据分析：</p>
<ul>
<li>选择腾讯视频app  </li>
</ul>
<p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Test/2019-02-20-Android-Quantity-12.jpg" alt="选择腾讯视频app"> </p>
<ul>
<li>Wacklocks表格中展示app持有的wacklock，持有时间及数量，通过这个表格我们可以看到我们APP是否有持有一小时以上的wack_lock。  </li>
</ul>
<p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Test/2019-02-20-Android-Quantity-13.jpg" alt="选择腾讯视频app"> </p>
<ul>
<li>Wakeup alarm info表格中展示了APP运行过程中触发的wakeup alarm名字和个数，通过该分析工具也可以统计app的闹钟唤醒次数。  </li>
</ul>
<p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Test/2019-02-20-Android-Quantity-14.jpg" alt="选择腾讯视频app"> </p>
<h3 id="C-QAPM"><a href="#C-QAPM" class="headerlink" title="C. QAPM"></a>C. <strong>QAPM</strong></h3><p>QAPM是SNG开发的致力于解放专项测试人员的工具平台，该平台带有电量监控功能，在电量个例菜单中会统计前台30分钟、后台5分钟两个场景下的wacklock持有信息。该平台上的数据可以作为我们电量测试的参考对象，具体的统计方法还需后续深入了解。</p>
<p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Test/2019-02-20-Android-Quantity-15.jpg" alt="选择腾讯视频app"> </p>
<p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Test/2019-02-20-Android-Quantity-16.jpg" alt="选择腾讯视频app"> </p>
<h3 id="D-dumpsys命令"><a href="#D-dumpsys命令" class="headerlink" title="D. dumpsys命令"></a>D. <strong>dumpsys命令</strong></h3><p>Android提供的dumpsys工具能够用于查看感兴趣的系统服务信息与状态，手机连接电脑后能够直接命令行运行adb shell dumpsys 查看电池、电量相关信息。 </p>
<p><strong>adb shell dumpsys power</strong>  </p>
<p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Test/2019-02-20-Android-Quantity-17.jpg" alt="shell"> </p>
<p>通过该条命令可以看到手机中所有的wack_lock持有信息</p>
<p><strong>adb shell dumpsys alarm</strong>   </p>
<p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Test/2019-02-20-Android-Quantity-18.jpg" alt="shell"> </p>
<p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Test/2019-02-20-Android-Quantity-19.jpg" alt="shell"> </p>
<p>此命令会提供设备上的alarm系统服务相关信息。其中Alarm Stats列出了应用设置alarm的情况，其中有系统被该应用所有alarm消耗的时间以及被闹钟唤醒的次数。可以通过获取一小时内的电量数据来分析用户在每小时的唤醒次数。<br>相关链接： <a href="https://blog.csdn.net/memoryjs/article/details/48709183" target="_blank" rel="noopener">https://blog.csdn.net/memoryjs/article/details/48709183</a><br>该方法与通过burgreport文件统计电量信息类似，都是通过Android系统中提供的工具来输出电量的消耗情况，且该种方式输出的报告也比较复杂，可读性查，可在测试过程中作为参考。</p>
<h1 id="4、国际版电量测试方法总结与实践"><a href="#4、国际版电量测试方法总结与实践" class="headerlink" title="4、国际版电量测试方法总结与实践"></a>4、国际版电量测试方法总结与实践</h1><h2 id="4-1-测试方法总结"><a href="#4-1-测试方法总结" class="headerlink" title="4.1 测试方法总结"></a>4.1 测试方法总结</h2><p>根据上一节的测试方法研究，我们打算首先用GT测试各个场景中APP电量消耗是否有异常。<br>接下来采用battery historian分析工具对手机里获取的bugreport文件进行分析，统计app中持有超过一小时的wack_lock和一小时内发生的wackup数。<br>QAPM中采集到的数据作为我们的辅助分析数据，我们可以比较两份数据，看我们通过battery historian统计的wack_lock数据是否准确。<br>我们也可以通过使用dumpsys命令，查看app电量相关信息作为测试辅助方法。</p>
<h2 id="4-2-测试方法实践"><a href="#4-2-测试方法实践" class="headerlink" title="4.2 测试方法实践"></a>4.2 测试方法实践</h2><p>腾讯视频国际版1.0.0已经发布，我们已经使用该方法对其进行了一次电量测试，具体测试过程如下：</p>
<h3 id="A-GT测试："><a href="#A-GT测试：" class="headerlink" title="A. GT测试："></a>A. <strong>GT测试</strong>：</h3><h4 id="测试场景：启动-播放-前台静置"><a href="#测试场景：启动-播放-前台静置" class="headerlink" title="测试场景：启动-播放-前台静置"></a>测试场景：启动-播放-前台静置</h4><h4 id="测试机器：nexus"><a href="#测试机器：nexus" class="headerlink" title="测试机器：nexus"></a>测试机器：nexus</h4><h4 id="测试结果分析："><a href="#测试结果分析：" class="headerlink" title="测试结果分析："></a>测试结果分析：</h4><p><strong>从以下电流趋势变化图中可以看出，播放过程和前台静置过程，电流曲线平稳，无较大波动，无明显异常。<br>从播放到退出播放前台静置，使用电流明显变小，符合预期。</strong>   </p>
<p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Test/2019-02-20-Android-Quantity-19.jpg" alt="电流"> </p>
<h3 id="B-Battery-Historian测试："><a href="#B-Battery-Historian测试：" class="headerlink" title="B. Battery Historian测试："></a>B. <strong>Battery Historian测试</strong>：</h3><h4 id="测试场景："><a href="#测试场景：" class="headerlink" title="测试场景："></a>测试场景：</h4><p>app前台静置2小时<br>app后台静置2小时<br>全屏播放2小时  </p>
<h4 id="测试型号："><a href="#测试型号：" class="headerlink" title="测试型号："></a>测试型号：</h4><p>Y7 Pro 2018 （LDN-LX2）<br>OPPO F7 （CPH1819）  </p>
<h4 id="测试结果分析：-1"><a href="#测试结果分析：-1" class="headerlink" title="测试结果分析："></a>测试结果分析：</h4><p>三个场景中，仅播放场景下会持有WindowManager这个wakelock超过1小时以上。而Android Vitals中关注的是app运行在后台时，长时间持有部分唤醒锁的情况，播放这个场景可以排除在外，因此得出结论，国际版APP持有唤醒锁情况正常。</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>机型</th>
<th>持有1小时以上的wack lock</th>
</tr>
</thead>
<tbody><tr>
<td>app前台</td>
<td>华为Y7 Pro 2018 （LDN-LX2）</td>
<td>无</td>
</tr>
<tr>
<td>app前台</td>
<td>OPPO F7 （CPH1819）</td>
<td>无</td>
</tr>
<tr>
<td>app后台</td>
<td>华为Y7 Pro 2018 （LDN-LX2）</td>
<td>无</td>
</tr>
<tr>
<td>app后台</td>
<td>OPPO F7 （CPH1819）</td>
<td>无</td>
</tr>
<tr>
<td>全屏播放</td>
<td>华为Y7 Pro 2018 （LDN-LX2）</td>
<td>WindowManager</td>
</tr>
<tr>
<td>全屏播放</td>
<td>OPPO F7 （CPH1819）</td>
<td>WindowManager</td>
</tr>
</tbody></table>
<p><strong>测试过程中没有统计到alarm数据，说明国际版APP暂时没有使用到AlarmManager定时任务。</strong></p>
<h3 id="C-测试结论："><a href="#C-测试结论：" class="headerlink" title="C. 测试结论："></a>C. 测试结论：</h3><h4 id="GT电流测试显示国际版APP各应用场景电量使用情况正常。"><a href="#GT电流测试显示国际版APP各应用场景电量使用情况正常。" class="headerlink" title="GT电流测试显示国际版APP各应用场景电量使用情况正常。"></a>GT电流测试显示国际版APP各应用场景电量使用情况正常。</h4><table>
<thead>
<tr>
<th>场景</th>
<th>启动APP</th>
<th>播放</th>
<th>退出播放，前台静置</th>
</tr>
</thead>
<tbody><tr>
<td>结论</td>
<td>启动过程需加载图片等资源，电流较大，正常</td>
<td>播放过程电流平稳无异常</td>
<td>退出播放电流变小，静置过程平稳无异常</td>
</tr>
</tbody></table>
<h4 id="Battery-Historian分析电量数据得出，前台静置、后台静置、播放三个场景中仅播放场景会持有wack-lock1小时以上，不属于Android-Vitals统计范畴，不会影响到国际版APP在Google-Play商店的排名。"><a href="#Battery-Historian分析电量数据得出，前台静置、后台静置、播放三个场景中仅播放场景会持有wack-lock1小时以上，不属于Android-Vitals统计范畴，不会影响到国际版APP在Google-Play商店的排名。" class="headerlink" title="Battery Historian分析电量数据得出，前台静置、后台静置、播放三个场景中仅播放场景会持有wack lock1小时以上，不属于Android Vitals统计范畴，不会影响到国际版APP在Google Play商店的排名。"></a>Battery Historian分析电量数据得出，前台静置、后台静置、播放三个场景中仅播放场景会持有wack lock1小时以上，不属于Android Vitals统计范畴，不会影响到国际版APP在Google Play商店的排名。</h4><table>
<thead>
<tr>
<th>场景</th>
<th>机型</th>
<th>stuck wake locks</th>
<th>excessive wakeups</th>
<th>结论</th>
</tr>
</thead>
<tbody><tr>
<td>前台静置</td>
<td>华为Y7 Pro 2018 （LDN-LX2）</td>
<td>无唤醒锁定卡住</td>
<td>无过渡唤醒</td>
<td>正常</td>
</tr>
<tr>
<td>前台静置</td>
<td>OPPO F7 （CPH1819）</td>
<td>无唤醒锁定卡住</td>
<td>无过渡唤醒</td>
<td>正常</td>
</tr>
<tr>
<td>后台静置</td>
<td>华为Y7 Pro 2018 （LDN-LX2）</td>
<td>无唤醒锁定卡住</td>
<td>无过渡唤醒</td>
<td>正常</td>
</tr>
<tr>
<td>后台静置</td>
<td>OPPO F7 （CPH1819）</td>
<td>无唤醒锁定卡住</td>
<td>无过渡唤醒</td>
<td>正常</td>
</tr>
<tr>
<td>播放</td>
<td>华为Y7 Pro 2018 （LDN-LX2）</td>
<td>持有唤醒锁1小时以上</td>
<td>无过渡唤醒</td>
<td>正常</td>
</tr>
<tr>
<td>播放</td>
<td>OPPO F7 （CPH1819）</td>
<td>持有唤醒锁1小时以上</td>
<td>无过渡唤醒</td>
<td>正常</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 提交规范</title>
    <url>/2018/07/15/2018-07-15-GIT-Rule/</url>
    <content><![CDATA[<h1 id="1-具体规则"><a href="#1-具体规则" class="headerlink" title="1. 具体规则"></a>1. 具体规则</h1><p>先来看看公式：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;type&gt;(&lt;id&gt;&lt;scope&gt;): &lt;subject&gt;  </span><br><span class="line">&#x2F;&#x2F; 空一行  </span><br><span class="line">&lt;body&gt;  </span><br><span class="line">&#x2F;&#x2F; 空一行  </span><br><span class="line">&lt;footer&gt;</span><br></pre></td></tr></table></figure>
<h2 id="1-1-type：用于说明-commit-的类别，只允许使用下面7个标识。"><a href="#1-1-type：用于说明-commit-的类别，只允许使用下面7个标识。" class="headerlink" title="1.1 type：用于说明 commit 的类别，只允许使用下面7个标识。"></a>1.1 <strong>type</strong>：用于说明 commit 的类别，只允许使用下面7个标识。</h2><ul>
<li>FEAT：新功能【feature】  </li>
<li>FIX：修补bug   </li>
<li>DOC：文档【documentation】  </li>
<li>STYLE： 格式【不影响代码运行的变动】  </li>
<li>REFACTOR：重构【即不是新增功能，也不是修改bug的代码变动】  </li>
<li>TEST：增加测试  </li>
<li>CHORE：构建过程或辅助工具的变动   </li>
</ul>
<h2 id="1-2-id：对应新功能或者bug对应的id编号。"><a href="#1-2-id：对应新功能或者bug对应的id编号。" class="headerlink" title="1.2 id：对应新功能或者bug对应的id编号。"></a>1.2 <strong>id</strong>：对应新功能或者bug对应的id编号。</h2><h2 id="1-3-scope：用于说明-commit-影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。"><a href="#1-3-scope：用于说明-commit-影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。" class="headerlink" title="1.3 scope：用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。"></a>1.3 <strong>scope</strong>：用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。</h2><p><strong>subject</strong>：是 commit 目的的简短描述，不超过50个字符。</p>
<ol>
<li>以动词开头，使用第一人称现在时，比如change，而不是changed或changes；  </li>
<li>第一个字母小写；    </li>
<li>结尾不加句号(.)。  </li>
</ol>
<h2 id="1-4-body-部分是对本次-commit-的详细描述，可以分成多行。"><a href="#1-4-body-部分是对本次-commit-的详细描述，可以分成多行。" class="headerlink" title="1.4 body:部分是对本次 commit 的详细描述，可以分成多行。"></a>1.4 <strong>body</strong>:部分是对本次 commit 的详细描述，可以分成多行。</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">More detailed explanatory text, <span class="keyword">if</span> necessary.  Wrap it to </span><br><span class="line">about 72 characters or so. </span><br><span class="line">Further paragraphs come after blank lines.</span><br><span class="line">- Bullet points are okay, too</span><br><span class="line">- Use a hanging indent</span><br></pre></td></tr></table></figure>
<p><strong>有两个注意点:</strong><br>  (1)使用第一人称现在时，比如使用change而不是changed或changes。<br>  (2)应该说明代码变动的动机，以及与以前行为的对比。   </p>
<h2 id="1-5-Footer-只用于两种情况"><a href="#1-5-Footer-只用于两种情况" class="headerlink" title="1.5 Footer:只用于两种情况"></a>1.5 <strong>Footer</strong>:只用于两种情况</h2><h3 id="1-5-1-不兼容变动"><a href="#1-5-1-不兼容变动" class="headerlink" title="1.5.1 不兼容变动"></a>1.5.1 <strong>不兼容变动</strong></h3><p>如果当前代码与上一个版本不兼容，则 Footer 部分以BREAKING CHANGE开头，后面是对变动的描述、以及变动理由和迁移方法。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">BREAKING CHANGE: isolate scope bindings definition has changed.</span><br><span class="line">    To migrate the code follow the example below:</span><br><span class="line">    Before:</span><br><span class="line">    scope: &#123;</span><br><span class="line">      myAttr: <span class="string">'attribute'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    After:</span><br><span class="line">    scope: &#123;</span><br><span class="line">      myAttr: <span class="string">'@'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    The removed `inject` wasn<span class="string">'t generaly useful for directives so there should be no code using it.</span></span><br></pre></td></tr></table></figure>
<h3 id="1-5-2-关闭-Issue"><a href="#1-5-2-关闭-Issue" class="headerlink" title="1.5.2 关闭 Issue"></a>1.5.2 <strong>关闭 Issue</strong></h3><p>如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue 。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Closes <span class="comment">#234</span></span><br></pre></td></tr></table></figure>
<p>也可以一次关闭多个 issue 。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Closes <span class="comment">#123, #245, #992</span></span><br></pre></td></tr></table></figure>
<h2 id="1-6-Revert-还有一种特殊情况，如果当前-commit-用于撤销以前的-commit，则必须以revert-开头，后面跟着被撤销-Commit-的-Header。"><a href="#1-6-Revert-还有一种特殊情况，如果当前-commit-用于撤销以前的-commit，则必须以revert-开头，后面跟着被撤销-Commit-的-Header。" class="headerlink" title="1.6 Revert:还有一种特殊情况，如果当前 commit 用于撤销以前的 commit，则必须以revert:开头，后面跟着被撤销 Commit 的 Header。"></a>1.6 <strong>Revert</strong>:还有一种特殊情况，如果当前 commit 用于撤销以前的 commit，则必须以revert:开头，后面跟着被撤销 Commit 的 Header。</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">revert: feat(pencil): add <span class="string">'graphiteWidth'</span> option   </span><br><span class="line">This reverts commit 667ecc1654a317a13331b17617d973392f415f02.</span><br></pre></td></tr></table></figure>
<p>Body部分的格式是固定的，必须写成This reverts commit &lt;hash&gt;.，其中的hash是被撤销 commit 的 SHA 标识符。<br>如果当前 commit 与被撤销的commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的Reverts小标题下面。   </p>
<h1 id="2-异常处理"><a href="#2-异常处理" class="headerlink" title="2. 异常处理"></a>2. 异常处理</h1><p>我们先来看看这个异常提醒： </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">INVALID COMMIT MSG: does not match <span class="string">"&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;"</span> !</span><br><span class="line">jartto:fix bug</span><br></pre></td></tr></table></figure>

<p>这里之所以报出这个警告，是因为我的提交出现了两个问题：<br>其一，使用了规范外的关键字；<br>其二，很细节的问题，jartto：后少了空格。<br>这时候我才回忆起来，当时提交一直失败，情急之下直接强制提交，所以以后的提交都会抱出这个异常。大致意思就是：<br>你的之前的 Commit 不合格～你的之前的 Commit 不合格～你的之前的 Commit 不合格<br>这时候就很烦了，我们只能去将之前的错误修正，那么如何操作呢？  </p>
<h1 id="3-如何修改之前的-Commit-信息？"><a href="#3-如何修改之前的-Commit-信息？" class="headerlink" title="3. 如何修改之前的 Commit 信息？"></a>3. 如何修改之前的 Commit 信息？</h1><p>其实并不复杂，我们只需要这样做：</p>
<ol>
<li>将当前分支无关的工作状态进行暂存    <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure></li>
<li>将 HEAD 移动到需要修改的 commit 上<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase 9633cf0919^ --interactive</span><br></pre></td></tr></table></figure></li>
<li>找到需要修改的 Commit，将首行的 pick 改成 edit</li>
<li>开始着手解决你的 bug  </li>
<li>git add 将改动文件添加到暂存  </li>
<li>git commit –amend 追加改动到提交  </li>
<li>git rebase –continue 移动 HEAD 回最新的 commit    </li>
<li>恢复之前的工作状态  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="4-项目中使用"><a href="#4-项目中使用" class="headerlink" title="4. 项目中使用"></a>4. 项目中使用</h1><p>这时候问题又来了，为什么我提交的时候会有警告，这个又是如何做到的呢？<br>这时候，我们需要一款 Node 插件 validate-commit-msg 来检查项目中 Commit message 是否规范。</p>
<h2 id="4-1-首先，安装插件："><a href="#4-1-首先，安装插件：" class="headerlink" title="4.1 首先，安装插件："></a>4.1 首先，安装插件：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save-dev validate-commit-msg</span><br></pre></td></tr></table></figure>

<h2 id="4-2-使用方式一，建立-vcmrc-文件："><a href="#4-2-使用方式一，建立-vcmrc-文件：" class="headerlink" title="4.2 使用方式一，建立 .vcmrc 文件："></a>4.2 使用方式一，建立 .vcmrc 文件：</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"types"</span>: [<span class="string">"feat"</span>, <span class="string">"fix"</span>, <span class="string">"docs"</span>, <span class="string">"style"</span>, <span class="string">"refactor"</span>, <span class="string">"perf"</span>, <span class="string">"test"</span>, <span class="string">"build"</span>, <span class="string">"ci"</span>, <span class="string">"chore"</span>, <span class="string">"revert"</span>],</span><br><span class="line">  <span class="attr">"scope"</span>: &#123;</span><br><span class="line">  <span class="attr">"required"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"allowed"</span>: [<span class="string">"*"</span>],</span><br><span class="line">  <span class="attr">"validate"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"multiple"</span>: <span class="literal">false</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">"warnOnFail"</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="attr">"maxSubjectLength"</span>: <span class="number">100</span>,</span><br><span class="line"><span class="attr">"subjectPattern"</span>: <span class="string">".+"</span>,</span><br><span class="line"><span class="attr">"subjectPatternErrorMsg"</span>: <span class="string">"subject does not match subject pattern!"</span>,</span><br><span class="line"><span class="attr">"helpMessage"</span>: <span class="string">""</span>,</span><br><span class="line"><span class="attr">"autoFix"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-3-使用方式二：写入-package-json"><a href="#4-3-使用方式二：写入-package-json" class="headerlink" title="4.3 使用方式二：写入 package.json"></a>4.3 使用方式二：写入 package.json</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"config"</span>: &#123;</span><br><span class="line">	<span class="attr">"validate-commit-msg"</span>: &#123;</span><br><span class="line">	  <span class="comment">/* your config here */</span></span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-4-可是我们如果想自动使用-ghooks-3-钩子函数呢？"><a href="#4-4-可是我们如果想自动使用-ghooks-3-钩子函数呢？" class="headerlink" title="4.4 可是我们如果想自动使用 ghooks[3] 钩子函数呢？"></a>4.4 可是我们如果想自动使用 ghooks[3] 钩子函数呢？</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  …</span><br><span class="line">  "config": &#123;</span><br><span class="line">	"ghooks": &#123;</span><br><span class="line">	  "pre-commit": "gulp lint",</span><br><span class="line">	  "commit-msg": "validate-commit-msg",</span><br><span class="line">	  "pre-push": "make test",</span><br><span class="line">	  "post-merge": "npm install",</span><br><span class="line">	  "post-rewrite": "npm install",</span><br><span class="line">	  …</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 ghooks 中我们可以做很多事情，当然不只是 validate-commit-msg 哦。更多细节请参考：validate-commit-msg[4]。  </p>
<h1 id="5-Commit-规范的作用"><a href="#5-Commit-规范的作用" class="headerlink" title="5. Commit 规范的作用"></a>5. Commit 规范的作用</h1><ol>
<li>提供更多的信息，方便排查与回退；</li>
<li>过滤关键字，迅速定位；</li>
<li>方便生成文档。</li>
</ol>
<h1 id="6-生成-Change-log"><a href="#6-生成-Change-log" class="headerlink" title="6. 生成 Change log"></a>6. 生成 Change log</h1><p>正如上文提到的生成文档，如果我们的提交都按照规范的话，那就很简单了。生成的文档包括以下三个部分：  </p>
<ul>
<li><strong>New features</strong>  </li>
<li><strong>Bug fixes</strong>  </li>
<li><strong>Breaking changes</strong>  </li>
</ul>
<p>每个部分都会罗列相关的 commit ，并且有指向这些 commit 的链接。当然，生成的文档允许手动修改，所以发布前，你还可以添加其他内容。<br>这里需要使用工具 Conventional Changelog[5] 生成 Change log ： </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g conventional-changelog</span><br><span class="line"><span class="built_in">cd</span> jartto-domo</span><br><span class="line">conventional-changelog -p angular -i CHANGELOG.md -w</span><br></pre></td></tr></table></figure>

<p>为了方便使用，可以将其写入 package.json 的 scripts 字段。  </p>
<ol>
<li>过滤关键字，迅速定位；</li>
<li>方便生成文档。</li>
</ol>
<h1 id="7-生成-Change-log"><a href="#7-生成-Change-log" class="headerlink" title="7. 生成 Change log"></a>7. 生成 Change log</h1><p>正如上文提到的生成文档，如果我们的提交都按照规范的话，那就很简单了。生成的文档包括以下三个部分：  </p>
<ul>
<li><strong>New features</strong>  </li>
<li><strong>Bug fixes</strong>  </li>
<li><strong>Breaking changes</strong>  </li>
</ul>
<p>每个部分都会罗列相关的 commit ，并且有指向这些 commit 的链接。当然，生成的文档允许手动修改，所以发布前，你还可以添加其他内容。<br>这里需要使用工具 Conventional Changelog[5] 生成 Change log ：  </p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">	<span class="attr">"changelog"</span>: <span class="string">"conventional-changelog -p angular -i CHANGELOG.md -w -r 0"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，使用起来就很简单了：  </p>
<pre><code class="bash">npm run changelog</code></pre>
<p><strong>参考文献:</strong>  </p>
<ol>
<li><a href="http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html</a>  </li>
<li><a href="https://www.aliyun.com/jiaocheng/125261.html" target="_blank" rel="noopener">https://www.aliyun.com/jiaocheng/125261.html</a>  </li>
<li><a href="https://www.npmjs.com/package/ghooks" target="_blank" rel="noopener">https://www.npmjs.com/package/ghooks</a>  </li>
<li><a href="https://github.com/conventional-changelog-archived-repos/validate-commit-msg" target="_blank" rel="noopener">https://github.com/conventional-changelog-archived-repos/validate-commit-msg</a>   </li>
<li><a href="https://github.com/conventional-changelog/conventional-changelog" target="_blank" rel="noopener">https://github.com/conventional-changelog/conventional-changelog</a>   </li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>用例设计之等价类</title>
    <url>/2020/01/06/2020-01-06-Testcase-Equivalence-Partitioning/</url>
    <content><![CDATA[<h1 id="1-等价类概念"><a href="#1-等价类概念" class="headerlink" title="1. 等价类概念"></a>1. 等价类概念</h1><p>等价类划分是一种典型的黑盒测试方法，其原理是把程序的输入域划分成若干部分（子集），然后从每一个子集中选取少数具有代表性的数据作为测试用例。<br>等价类是指某个输入域的子集合。在该子集合中，各个输入数据对于揭露程序中的错误都是等效的。并合理的假设，测试某等价类的代表值就等于对这一类其它值的测试。<br>等价类划分有两种不同的情况：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;b&gt;有效等价类&lt;&#x2F;b&gt;：指对于程序的规格说明来说是合理的、有意义的输入数据构成的集合。</span><br><span class="line">&lt;b&gt;无效等价类&lt;&#x2F;b&gt;：指对程序的规格说明是不合理的或无意义的输入数据所构成的集合。对于具体的问题，无效等价类至少应有一个，也可能有多个。</span><br><span class="line">在设计测试用例时，要同时考虑有效等价类和无效等价类，以此验证软件在正常操作和异常操作时是否都能正常运行。</span><br></pre></td></tr></table></figure>
<h1 id="2-等价类原则"><a href="#2-等价类原则" class="headerlink" title="2.等价类原则"></a>2.等价类原则</h1><p>确定等价类的6条原则：</p>
<h2 id="１、-在输入条件规定了取值范围或取值的个数的情况下，可以确立一个有效等价类和两个无效等价类。"><a href="#１、-在输入条件规定了取值范围或取值的个数的情况下，可以确立一个有效等价类和两个无效等价类。" class="headerlink" title="１、 在输入条件规定了取值范围或取值的个数的情况下，可以确立一个有效等价类和两个无效等价类。"></a>１、 在输入条件规定了取值范围或取值的个数的情况下，可以确立一个有效等价类和两个无效等价类。</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例1：输入值是学生成绩，输入形式为文本框，要求的输入范围是0～100</span><br><span class="line">有效等价类：0&lt;&#x3D;输入成绩&lt;&#x3D;100；</span><br><span class="line">无效等价类1：输入成绩&lt;0；</span><br><span class="line">无效等价类2：输入成绩&gt;100</span><br></pre></td></tr></table></figure>
<h2 id="２、-在输入条件规定了输入值的集合或者规定了“必须如何”的条件的情况下，可以确立一个有效等价类和一个无效等价类。"><a href="#２、-在输入条件规定了输入值的集合或者规定了“必须如何”的条件的情况下，可以确立一个有效等价类和一个无效等价类。" class="headerlink" title="２、 在输入条件规定了输入值的集合或者规定了“必须如何”的条件的情况下，可以确立一个有效等价类和一个无效等价类。"></a>２、 在输入条件规定了输入值的集合或者规定了“必须如何”的条件的情况下，可以确立一个有效等价类和一个无效等价类。</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例2：输入值是人员性别，输入形式为文本框，要求输入的内容必须在集合&#123;男,女&#125;中</span><br><span class="line">有效等价类：性别＝’男’ 或者 ‘女’</span><br><span class="line">无效等价类：性别＝’人妖’</span><br></pre></td></tr></table></figure>
<h2 id="３、在输入条件是一个布尔量的情况下，可以确立一个有效等价类和一个无效等价类。"><a href="#３、在输入条件是一个布尔量的情况下，可以确立一个有效等价类和一个无效等价类。" class="headerlink" title="３、在输入条件是一个布尔量的情况下，可以确立一个有效等价类和一个无效等价类。"></a>３、在输入条件是一个布尔量的情况下，可以确立一个有效等价类和一个无效等价类。</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例3：输入值是状态标识位“是否完成”，输入形式为单选下拉框，选择范围为&#123;是,否&#125;</span><br><span class="line">有效等价类：选项＝’是’ 或者 ‘否’</span><br><span class="line">无效等价类：未进行选择操作</span><br></pre></td></tr></table></figure>
<h2 id="４、在规定了输入数据的一组值（假设N个），并且程序要对每一个输入值进行处理的情况下，可以确立N个有效等价类和一个无效等价类。"><a href="#４、在规定了输入数据的一组值（假设N个），并且程序要对每一个输入值进行处理的情况下，可以确立N个有效等价类和一个无效等价类。" class="headerlink" title="４、在规定了输入数据的一组值（假设Ｎ个），并且程序要对每一个输入值进行处理的情况下，可以确立Ｎ个有效等价类和一个无效等价类。"></a>４、在规定了输入数据的一组值（假设Ｎ个），并且程序要对每一个输入值进行处理的情况下，可以确立Ｎ个有效等价类和一个无效等价类。</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例4：输入值是人员性别，输入形式为文本框，要求输入的内容必须在集合&#123;男,女&#125;中；不同的性别选择将跳转至不同的处理页面</span><br><span class="line">有效等价类1：性别＝’男’</span><br><span class="line">有效等价类2：性别＝’女’</span><br><span class="line">无效等价类：性别＝’人妖’</span><br></pre></td></tr></table></figure>
<h2 id="５、在规定了输入数据必须遵守的规则的情况下，可以确立一个有效等价类（符合条件）和若干无效等价类（从各个角度违反规则）。"><a href="#５、在规定了输入数据必须遵守的规则的情况下，可以确立一个有效等价类（符合条件）和若干无效等价类（从各个角度违反规则）。" class="headerlink" title="５、在规定了输入数据必须遵守的规则的情况下，可以确立一个有效等价类（符合条件）和若干无效等价类（从各个角度违反规则）。"></a>５、在规定了输入数据必须遵守的规则的情况下，可以确立一个有效等价类（符合条件）和若干无效等价类（从各个角度违反规则）。</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例5：输入值是人员性别，输入形式为单选下拉框，要求输入的内容必须在集合&#123;男,女&#125;中；</span><br><span class="line">有效等价类：性别＝’男’ 或者 ‘女’</span><br><span class="line">无效等价类1：未选择人员性别</span><br><span class="line">无效等价类2：在浏览器开发工具中将人员性别的属性值更改为’人妖’</span><br></pre></td></tr></table></figure>
<h2 id="６、在确知已划分的等价类中各元素在程序处理中的方式不同的情况下，则应再将该等价类划分为更小的等价类。"><a href="#６、在确知已划分的等价类中各元素在程序处理中的方式不同的情况下，则应再将该等价类划分为更小的等价类。" class="headerlink" title="６、在确知已划分的等价类中各元素在程序处理中的方式不同的情况下，则应再将该等价类划分为更小的等价类。"></a>６、在确知已划分的等价类中各元素在程序处理中的方式不同的情况下，则应再将该等价类划分为更小的等价类。</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例6：在例2（输入值是人员性别，输入形式为文本框，要求输入的内容必须在集合&#123;男,女&#125;中）的基础上，不同的性别选择将跳转至不同的处理页面</span><br><span class="line">有效等价类：性别＝’男’ 或者 ‘女’</span><br><span class="line">有效等价类细分1：性别＝’男’</span><br><span class="line">有效等价类细分2：性别＝’女’</span><br><span class="line">无效等价类：性别＝’人妖’</span><br></pre></td></tr></table></figure>
<h1 id="3-确定测试用例"><a href="#3-确定测试用例" class="headerlink" title="3.确定测试用例"></a>3.确定测试用例</h1><p>根据已列出的等价类表，按照如下步骤确定测试用例：</p>
<ul>
<li>1）  为每个等价类规定一个唯一的编号</li>
<li>2）  设计一个新的测试用例，使其尽可能多地覆盖尚未覆盖的有效等价类。重复这一步，最后使得所有有效等价类均被测试用例所覆盖。</li>
<li>3） 设计一个新的测试用例，使其只覆盖一个无效等价类。重复这一步，使所有无效等价类均被覆盖。</li>
</ul>
<h1 id="4-示例"><a href="#4-示例" class="headerlink" title="4. 示例"></a>4. 示例</h1><h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h2><p>某程序具有如下功能：输入3个正数a、b、c，分别作为三边的边长构成三角形，输出这3个数所构成的三角形类型。<br>用等价类划分方法为该程序进行测试用例设计。</p>
<h3 id="划分等价类"><a href="#划分等价类" class="headerlink" title="划分等价类"></a>划分等价类</h3><p>分析思路：</p>
<ul>
<li>步骤一、要求输入3个数，且3个数都为正数；参照规则5，划分为一个有效等价类和三个无效等价类。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有效等价类（1）：a&gt;0; b&gt;0; c&gt;0;</span><br><span class="line">无效等价类（2）：a&lt;&#x3D;0</span><br><span class="line">无效等价类（3）：b&lt;&#x3D;0</span><br><span class="line">无效等价类（4）：c&lt;&#x3D;0</span><br></pre></td></tr></table></figure></li>
<li>步骤二、在有效等价类（1）的基础上，参照规则6，对该等价类进行细分；考察3个数能否构成三角形，参照规则5，划分为一个有效等价类和三个无效等价类。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有效等价类（5）：a&gt;0; b&gt;0; c&gt;0; a+b&gt;c; a+c&gt;b; b+c&gt;a</span><br><span class="line">无效等价类（6）：a&gt;0; b&gt;0; c&gt;0; a+b&lt;&#x3D;c</span><br><span class="line">无效等价类（7）：a&gt;0; b&gt;0; c&gt;0; b+c&lt;&#x3D;a</span><br><span class="line">无效等价类（8）：a&gt;0; b&gt;0; c&gt;0; a+c&lt;&#x3D;b</span><br></pre></td></tr></table></figure></li>
<li>步骤三、在有效等价类（5）的基础上，参照规则6，对该等价类进行细分；考察3个数能否构成等边三角形，参照规则2，划分为一个有效等价类和一个无效等价类。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有效等价类（9）：a&gt;0; b&gt;0; c&gt;0; a+b&gt;c; a+c&gt;b; b+c&gt;a; a&#x3D;b&#x3D;c</span><br><span class="line">无效等价类（10）：a&gt;0; b&gt;0; c&gt;0; a+b&gt;c; a+c&gt;b; b+c&gt;a; a!&#x3D;b 或 b!&#x3D;c 或 c!&#x3D;a</span><br></pre></td></tr></table></figure></li>
<li>步骤四、在无效等价类（10）的基础上，参照规则6，对该等价类进行细分；考察3个数能否构成等腰三角形，参照规则4，划分为三个有效等价类和一个无效等价类。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有效等价类（11）：a&gt;0; b&gt;0; c&gt;0; a+b&gt;c; a+c&gt;b; b+c&gt;a; a&#x3D;b!&#x3D;c</span><br><span class="line">有效等价类（12）：a&gt;0; b&gt;0; c&gt;0; a+b&gt;c; a+c&gt;b; b+c&gt;a; b&#x3D;c!&#x3D;a</span><br><span class="line">有效等价类（13）：a&gt;0; b&gt;0; c&gt;0; a+b&gt;c; a+c&gt;b; b+c&gt;a; c&#x3D;a!&#x3D;b</span><br><span class="line">无效等价类（14）：a&gt;0; b&gt;0; c&gt;0; a+b&gt;c; a+c&gt;b; b+c&gt;a; a!&#x3D;b; a!&#x3D;c; b!&#x3D;c</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="设计测试用例"><a href="#设计测试用例" class="headerlink" title="设计测试用例"></a>设计测试用例</h3><table>
<thead>
<tr>
<th>序号</th>
<th>[a,b,c]</th>
<th>覆盖等价类</th>
<th>预期输出结果</th>
</tr>
</thead>
<tbody><tr>
<td>–</td>
<td>–</td>
<td><strong>覆盖有效等价类</strong></td>
<td>–</td>
</tr>
<tr>
<td>1</td>
<td>[6,6,6]</td>
<td>（1）（5）（9）</td>
<td>等边三角形</td>
</tr>
<tr>
<td>2</td>
<td>[3,3,5]</td>
<td>（1）（5）（10）（11）</td>
<td>等腰三角形</td>
</tr>
<tr>
<td>3</td>
<td>[3,4,4]</td>
<td>（1）（5）（10）（12）</td>
<td>等腰三角形</td>
</tr>
<tr>
<td>4</td>
<td>[4,5,4]</td>
<td>（1）（5）（10）（13）</td>
<td>等腰三角形</td>
</tr>
<tr>
<td>–</td>
<td>–</td>
<td><strong>覆盖无效等价类</strong></td>
<td>–</td>
</tr>
<tr>
<td>5</td>
<td>[3,4,5]</td>
<td>（1）（5）（14）</td>
<td>一般三角形</td>
</tr>
<tr>
<td>6</td>
<td>[-1,3,2]</td>
<td>（2）</td>
<td>不能构成三角形</td>
</tr>
<tr>
<td>7</td>
<td>[3,-1,2]</td>
<td>（3）</td>
<td>不能构成三角形</td>
</tr>
<tr>
<td>8</td>
<td>[3,2,-1]</td>
<td>（4）</td>
<td>不能构成三角形</td>
</tr>
<tr>
<td>9</td>
<td>[1,2,3</td>
<td>（1）（6）</td>
<td>不能构成三角形</td>
</tr>
<tr>
<td>10</td>
<td>[3,1,2]</td>
<td>（1）（7）</td>
<td>不能构成三角形</td>
</tr>
<tr>
<td>11</td>
<td>[1,3,2]</td>
<td>（1）（8）</td>
<td>不能构成三角形</td>
</tr>
</tbody></table>
<h2 id="Example2"><a href="#Example2" class="headerlink" title="Example2"></a>Example2</h2><p>某程序具有如下功能：文本框要求输入日期信息，日期限定在1990年1月~2049年12月，并规定日期由6位数字字符组成，前4位表示年，后2位表示月；程序需对输入的日期有效性进行校验。<br>用等价类划分方法为该程序的“日期检查功能”设计测试用例。</p>
<h3 id="划分等价类-1"><a href="#划分等价类-1" class="headerlink" title="划分等价类"></a>划分等价类</h3><ul>
<li>步骤一、要求输入6个数字字符yyyynn；参照规则5，划分为一个有效等价类和三个无效等价类。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有效等价类（1）：输入6个数字字符</span><br><span class="line">无效等价类（2）：输入6个字符，存在非数字的情况</span><br><span class="line">无效等价类（3）：输入少于6个字符</span><br><span class="line">无效等价类（4）：输入多于6个字符</span><br></pre></td></tr></table></figure></li>
<li>步骤二、在有效等价类（1）的基础上，参照规则6，对该等价类进行细分；考察6个数是否满足日期格式要求，1990&lt;=yyyy&lt;=2049，01&lt;=nn&lt;=12，参照规则，划分为一个有效等价类和四个无效等价类。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有效等价类（5）：日期格式满足要求，1990&lt;&#x3D;yyyy&lt;&#x3D;2049，01&lt;&#x3D;nn&lt;&#x3D;12</span><br><span class="line">无效等价类（6）：yyyy不满足要求，yyyy&lt;1990</span><br><span class="line">无效等价类（7）：yyyy不满足要求，yyyy&gt;2049</span><br><span class="line">无效等价类（8）：nn不满足要求，nn&lt;01</span><br><span class="line">无效等价类（9）：nn不满足要求，nn&gt;12</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="设计测试用例-1"><a href="#设计测试用例-1" class="headerlink" title="设计测试用例"></a>设计测试用例</h3><table>
<thead>
<tr>
<th>序号</th>
<th>yyyynn</th>
<th>覆盖等价类</th>
<th>预期输出结果</th>
</tr>
</thead>
<tbody><tr>
<td>–</td>
<td>–</td>
<td><strong>覆盖有效等价类</strong></td>
<td>–</td>
</tr>
<tr>
<td>1</td>
<td>199307</td>
<td>（1）（5）</td>
<td>日期格式有效</td>
</tr>
<tr>
<td>–</td>
<td>–</td>
<td><strong>覆盖无效等价类</strong></td>
<td>–</td>
</tr>
<tr>
<td>2</td>
<td>19June</td>
<td>（2）</td>
<td>日期格式无效</td>
</tr>
<tr>
<td>3</td>
<td>19Jun</td>
<td>（3）</td>
<td>日期格式无效</td>
</tr>
<tr>
<td>4</td>
<td>19June2</td>
<td>（4）</td>
<td>日期格式无效</td>
</tr>
<tr>
<td>5</td>
<td>198805</td>
<td>（6）</td>
<td>日期格式无效</td>
</tr>
<tr>
<td>6</td>
<td>205005</td>
<td>（7）</td>
<td>日期格式无效</td>
</tr>
<tr>
<td>7</td>
<td>198800</td>
<td>（8）</td>
<td>日期格式无效</td>
</tr>
<tr>
<td>8</td>
<td>199513</td>
<td>（9）</td>
<td>日期格式无效</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>用例设计</tag>
      </tags>
  </entry>
  <entry>
    <title>《我的团长我的团》观后感</title>
    <url>/2019/10/18/2019-10-18-My-Chief-and-My-Regiment/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">桃花飞绿水 一庭芳草围新绿 有情芍药含春泪</span><br><span class="line"></span><br><span class="line">野竹上表霄 十亩藤花落古香 无力蔷薇卧晓枝</span><br><span class="line"></span><br><span class="line">我愿暂求造化力 减却牡丹妖艳色</span><br><span class="line"></span><br><span class="line">花非花 梦非梦 花如梦 梦似花 梦里有花 花开如梦</span><br><span class="line"></span><br><span class="line">心非心 镜非镜 心如镜 镜似心 镜中有心 心如明镜</span><br></pre></td></tr></table></figure>

<p>昨天晚上终于在凌晨1点的样子，看完了《我的团长我的团》这部连续剧；现在已经没有耐心再一字一句的看完整部剧了，都是在快进与倍速中看完了这部作品；我想这样看完这部作品是不应该的。</p>
<p>这边作品是值得用心看一遍的，里面许多值得用心体会的对白。同时在看待战争看待为什么而战时也比较客观合理，不像现在到处充斥着的神剧一样，神一样的逻辑，真的有那么多悍不畏死的人么？同时也明白底层士兵的命运是何等的低贱，就因为上面一些人无休止的争论就可以充当炮灰；但是现实中又何尝不是呢！所以”岂曰无衣，与子同袍”，才是他们何为战的原因。</p>
<p>剧中经常有些对话莫名其妙，大部分是集中在团长和孟烦了之间，应该全是在他们之间，经常让我找不着头脑；不知道是在通过言语各种试探还是要干什么，觉得各种绕；仿佛每句台词也富含哲理；但是剧中的各种方言是很好听的，不知道现在为什么要统一，少了这么多多样性就一定好么？</p>
<p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images//Article/2019-10-18-My-Chief-and-My-Regiment-1.png" alt="我的团长我的团"></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>《自卑与超越》读后感</title>
    <url>/2020/07/27/2020-07-27-Inferiority-and-Transcendence/</url>
    <content><![CDATA[<p>去年在朋友圈看见有同学发了一则买书优惠的信息，于是就头脑发热的买了几本书，截止目前大概看完了其中的1/5；目前真正看完的一本书《自卑与超越》，作者阿尔弗雷德·阿德勒。</p>
<p>看完这本书也没有陆续有些记录，可是等看完了再来记录，偶然发现什么也记不起了；大概依稀只记得，这本书主要讲了任何后期的发生的事情，都因为在年幼的时候因为各种事情产生的影响。只要你能根据后期的表征，判断出最开始是什么影响了；你就能解决他或者她心理上的问题，助他或者她摆脱魔障。同时，本书还大概的讲了一个人成长过程中各个阶段的学校，家庭，职场对其能产生怎样的作用，又应该怎样的引导。</p>
<p>这本书还大概剖析了梦的由来以及原有，类似周工解梦了。不过最让我好奇的是，之前我总是做关于读书考试的梦；可是周工解梦里面没有这梦的一解，在这里我总算找到了一个答案。它说这是因为对即将进行的事情，没有做好充分的准备从而引发的心理反应。这个解释还比较令人信服，起码至少是站在心理学的高度去剖析的。</p>
<p>通过这本书，了解到人这一生都是围绕三个问题展开的；1，一个人的劳作；2，与他人合作的关系；3，两性关系；大概每个人都在这三个问题中纠葛。怪不得书是人类进步的阶梯，通过前人总结的各种思想，后面的人在遇到问题时，总能从中找到解决办法；找不到解决办法也能从中获取思路。所以应该多看书，去长长见识；也许顺便能解决自己困恼已久的问题。</p>
<p>通过这本书，也有助于锻炼自己阅读的速度；之前都学习的是课本，每句都是仔细研读；阅读的速度，其实根本就没有速度可言。现在偶然发现，其实读书不光一目一行，还能一目十行，并且能知道其中的内容；之前怎么没有发现呢！</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试分类</title>
    <url>/2020/07/28/2020-07-28-Test-Classification/</url>
    <content><![CDATA[<p>工作这么多年，经常听到有人在说冒烟测试，β测试，UAT测试等等；但是随着进入项目逐渐熟悉起来，也跟着喊了。经常是刚进来的人一头雾水。我们从未去深究为什么有这样的命名，也没有去深究那几个英文字母是哪几个单词的缩写。</p>
<h1 id="1-软件测试分类"><a href="#1-软件测试分类" class="headerlink" title="1. 软件测试分类"></a>1. 软件测试分类</h1><p>按照生命周期的软件测试概念，测试对象应包括软件设计开发的各个阶段的内容，对于需求和设计阶段的测试以及关于文档的测试将在面向对象与文档测试部分进行描述。根据不同的开发阶段，测试实施组织以及测试技术，可以对测试进行不同的分类，已区分各个阶段的测试工作，测试人员以及采用的各种测试技术。</p>
<table>
<thead>
<tr>
<th>划分依据</th>
<th>测试分类</th>
</tr>
</thead>
<tbody><tr>
<td>开发阶段</td>
<td>单元测试-&gt;集成测试-&gt;系统测试-&gt;确认测试-&gt;验收测试</td>
</tr>
<tr>
<td>实施组织</td>
<td>开发方测试-&gt;用户测试(β测试)-&gt;第三方测试</td>
</tr>
<tr>
<td>测试技术</td>
<td>白盒测试，黑盒测试，灰盒测试</td>
</tr>
</tbody></table>
<h1 id="2-按照开发阶段划分"><a href="#2-按照开发阶段划分" class="headerlink" title="2. 按照开发阶段划分"></a>2. 按照开发阶段划分</h1><p>按照开发阶段划分软件测试分为：单元测试，集成测试，系统测试，确认测试和验收测试。</p>
<h2 id="2-1-单元测试"><a href="#2-1-单元测试" class="headerlink" title="2.1 单元测试"></a>2.1 单元测试</h2><p>单元测试又称模块测试，是针对软件设计的最小单位————程序模块进行正确性检验的测试工作。其目的在于检查每个程序单元能否正确实现详细设计说明中的模块功能、性能、接口和设计约束等要求，发现各模块内部可能存在的各种错误。单元测试需需要从程序内部结构出发设计测试用例。多个模块可以平行地独立进行单元测试。</p>
<h2 id="2-2-集成测试-组装测试，SIT测试"><a href="#2-2-集成测试-组装测试，SIT测试" class="headerlink" title="2.2 集成测试(组装测试，SIT测试)"></a>2.2 集成测试(组装测试，SIT测试)</h2><p>集成测试也叫组装测试，也称为SIT测试(System Integration Test)。通常在单元测试的基础上，将所有的程序模块进行有序的，递增的测试。集成测试是检验程序单元或部件的接口关系，逐步集成为符合概要设计要求的程序部件或整个系统。</p>
<p>软件集成的过程是一个持续的过程，会形成很多个临时版本，在不断的集成过程中，功能集成的稳定性是真正的挑战。在每个版本提交时，都需要进行<strong>冒烟测试</strong>，即对程序主要功能进行测试。冒烟测试也叫版本验证测试、提交测试。</p>
<h2 id="2-3-确认测试"><a href="#2-3-确认测试" class="headerlink" title="2.3 确认测试"></a>2.3 确认测试</h2><p>确认测试是通过检验和提供客观证据，证实软件是否满足特定预期用途的需求。确认测试时检测与证实软件是否满足软件需求说明书中规定的要求。</p>
<h2 id="2-4-系统测试-ST测试"><a href="#2-4-系统测试-ST测试" class="headerlink" title="2.4 系统测试(ST测试)"></a>2.4 系统测试(ST测试)</h2><p>系统测试(System Test)是为验证和确认系统是否达到其原始目标，而对集成的硬件和软件系统进行的测试。系统测试是在真实或模拟系统运行的环境下，检查完整的程序系统能否和系统(包括硬件，外设，网络和系统软件，支持平台等)正确配置，连接，并满足用户需求。</p>
<h2 id="2-5-验收测试-UAT测试"><a href="#2-5-验收测试-UAT测试" class="headerlink" title="2.5 验收测试(UAT测试)"></a>2.5 验收测试(UAT测试)</h2><p>按照项目任务或合同、供需双方约定的验收依据文档进行的对整个系统的测试与评审，决定是否接收或拒收系统。也常被称为(UAT 测试：User Acceptance Test)。</p>
<h1 id="3-按照测试实施组织划分"><a href="#3-按照测试实施组织划分" class="headerlink" title="3 按照测试实施组织划分"></a>3 按照测试实施组织划分</h1><p>按照测试实施组织划分，软件测试可分为开发方测试，用户测试(β测试)、第三方测试。</p>
<h2 id="3-1-开发方测试"><a href="#3-1-开发方测试" class="headerlink" title="3.1 开发方测试"></a>3.1 开发方测试</h2><p>通常也叫“验证测试”或“α测试”。开发方通过检测和提供客观证据，证实软件的实现是否满足规定的需求。验证测试是在软件开发环境下，由开发者检测与证实软件的实现是否满足软件设计说明或软件需求说明的要求。主要是指在软件开发完成以后，开发方对要提交的软件进行全面的自我检查与验证，可以和软件的“系统测试”一并进行。</p>
<h2 id="3-2-用户测试"><a href="#3-2-用户测试" class="headerlink" title="3.2 用户测试"></a>3.2 用户测试</h2><p>在用户的应用环境下，用户通过运行和使用软件，检测与核实软件实现是否符合自己预期的要求。通常情况用户测试不是指用户的“验收测试”，而是指用户的使用性测试，由用户找出软件的应用过程中发现的软件的缺陷与问题，并对使用质量进行评价。</p>
<p>β测试通常被看成是一种“用户测试”。β测试主要是把软件产品有计划地免费分发到目标市场，让用户大量使用，并评价、检查软件。通过用户各种方式的大量使用，来发现软件存在的问题与错误，把信息反馈给开发者修改。β测试中厂商获取的信息，可以有助于软件产品的发布。</p>
<h2 id="3-3-第三方测试"><a href="#3-3-第三方测试" class="headerlink" title="3.3 第三方测试"></a>3.3 第三方测试</h2><p>介于软件开发方与用户方之间的测试组织的测试。第三方测试也称为独立测试。软件质量工程工程强调开展独立验证和确认活动。软件第三方测试也就是由在技术、管理和财务上与开发方和用户方相对独立的组织进行的软件测试。一般情况下是在模拟用户真实应用环境下，进行软件确认测试。</p>
<h1 id="4-按照测试技术划分"><a href="#4-按照测试技术划分" class="headerlink" title="4 按照测试技术划分"></a>4 按照测试技术划分</h1><p>按照测试技术划分：白盒测试、黑盒测试、灰盒测试。也可划分为静态测试和动态测试。静态测试是指不运行程序，通过人工对程序和文档进行分析与检查；静态测试技术又称为静态分析技术，静态测试实际上是对软件中的需求说明书、设计说明书、程序源代码等进行非运行的检查，静态测试包括：走查、符合执行、需求确认等。动态测试是指通过人工或使用工具运行程序进行检查、分析程序的执行状态和程序的外部表现。我们这里讨论的白盒测试，黑盒测试，灰盒测试，在实际测试方法上既包括了动态测试也包括了静态测试。</p>
<h2 id="4-1-白盒测试"><a href="#4-1-白盒测试" class="headerlink" title="4.1 白盒测试"></a>4.1 白盒测试</h2><p>通过对程序内部结构的分析、检测来寻找问题。白盒测试可以把程序看成装在一个透明的盒子里，也就是清楚了解程序结构和处理过程，检查是否所有的结构及路径都是正确的，检查软件内部动作是否按照设计说明的规定正常进行。白盒测试又称结构测试。</p>
<h2 id="4-2-灰盒测试"><a href="#4-2-灰盒测试" class="headerlink" title="4.2 灰盒测试"></a>4.2 灰盒测试</h2><p>通过软件的外部表现来发现其缺陷和错误。黑盒测试法把测试对象看成一个黑盒子，完全不考虑程序内部结构和处理过程。黑盒测试是在程序界面处进行测试，它只是检查程序是否按照需求规格说明书的规定正常实现。</p>
<h2 id="4-3-灰盒测试"><a href="#4-3-灰盒测试" class="headerlink" title="4.3 灰盒测试"></a>4.3 灰盒测试</h2><p>介于白盒测试与黑盒测试之间的测试。灰盒测试关注输出对于输入的正确性；同时也关注内部表现，但这种关注不像白盒测试那样详细、完整，只是通过一些表征性的现象、事件、标志来判断内部运行的状态。</p>
<p>灰盒测试结合了白盒测试和黑盒测试的要素。它考虑了用户端、特定的系统知识和操作环境。它在系统组件的协同性环境中评价应用软件的设计。</p>
<p>软件测试方法和技术的分类与软件开发过程相关联，它贯穿了整个软件生命周期。走查、单元测试、集成测试、系统测试用于整个开发过程中的不同阶段。开发文档和源程序可以应用单元测试或应用走查的的方法；单元测试可应用白盒测试的方法；集成测试应用近似灰盒测试方法；而系统测试和确认测试应用黑盒测试方法。</p>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>《软件评测师》Flag</title>
    <url>/2020/07/27/2020-07-27-Software%20Evaluator%20Test/</url>
    <content><![CDATA[<h1 id="考试计划"><a href="#考试计划" class="headerlink" title="考试计划"></a>考试计划</h1><p>前两天报名了软件测评师的等级考试，时间大概在2020-11-07；同时购买了3本考试用书，大概翻阅了一下，可以说这是我目前看到的对于测试理论以及测试实操介绍最为全面的书籍，没有之一(也可能是我看书少的原有)。</p>
<p>既然定了有考试时间，肯定要立Flag，排期进行；不至于报名加买书的这2,300块钱打水漂。</p>
<table>
<thead>
<tr>
<th>书籍</th>
<th>时间</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>软件评测师教程</td>
<td>2020-8-1至2020-8-31</td>
<td></td>
</tr>
<tr>
<td>软件评测师考试讲义</td>
<td>2020-9-1至2020-9-30</td>
<td></td>
</tr>
<tr>
<td>软件评测师试题分析与解答</td>
<td>2020-10-1至2020-10-31</td>
<td></td>
</tr>
</tbody></table>
<p>希望自己能通过这次等级考试，补齐相关测试理论的短板，同时拿到证书；同时在学习过程中，好的相关测试理论以及测试案例，能够记录下来。</p>
<h1 id="考试总结"><a href="#考试总结" class="headerlink" title="考试总结"></a>考试总结</h1><p><strong>2020-11-09</strong>完成了软件测评师的考试，总体上感觉考试不难；前提是你要知道，知道就简单；不知道就不知道，无所谓难于不难。应该说考察的实是知识的广度而不是深度。<br><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images/Test/1-2020-07-27-SoftwareEvaluatorTest.jpg" alt="Exam"><br>不过参加考试的人当中，估计有50%的人缺考。好久没有体验过坐在教室里面的感觉，做在课桌前真是思绪万千。<br><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images/Test/2-2020-07-27-SoftwareEvaluatorTest.jpg" alt="Exam"><br>参加考试的人有年纪大的有年纪小的，都要保持一颗求知的心。<br><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images/Test/3-2020-07-27-SoftwareEvaluatorTest.jpg" alt="Exam">  </p>
<h1 id="考试结果"><a href="#考试结果" class="headerlink" title="考试结果"></a>考试结果</h1><p>刚好考试结果就在过于不过的边缘，不过没有过多少令人失望；尤其是看到朋友圈那么多人过了的时候，一比较愈发的心情低落啊。<br><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images/Test/4-2020-07-27-SoftwareEvaluatorTest.png" alt="Exam"></p>
<h1 id="考试总结-1"><a href="#考试总结-1" class="headerlink" title="考试总结"></a>考试总结</h1><p>总体来说考试的理论以及概念都跟自己平时工作有大部分重合，所以考试能在过于不过的边缘；对于考试参考用书也只是浏览了一遍就上考场了。但是对于理论的学习自己过于佛系，没有强调理论学习的严谨性，感觉从初高中以来都没有重视过这个问题；应该加强记忆，更加严谨。下次还要考试，一定要考过。</p>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>Flag</tag>
      </tags>
  </entry>
  <entry>
    <title>用例设计之边界值</title>
    <url>/2020/07/29/2020-07-29-Testcase-Boundary-Value-Analysis/</url>
    <content><![CDATA[<p>在长期的测试经历中，大量的缺陷发生在输入或输出范围的边界上，而不是在输入范围的内部。因此针对各种边界情况设计测试用例，可以检查出更多的错误。例如，在做三角形计算时，要输入三角形的3个边长A、B和C。这3个数值应当满足A&gt;0,B&gt;0,C&gt;0,A+B&gt;c,A+C&gt;B,B+C&gt;A,才能构成三角形。但如果把6个不等式中的任何一个大于号“&gt;”错写成大于等于好“≥”，那就不能构成三角形。问题恰恰出现在容易被忽略的边界值附件。这里所说的边界值是指相当于输入等价类和输出等价类而言，稍高于其边界值及稍低于其边界值的一些特殊情况。</p>
<h1 id="1-边界条件"><a href="#1-边界条件" class="headerlink" title="1. 边界条件"></a>1. 边界条件</h1><p>边界条件是特殊情况，编程从根本上说不怀疑边界有问题。但是根据人的固有思维，常年累月形成的经验可能会造成边界的问题；例如：生活常识中，大部分人都认为数字开始是1，可是代码中数字开始是从0开始；这种误差就可能导致在边界处出现问题。</p>
<h1 id="2-次边界条件"><a href="#2-次边界条件" class="headerlink" title="2.次边界条件"></a>2.次边界条件</h1><p>普通边界条件是容易找到的，一般在产品说明书中有定义，或者在使用软件的过程中确定。而有些边界在软件内部，最终用户几乎看不到，但是软件测试仍然有必要检查。这样的边界条件称为次边界条件或内部边界条件。<br>寻找这样的边界不要求软件测试人员具有程序员那样阅读源代码的能力，但是要求大体了解软件的工作方式。2的乘方和ASCII表就是这样的例子。</p>
<h2 id="2-1-2的乘方"><a href="#2-1-2的乘方" class="headerlink" title="2.1 2的乘方"></a>2.1 2的乘方</h2><p>计算机和软件的计算基础是二进制，用户(bit)来表示0和1，一个字节(byte)有8位组成，一个(word)有两个字节组成等。下表列出了常用的2的乘方单位及其范围或值。</p>
<table>
<thead>
<tr>
<th>术语</th>
<th>范围或值</th>
<th>术语</th>
<th>范围或值</th>
</tr>
</thead>
<tbody><tr>
<td>位</td>
<td>0或1</td>
<td>千</td>
<td>1,024</td>
</tr>
<tr>
<td>双位</td>
<td>0~15</td>
<td>兆</td>
<td>1,048,576</td>
</tr>
<tr>
<td>字节</td>
<td>0~255</td>
<td>亿</td>
<td>1,073,741,824</td>
</tr>
<tr>
<td>字</td>
<td>0~65,535</td>
<td>万亿</td>
<td>1,099,511,627,776</td>
</tr>
</tbody></table>
<p>上表列出的范围和值是作为边界条件的重要数据。除非软件向用户提出这些范围，否则在需求文档中不会指明。然而，它们通常由软件内部使用，外部是看不见的，当然，在产生软件缺陷的情况下可能会看到。<br>在建立等价区间时，要考虑是否需要包含2的乘方边界条件。例如，如果软件接受用户输入1~1000范围内的数字，谁都知道在合法区间中包含1和1000，也许还有2和999.为了覆盖任何可能的2的乘方次边界，还要包含临近双位边界的14、15和16，以及临近字节边界的254、255和256.</p>
<h2 id="2-2-ASCII表"><a href="#2-2-ASCII表" class="headerlink" title="2.2 ASCII表"></a>2.2 ASCII表</h2><table>
<thead>
<tr>
<th>字符</th>
<th>ASCII值</th>
<th>字符</th>
<th>ASCII值</th>
<th>字符</th>
<th>ASCII值</th>
<th>字符</th>
<th>ASCII值</th>
</tr>
</thead>
<tbody><tr>
<td>Null</td>
<td>0</td>
<td>B</td>
<td>66</td>
<td>2</td>
<td>50</td>
<td>a</td>
<td>97</td>
</tr>
<tr>
<td>Space</td>
<td>32</td>
<td>Y</td>
<td>89</td>
<td>9</td>
<td>57</td>
<td>b</td>
<td>98</td>
</tr>
<tr>
<td>/</td>
<td>47</td>
<td>Z</td>
<td>90</td>
<td>:</td>
<td>58</td>
<td>y</td>
<td>121</td>
</tr>
<tr>
<td>0</td>
<td>48</td>
<td>[</td>
<td>91</td>
<td>@</td>
<td>64</td>
<td>z</td>
<td>122</td>
</tr>
<tr>
<td>1</td>
<td>49</td>
<td>‘</td>
<td>96</td>
<td>A</td>
<td>65</td>
<td>{</td>
<td>123</td>
</tr>
</tbody></table>
<p>0至9的后面ASCII值是48至57。斜杠符(/)在数字0前面，而冒号字符“：”在数字9的后面。大写字母A~Z对应65至90。小写字母对应97至122。这些情况都代表次边界条件。</p>
<h2 id="2-3-其他一些边界条件"><a href="#2-3-其他一些边界条件" class="headerlink" title="2.3 其他一些边界条件"></a>2.3 其他一些边界条件</h2><p>另一种看起来很明显的软件缺陷来源是当软件要求输入时，不是没有输入正确的信息，而是根本没有输入任何内容，只按了Enter建。这种情况在产品说明书中常常被忽略，程序员也可能经常遗忘，但是在实际使用中却时有发生。<br>正确的软件通常应该将输入内容默认为合法边界内的最小值，或者合法区间内的某个合理值，否则，返回错误提示信息。</p>
<h1 id="3-边界值选择方法"><a href="#3-边界值选择方法" class="headerlink" title="3. 边界值选择方法"></a>3. 边界值选择方法</h1><p><strong>边界值分析是一种补充等价划分的测试用例设计技术</strong>，它不是选择等价类的任意元素，而是选择等价类边界的测试用例。实践证明，为检验边界附近的处理专门设计测试用例，常常取得良好的测试效果。边界值分析法不仅重视输入条件边界，而且也适用于输出域测试用例。</p>
<p>对边界值设计测试用例，应遵循以下几条原则：</p>
<ol>
<li>如果输入条件规定了值的范围，则应取刚达到这个范围的边界的值，以及刚刚超越这个范围边界的值作为测试输入数据。</li>
<li>如果输入条件规定了值的个数，则用最大个数、最小个数、比最小个数少1、比最大个数多1的数作为测试数据。</li>
<li>根据规格说明的每个输出条件，使用前面的原则1或者原则2。</li>
<li>如果程序的规格说明给出的输入域或输出域是有序集合，则应选取集合的第一个元素和最后一个元素作为测试用例。</li>
<li>如果程序中使用了一个内部数据结构，则应当选择这个内部数据结构边界上的值作为测试用例。</li>
<li>分析规格说明，找出其他可能的边界条件。</li>
</ol>
<p>这些都是正统的软件开发流程中，能给根据其相关文档找到对应的边界值。在实际工作中，可能并没有规范的文档，这就需要测试人员根据自己的实际积累，去辨识对应的边界，设计测试用例。</p>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>用例设计</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试过程模型</title>
    <url>/2020/08/26/2020-08-26-Test-Models/</url>
    <content><![CDATA[<p>软件测试过程的主要模型有V模型，W模型，H模型，X模型，前置测试模型。</p>
<h1 id="1-V模型"><a href="#1-V模型" class="headerlink" title="1. V模型"></a>1. V模型</h1><p>如上图所示，V字形左边各圆形节点表示开发过程中的个阶段，V字形的右边各圆形节点表示测试过程中的各阶段，每个开发阶段对应一个测试阶段。编码&lt;-&gt;单元测试、系统结构设计&lt;-&gt;系统测试、详细或程序设计&lt;-&gt;功能测试、编码&lt;-&gt;单元测试。</p>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>测试设计</tag>
      </tags>
  </entry>
  <entry>
    <title>用例设计之场景法</title>
    <url>/2020/08/04/2020-08-04-Testcase-Scene-Method/</url>
    <content><![CDATA[<p>现在的软件几乎都是用实践触发来控制流程，事件触发时的情景便形成了场景，而同一事件不同的触发顺序和处理结果形成了事件流。这种在软件设计方面的思想也可以引入到软件测试中，可以比较生动地描绘出事件触发时的情景，有利于测试用例的设计，同时使测试用例更容易理解和执行。<br>用例场景用例描绘流经测试用例的路劲，从用例开始到结束遍历这条路劲上所有基本流和备选流。</p>
<h1 id="1-基本流和备选流"><a href="#1-基本流和备选流" class="headerlink" title="1. 基本流和备选流"></a>1. 基本流和备选流</h1><p>如下图所示，图中经过用例的每条路径都用基本流和备选流来表示，直黑线表示基本流，是经过用例的最简单的路劲。备选流用不同的彩色表示，一个备选流可能从基本流开始，在特定条件下执行，然后重新加入基本流中(如备选流1和3)；也可能起源于另一个备选流(备选流2)，或者终止用例而不再重新加入到某个流(如备选流2和4)。<br><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images/Test/2020-08-04-Testcase-Scene-Method-1.png" alt="ScenceMethod"><br>如上图所示的每个经过用例的路劲，可以确定一下不同的用例场景。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">场景1：基本流；</span><br><span class="line">场景2：基本流，备选流1；</span><br><span class="line">场景3：基本流，备选流1，备选流2；</span><br><span class="line">场景4：基本流，备选流3；</span><br><span class="line">场景5：基本流，备选流3，备选流1；</span><br><span class="line">场景6：基本流，备选流3，备选流1，备选流2；</span><br><span class="line">场景7：基本流，备选流4；</span><br><span class="line">场景8：基本流，备选流3，备选流4。</span><br></pre></td></tr></table></figure>

<h1 id="2-用户登录示例"><a href="#2-用户登录示例" class="headerlink" title="2. 用户登录示例"></a>2. 用户登录示例</h1><h2 id="2-1-示例描述"><a href="#2-1-示例描述" class="headerlink" title="2.1 示例描述"></a>2.1 示例描述</h2><p>示例为常规的网站登录操作，如下为所示用例的基本流和某些备选流。<br><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images/Test/2020-08-04-Testcase-Scene-Method-2.png" alt="ScenceMethod2"> </p>
<h2 id="2-2-场景设计"><a href="#2-2-场景设计" class="headerlink" title="2.2 场景设计"></a>2.2 场景设计</h2><table>
<thead>
<tr>
<th>场景描述</th>
<th>基本流</th>
<th>备选流</th>
</tr>
</thead>
<tbody><tr>
<td>场景1-登录成功</td>
<td>基本流</td>
<td></td>
</tr>
<tr>
<td>场景2-输入验证</td>
<td>基本流</td>
<td>备选流1</td>
</tr>
<tr>
<td>场景3-验证码校验</td>
<td>基本流</td>
<td>备选流2</td>
</tr>
<tr>
<td>场景4-用户不存在验证</td>
<td>基本流</td>
<td>备选流3</td>
</tr>
<tr>
<td>场景5-密码验证</td>
<td>基本流</td>
<td>备选流4</td>
</tr>
</tbody></table>
<h2 id="2-3-用例设计"><a href="#2-3-用例设计" class="headerlink" title="2.3 用例设计"></a>2.3 用例设计</h2><p>对于这5个场景的每一个场景都需要确定测试用例，一般采用矩阵或决策表来确定和管理测试用例。如下表所示为一种通用格式，其中行代表各个测试用例，列代表测试用例的信息。本例中的测试用例包含测试用例ID，场景/条件，测试用例中涉及的所有数据元素和预期结果等项目。首先确定执行用例场景所需的数据元素，然后构建矩阵，最后要确定包含执行场景所需的适当条件的测试用例。在下面的矩阵中，V表示这个条件必须有效的才可执行基本流，I表示这种条件下将激活所需备选流，n/a表示这个条件不适用与测试用例。</p>
<table>
<thead>
<tr>
<th>TC(测试用例)ID号</th>
<th>场景/条件</th>
<th>验证码</th>
<th>用户名</th>
<th>密码</th>
<th>预期结果</th>
</tr>
</thead>
<tbody><tr>
<td>TC1</td>
<td>场景1-登录成功</td>
<td>V</td>
<td>V</td>
<td>V</td>
<td>登录成功</td>
</tr>
<tr>
<td>TC1</td>
<td>场景2-输入验证</td>
<td>I</td>
<td>I</td>
<td>I</td>
<td>提示登录信息输入完整</td>
</tr>
<tr>
<td>TC1</td>
<td>场景3-验证码校验</td>
<td>I</td>
<td>V</td>
<td>V</td>
<td>提示验证码错误</td>
</tr>
<tr>
<td>TC1</td>
<td>场景4-用户不存在验证</td>
<td>V</td>
<td>I</td>
<td>V</td>
<td>提示用户名或密码错误</td>
</tr>
<tr>
<td>TC1</td>
<td>场景5-密码验证</td>
<td>V</td>
<td>V</td>
<td>I</td>
<td>提示用户名或密码错误</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>用例设计</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 博文搭建</title>
    <url>/2020/09/08/2020-09-08-HexoSetting/</url>
    <content><![CDATA[<p>Hexo 博文设置加密：<a href="https://github.com/MikeCoder/hexo-blog-encrypt" target="_blank" rel="noopener">https://github.com/MikeCoder/hexo-blog-encrypt</a></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>平生畅(1)</title>
    <url>/2020/09/04/2020-09-04-RecentFeelings/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="我年华虚度，空有一身疲倦。" data-whm="这才知道我全部的努力，不过完成了普通的生活。">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">Hey, password is required here.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="5cb60a7bb5f5fb056dfdbe40b4f20231b0aece336b06adfcf306de009641229d">33f0e8a3bc876b5663973bdc75a16271c3ef68a234d08fff123bae000f451db58640e808eb7194996806676b35400a91671277c7b07768261e8c0f1eb786d0d5f03ee4b0b25ec1940cde59003abda1a3f6d573140810d9d0eacfe7d1b445bc5b9c7fe37d7ac2ec2f451631bbc522a1cabde5620a911ed14c5ab682d5e273b68c087fec2faa83ab9cf4ff1f65bee74533674da86968098a2842c6ac4b3f6364092e4b1e495087c44a011502f235bc66ed7e6bc77917beba95e2f89c59407567a1ad5543d01efd2da018862e3ed778a4ff2b528a276a6df910bd9e0ed294bcf77341e201037a5588f7c627cf42ebb9cff86e586b7067d9fbe371ec76aa498f04dd997aa2b59f81eba67aa138552fc7d3101b57f263140082c675b3bf1bd9c716819428d46567470efcfd55009598a712e2bf0ae8ff516463b14f5c6727726c959f45c4c3dd8241cc2ad1c1d7bb359fec7b4926e496156a74ab7f5010e724193ffb66cb386078cc021f752b2ed55405b1609face75e956d0486301465201dd0783e7c3eda598b68b81e6ec0a88c764468d365d2e05814ab99e0e14b9b9d2e0825efe45fe8dafac9e10da53ff7e6a92e60b3d43244a3e391984c1957b09a42ffef1ab63bb76266a9a9ddc89ff7ca4bd76fb871705fad5d92a94ed65e81a0e24bd48eaeb09c71137c030dfdd4589d94b3db557c5326bb359f0540b120925b68722cdad8f27f31bedc43ca0ecb234a6d489cfa3a88702e67254f8b2d6cfcefc59f62bc68cf6b96835ba354b98de506508a9a8598e644d58acbe0f41e164bca09db7bbb21301bc3b4e46e373bb2f2ad7c8d0eb61ec2384dd4989b957b77e7bc0af5c27e8f119019f93b827f9f68873870d62504d335d62574b84037ea91e2ead7883af2a42fb988084b19981d3750bac9c4acd67a7bb8ec39c7e4847b343ded35b2a857fb70de33d31931e2b578e09d1975d52c5831d13cbfe49d686c1c555aa6a2300414f70efd46b4cfcebda76c3f569a7ae1668851d374e507a8511aca0e8b5f8ef4d1397c43ca200b17f91ee5f16902ed9ccf62544e9d065f938a0341f06e93b4aae6ecc41c8647bd2026a1a898bf370959c07dac24711a7d00f1a6ffb05af9559d7d4a090c6e83d7abefc0e9e412b2961f1a3abcc069664b322d88c1b3a96358e85c933b44a7f73739c0ec14cdb0388ef9cb8c27b74ca32d0ed099681fb880ec217a8ae4aa0a4ea319a07ecc04103fe1c07ac3792e4c73e4f8c9921a0c52b43b7e434c9538693840615e9d7fab6b84bc06109dd6ea0262a96834662711e356855532620fabd42d358a9a33e4aae65ba5ed58474d1ea3f5d48adb4548d9bd8db29413afa3cf8027c76b80032b15371b5009a98d254bfda80309f08a1455cd71d8d4ffa7d2cb31ce465f22b2e83f441e7080e1bf89d07a87989ddc247035a422809032352d392c0b51242bbe102311ba9d24d7ca94493f226d71b273965300a65a8e844001acecac2364ca55304198266af9de4f84b0ae8448056f0b437836a2306df09e39bb328d44b047bd1f4eed70b5b3dcc7db8c8346fd22dcc7e311ac8cbd975f8890d568cbb59b915f5396aa5cc41f900319df9a7970453e4560bda0ce31d005eec981415eb56bd560412c12ca16fb41f62fbb83c22703128c699a9bdf55c47e3204974dea1b50c76177beeea87a6942ab56661f09536e537c5e764801cf205f55acd1664132c8e2d73f4693d5d1c2c4340b095813d1670f3e7dc8f92b3dcbb0ce0009f13f16ac1489b9f1dab3dd327a7863f9d4191b60aee6febb40c072e11f898dd2d95b2bb918840ee37378c04139bc8afefa3c015f64c4cf95a68cf92d733e661a4fc8b066f9b9c423f5037bcf10e78f7b726e0bcec9bb7621535fa32e68fb41724dad52800649330949ddc3ededbe870f6bef799556ba2af7d1c56e6ebe32a48f75954b9b0ba01d2d4d73d741bc869efd053a7c64bc997ac05c19664aec8c35a6094d285693cc81674ca3fcda6837d0af055c0a288a8ab4a2bb6f11753c87765ad66f02fdce0ccba02295bb9a6fb2866a436229b68198698099083b158513de1393eab6163d246a1f8d1a6f6e3f3fa511da5efb17e96d1f21eccfa0783a6ad3281ad9a950d2af3cecd4698401def800200d418aeffcf5ccecc31a07be58cbbdd4c3bc2736952d957d22724e2712650c505214f838a794703b1c53cfb39b6c31fa885402b5e46417163d9647eaba6b33dc503665ad69901c3c320899e3e738e0239d2d43a88aac7c04b7eab65a39e3d5071765acfa079f4a3dc1bdc133fff02e63128f07c25b94c65c92ba5f89dc52c3d63caba1b0fcafb30256c645be55bf1d945a641056358ae609c6678ca1ede9edd0bf5613992a8c744b6f3b55e48d8eca35bb41dec6a55617597fd96e10c49146e9d4a65214f777d2c05bdac1df4913f25959a8fb92f19d6007250b23b3fa87b40644a355e39fedfb1d925ebb9cd597b76dcb78d1ec362c8ddb91434f80bbdf7f78c3e820345593ee60d72d3cd63c9a8671d598cc0d00c22cb600a704bec9e3087eff3e745b3cff14c79539055469efe25e816a5d29139ad9fc86f14b7e4c45e08c8064993f8e598ec623bf9f177fa54520625fa692b2f5fb1c722ce0cf13b174c6f865c824cd2b87b85f74d3652f13ba9b3684f815bc0b8f751e4ed5dce59b3e4364c6109ab20c5bcf4cfd188a7f15712a20640c5fd291defa70809636efe6054639b401eee7122d4bddf339f75b4e498c0feccedfd6f475ffc4bf292c423686f9e465ceed64bb449c6a6c025494b0530684011e369f899ed72afb8c0b</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>百年踪迹百年心</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;&lt;三体&gt;&gt;阅读笔记</title>
    <url>/2020/09/15/2020-09-15-ThreeBody/</url>
    <content><![CDATA[<p>最近总是把《三体》下下来看了，虽然听过很多人吐血推荐这本书，但是之前确实没有多大兴趣去阅读他。尤其是矮大紧在其节目中采访刘慈欣的时候，对作者以及这本书跪舔的姿态，都说明这本书的确是不得了的一本书。可我还是没有多大兴趣去阅读这本书，可能我更喜欢那种一路打怪升级，扮猪吃老虎的爽文；但是这种书看到了只能一时爽，所以还是抽空来看一下这本牛逼的书。想知道是何等的牛逼，让我怎样感觉自己的渺小。</p>
<p>完成了三体第一部的阅读，让我意外的是第一部这么短，我以后会有很长的内容，没想到这么快就看完了第一部分。看完第一部分没有多少让我惊讶的地方，觉得这本书也就那样；可能是因为我已经知道了大部分情节的原因吧。不过里面还是有很多新奇的地方，比如：用人构造的计算机的设想，以及三体人思维即表达的情节；之前都没有人去这样设想过。看来科幻小说，要牛逼的科幻小说，必须要想人之不能想的地方。对于第一部人与自然，以及人性本恶的主题思想，我倒没有什么感触。也许人类就应该被新的文明改造，你看现在的地球，被人类玩成了什么样子。但是我坚信人类终究会为自己的所作所为付出代价，以为科学进步能战胜自然；可是在自然面前无法知道自己是多么的自不量力；在自然眼中，人类跟虫子应该也没什么区别。</p>
<p>开始了三体第二部的阅读，首先就带出了一个让人思考的话题，当人类遭遇灭顶之灾时，什么样的人才有资格进入诺亚方舟。普遍认为应该是人类的精英，为了更好的延续人类的文明。可是精英也只是人类自己的看法而已，如果你站在动物的角度，也许所有人都一样，有什么区别。类似人人平等的话题，从来就没有平等过。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>节前小说</title>
    <url>/2020/09/30/2020-09-30-PreHolidaySpeaking/</url>
    <content><![CDATA[<p>依稀记得小时候上学的时候，在大假前的最后一堂课，总会莫名的兴奋，为即将到来的假期感到高兴，即使放假期间跟平时也没什么区别；也许仅仅是因为不用到学校的缘故，就可以引来无意识的兴奋；也许是喜欢放假之后的那种自由，不用每天按时到校，以及没有课业的束缚；也许仅仅是喜欢此刻看出教室外的树木的艳丽。这种感觉一直持续到整个学生生涯，即使后面大学的时候在假期的最后一党课，依旧可以感到令人莫名的兴奋。</p>
<p>后来出来工作了，放大假前依旧感到些许兴奋，不过已少了不少剂量；也许仅仅是因为节后能回老家，有一种行远程的刺激而已。慢慢地，在工作地安家了，放假前的兴奋以及心态波动已没有了，一如平常的每一天。逝去的是那一丝刺激，还是逝去的是什么？</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>百年踪迹百年心</tag>
      </tags>
  </entry>
  <entry>
    <title>节后小说</title>
    <url>/2020/10/09/2020-10-09-PostHolidaySpeaking/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="我年华虚度，空有一身疲倦。" data-whm="这才知道我全部的努力，不过完成了普通的生活。">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">Hey, password is required here.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="bd2bb663b3b6c25bcf48cffacd1e8261c23ad02b52152fed0b6db78212240c86">3afa8f13ac2ce5619363941566568260ec893c53c84ad6fc4bb6649d77ce8ddb71d40431303cdc55a7357eb89a1cb91672b5a2051a95e9c47fde966e870a8ffde8a078f1acc590c0e4a5b2bd3271449ea036649ba7b342a13b47fb26a7d5ec7826ce447b65d57a8d5f7273949b820a0ad983afee902467a405909c9430bfc743af3edeaf89fed7f023743a6ea22b139509b894d10ab4c03d2a61427703458dec45d5509b8f2e8d7a7a67d083eecf2ee2e84a8830e96bdee87f4bdfde4bba5250634b5a0fa99678156d778f44418cb2034963248ef94bcf066bcdd98e62359042ac117c889a707ff02b7d3bf66315270f4e65ca810c0a05ae890d0d3b26811a355c657f282680ba4de91fff5b5d44875829caf0bf4b8dc1ffc780d73b5d9b49f0783ad4afd0d805bf020e8b6e660072bfb294f8f4d81682827b88d4bd6b07136a382c5ddb19a3fa3ce0766f571fb14efb08e68cbc6fd399b2d6672076380c5b66c3afaf672e864a0755680e7781732d6a7d508bb4a3b3faee49c0f65360827ccef353a73a9b524d36e3af40a5584cab66084b9473322a6c2c946e22f7a0667842721f5719a6588852d0bc6a6c770fdadbf46c41f35890834fe45b9307da141bde450b63fd3373c31a0863b9786f20e0200a22bfc4111fb53dbfb19592a30fd185e9edf0b20c208435d4bc8603226da9b0362df1c602f66cb69ae407bb4c1981c1c02dcaeadb3234b79c3c203bbce4d81c6c469651d56045dd7a2e38481f6d6b3a7b79d2b5840e7addde11b8c33d363d6f9bacab4c19afb6b2c50f47f9a8809ee2b6402dd290499c2242c018aaa4d470f6db325a2981fa4c6f7a4dc889828819f4dcc5c7a7a99d43bca51286f4ee3ee3d58ba69999579d2b9384098838aa6b42d3d99029c56f9cfc32f6063c91797084885978beb15eb6caf46ed569d0ba37f8cce227212caf79e76ef630e74932fa64a582f55415da092ac51f3adfb91fe1a9de124f37ddaf99430dea7e0aa6efc4c23ee47e0e650ab6cb712b28153d8f4d460ad50f0505df8f5dd5021340803c0540d3d4c03da379284cd51e77ac45d0d811704e2462fc7b8aba96d6741a51609442b92ad8a194d1a111bd12ee1813a37e88fbe1d1d79f727e0277f134211909f8d862844ef48d6946be1f4b3ea3953ffb684809f49ce964b1fc0a82dff849b64b19c844024965d85b3e3181ef3493ee4efbe9d2b84c8ab9f4ba3f0dbd0a16a2dc4ae207ba5c4c24dee693ea2a550247efdb6ef37539fa8a3a98250c92407fc4f4783a8f1dd0868e8a1339440a18216f1151b77d599f99105b68a8e378209770f40b83cfa40147660cdb05148cbcf51337a7f4eae58dd362d14287c95b129819f1fc037cb80b43b822b5da3594ebd1cbb1887d17c960d8b7aef59062fba22e32398160d1e24c7bf0c5c026452495170100b39bb3b7a92c8fef6ab9bcc2b80dfb88dc53972a578f34b320686eb47df0b12585a2ff6951846e288b11dedc698c221ae7e08bfcec332e5495492da9f4e6bca1d6d66a193855b0cd4b61ccac191456b4987934824bb7251acf042afb304b8bdc7e8e76f1b0d5b94474f06de333e9d0f327f74c534d116af34d0cc2f4fcc1d78ef39a09bb02848b44e3de94b40fb324b8eb630ae7bc5fc1d4aae0d40c30d697d708c55c4ef504fddc2560db226c204abce99c7728730406fd90e99b079405dc261823884ef7ed1b4218bcf74a10e6432a5a08e3bcd503ace6087532eed7e333be60afcc537cc44e65d9a67f3f5b7ceecb30d3f73c9b6a5297f3d65bc0e1f401321ae2733de07428747950c9b1cf839d990b3c65aa26d0d9e52b0b9140e90cbce620ebcf58da45b43d4eb0c4fdf0aafb5c306879f0f0292e7669540c1e4fc409aabdac1b7643dfc46701ed70207f89f88cf0bb541e5f90c550c8aacbc5a46d248a782454d85b5cf615ea40fa53dbff1a2189f8b16756a64d4d3f2545ba5645661b972f24d9fadbf4e7e3670cd5769acd7a8a982721a589fc167e5337060eade23acd66c26e87c4244828bd057e9fa6275017eff6c706d0b0e831215c2aa0e478d992ed3dc84078409d407f9fca1d817760ed94796a3d1dd41fc49416affa5fc56d328ec5bbbf823c5013ad2fd7b4868d8ef40f09552fb23308ae2665f67401d3c23c43ebb105e0839007639bdadd19f0b987a10d3fa223c2fbd5c6c11902639e89d2a099005b63ea67f49c41dc2d309116c0d33e522342cae5490d566887cd5df354108afb09f62a02d07cf8ee2ae3d6c348a9b1a4684ef8a3a423ca1dac02bb60d7859dd556cad7230b712887cc1c3578ed0a35a531f7c985b2ca548fd3fd59a3896f75b049416fbb7985ee01d4bbc0610769543904140355fe23fcc25eb75a4994a27be065533cf8a23561932160cf0c4ddc0f7a2b5c6b5909df3c5954d3e54fd1a5a3ca9ea874220e29a9494e844fd11bf2a66768931f7839ef62f3a325faae7ef10041bf00653bef47105209ce4355bef7bdd342d12da8a629a6e0158f913ae91a07f0a17c91212b06015c41b30b137ec0bb2d120877b4a997f005fbef5163abe45e9bccc55d9db9dea1df8849922a4d4b755abbdc6bd7ba73d0d9acf002a3204f95862a1eb18050a339023f3bd60deae52484548219b758831f12deb9dce1229529a519e4c93dc5c8a3d8e1b3eacb011e791dbe285a6c1ec5611c2959f933fe539be0c4f27a124e3822fbbf77d0715d71e6ec38d11aa86676db046aaf298bd224fa0d7e9f63c99a87e01ef5a0ad39b43ffb2956af7f0106bcaa6529bc8dd8d50abb609cdec305426efa9a2309bf19fb80125448541dab154ab0040d55aa9e2ba9215d2324a602490b23de9a9abd4d2f6f49b128d2d12d01840b3de7d2f0680ecd2a841ceada4fcf185225fffe1c645ec3334601612a2641f8ebbe807ed8fa74ac39f9165f0c2bf57aaa8d045c927700dcc6911ec166ef2ab2eecd8cc8ceeed78d7462f9b6eb48077af448b0babf2562c5e23b5aea74a5c48ad1b4123e164b8c9aa5ce43d2efe7b551042f6f02f27a5ed18b4de573b4b14910af8bdee0c029ed026105e1272e14d87f99df2f556335f6b010ef43479887eaa0f93575b761f72708364f13874663ed298c84805c71f4718c8369bc966d1cc82e452d63923035b2782ceb026b3674ebe7852609e03f0c4f52b6c44fb5089971d99df6da28b11fdb69396d36264c194d935a6723d112fa55050d6266edc3d5358bfbf7d12041872a451781d3ff5a00b89f54b125c0bd80279e1127a9674e188ddb76def43d163d70d3ecf54c043fb0496ed8aebed7abbfd4d553dd2bd376b098c623c9c4a1847c5efab959fb1b5990bf11fba8ff26296b1c25210a6ac4581bac1baa0cc37510f81ced2ff96792505c388edc79e4247c0c73c9e91421a4cdd031e60ba04bbfcebbcea13c4e48cc93c058cbcca4991cc6e814474f31c4f185d379e54de28aa25f9aeb138a7bbf916b933ec2439392f9ac4ec4d05ee0738757ee4598bbc9f2305597807dc50850a9522f58decbe93314f9182f70b7e2159554cebacab81cfced99e9c06c96a56fdd8d666e213e3aca0ccbf60e0e74f4a1037cf77e4313af3462c61b8286d84ff6c87a3d33a302d42a2b0a232599a8d090023b7aa866740a85c2fc4936e37f4308ca7effcdabf9a25d47b629b1584659d412232f53b8ee97852263304536a7d354b22895ac272e0ed2c0092002078c13e64405206efa39549c7742c5c843aea5c2b8c6cc0506d392c437b1fb1dca189028c6ce91e635e657a4b89c2fea9dcf35b165c9609dc573d9505a588e2e6b29cc2fc6eab4bf767a4f9ff3a69c8d3ae5dfadf8b4ca245144791a3d1d926c09bc78e2a2ddda3a4b6f587bab05d8db22ce68c779d56ee22a3e4fc255d765da66abd35e3847bc5b3f51c42fc97330037e4619420af2c77b31cf2575d244c258eaf75a3b24daafe8d20c2f1a065e261b45c389ce59da0b71fcd6ea77446ebf6eb1b45a7cb4bd14bfa417d1657d4792d1f34dfa1d71d745f9ad6fd3e3166fb5abe898fb681a15b94ed46fe584f7fac8b086</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>百年踪迹百年心</tag>
      </tags>
  </entry>
  <entry>
    <title>控制流图</title>
    <url>/2020/11/09/2020-11-09-TestAnalysis-CFD/</url>
    <content><![CDATA[<h1 id="1-控制流图"><a href="#1-控制流图" class="headerlink" title="1.控制流图"></a>1.控制流图</h1><p>控制流图(Control Flow Graph, CFG)也叫控制流程图，是一个过程或程序的抽象表现，是用在编译器中的一个抽象数据结构，由编译器在内部维护，代表了一个程序执行过程中会遍历到的所有路径。它用图的形式表示一个过程内所有基本块执行的可能流向, 也能反映一个过程的实时执行过程。</p>
<h1 id="2-控制流图生成算法"><a href="#2-控制流图生成算法" class="headerlink" title="2.控制流图生成算法"></a>2.控制流图生成算法</h1><h2 id="2-1-简单语句节点"><a href="#2-1-简单语句节点" class="headerlink" title="2.1 简单语句节点"></a>2.1 简单语句节点</h2><p>该节点直接添加到当前节点的下一节点，然后当前节点变为后继节点。<br><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images/Test/2020-11-09-TestAnalysis-CFD-1.png" alt="简单语句节点">   </p>
<h2 id="2-2-IF语句节点"><a href="#2-2-IF语句节点" class="headerlink" title="2.2 IF语句节点"></a>2.2 IF语句节点</h2><p>该节点需要增加一条条件节点，由该条件出发引出两条后继节点，其中一条为if为真的后继节点，另外一条需要根据代码表达式判断是否存在else，如果存在else则后继节点再增加一条else的节点，不存在else则仍添加一条后继节点，该节点为if结束节点。最后当前节点分别对if和else内的语法树进行分析，if内的分析完后最后指向if结束节点。<br><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images/Test/2020-11-09-TestAnalysis-CFD-2.png" alt="IF语句节点">  </p>
<h2 id="2-3-SWITCH语句节点"><a href="#2-3-SWITCH语句节点" class="headerlink" title="2.3 SWITCH语句节点"></a>2.3 SWITCH语句节点</h2><p>该节点需要增加一条条件节点，由该条件出发引出多条后继节点。建立两个栈结构，一个label栈，用于存放case或者default节点，一个是break栈，如果有break表示该case结束。最后增加一个switch结束节点，所有case节点的后继节点都指向它。<br><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images/Test/2020-11-09-TestAnalysis-CFD-3.png" alt="IF语句节点">  </p>
<h2 id="2-4-WHILE语句节点"><a href="#2-4-WHILE语句节点" class="headerlink" title="2.4 WHILE语句节点"></a>2.4 WHILE语句节点</h2><p>该节点需要增加一条条件节点，由该条件出发引出两条后继节点，其中一个节点为while结束节点，另外一个节点为while内语句节点。再增加break栈结构和continue栈结构，while结束时从这些栈中取出节点，break节点指向while结束节点，continue指向while条件节点。<br><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images/Test/2020-11-09-TestAnalysis-CFD-4.png" alt="WHILE语句节点"><br><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images/Test/2020-11-09-TestAnalysis-CFD-5.png" alt="WHILE语句节点"><br><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images/Test/2020-11-09-TestAnalysis-CFD-6.png" alt="WHILE语句节点">  </p>
<h2 id="2-5-DO-WHILE语句节点"><a href="#2-5-DO-WHILE语句节点" class="headerlink" title="2.5 DO-WHILE语句节点"></a>2.5 DO-WHILE语句节点</h2><p>该节点处理方式和上述while相似，只要把条件节点换在while结束前，并且该条件节点指向do节点。<br><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images/Test/2020-11-09-TestAnalysis-CFD-7.png" alt="DO-WHILE语句节点">  </p>
<h2 id="2-6-FOR语句节点"><a href="#2-6-FOR语句节点" class="headerlink" title="2.6 FOR语句节点"></a>2.6 FOR语句节点</h2><p>该节点添加一个后继节点表示循环初始值，再在后面添加条件节点表示for循环条件，循环结束节点需要指向条件节点。<br><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images/Test/2020-11-09-TestAnalysis-CFD-8.png" alt="FOR语句节点">  </p>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>Test</tag>
      </tags>
  </entry>
  <entry>
    <title>《最后的棒棒》观后感</title>
    <url>/2020/11/27/2020-11-27-Last-BangBang/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images/Article/2020-11-27-Last-BangBang.jpg" alt="最后的棒棒"></p>
<p>偶然在抖音上看到了这样一部纪录片，虽然还是被切割了无数部分；但是还是深深地吸引了我。因为他们的生活感觉是那么熟悉，虽然小时候也看过电视剧《山城棒棒军》，但是记忆相对模糊，也没有完整看完过。不过对于棒棒的熟悉，还是源于我生活在火车站附近，小时候到处可见的棒棒；虽然现在已没有了，就连坐火车的人也很少了；即使有，都是到了就上火车，也不会再火车站作停留。</p>
<p>在这一部纪录片中我看到了我熟悉的人们，也许是地理位置相近的缘故。就这样卑微的一生，令人感叹！</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>如何做到测试场景不遗漏？</title>
    <url>/2020/12/08/2020-12-08-Test-Scenes/</url>
    <content><![CDATA[<p><strong>注：</strong>以下文章来源于阿里巴巴技术质量 ，作者麒烨。</p>
<h1 id="测试分析与设计"><a href="#测试分析与设计" class="headerlink" title="测试分析与设计"></a>测试分析与设计</h1><p>测试是一门精细的学科，新人同学很容易有的误区是认为做测试主要就是编写测试用例和执行测试用例，进阶能力是写自动化脚本或研发工具。而实际上，测试人员最难修炼的是测试分析能力，测试分析能力是衡量一位测试同学是否专业的分水岭。分析除了使用方法，还需要有对业务、经验、质量的深度理解。自动化或工具实际是对分析和设计结果的一种实现，分析和设计的有效会决定实现的效果。</p>
<h2 id="分析与设计过程"><a href="#分析与设计过程" class="headerlink" title="分析与设计过程"></a>分析与设计过程</h2><p>测试分析要从业务需求最开始就要介入，流程覆盖业务整个生命周期。在做分析的过程要想清楚，整体后续的设计怎么做。<br>测试分析可总结为四步</p>
<ul>
<li>建模 - 输出业务/系统流程（分析：业务流程 - 系统流程）</li>
<li>设计 - 测试场景（设计：测试场景）</li>
<li>细分 - 测试用例/数据（设计：测试用例）</li>
<li>扩展 - 多类型测试（性能，安全，异常等等）（基于经验）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images/Test/1-2020-12-08-Test-Scenes.jpg" alt="TestScense"></p>
<h2 id="测试场景分析实施"><a href="#测试场景分析实施" class="headerlink" title="测试场景分析实施"></a>测试场景分析实施</h2><p>测试场景和测试用例区别是什么？为什么先要设计测试场景？</p>
<p>上图也描述了，测试场景对应的是实际的业务场景，业务场景是业务流程中因不同的事件触发后的业务情景。比如银行取款的业务办理流程，会因为用户的身份（VIP与否）、取款金额（大额，小额）、卡内余额（足额取，不足额取）等诸多因素，导致最后取款的结果和过程分支产生不同。测试场景就是对这类事件触发时的业务情景在质量角度的描述。而测试用例是对测试场景在测试范围和测试点的详细覆盖。</p>
<h3 id="第一步：根据业务的目标（价值）、类别、技术等输入，确定业务场景分析的范围。"><a href="#第一步：根据业务的目标（价值）、类别、技术等输入，确定业务场景分析的范围。" class="headerlink" title="第一步：根据业务的目标（价值）、类别、技术等输入，确定业务场景分析的范围。"></a>第一步：根据业务的目标（价值）、类别、技术等输入，确定业务场景分析的范围。</h3><p>业务分析就是需求分析的过程。这里不仅仅考虑需求的功能逻辑，还需要结合不同业务类型，根据历史业务经验沉淀和风险沉淀进行综合考虑。可以参考用下图进行前期梳理。</p>
<table>
<thead>
<tr>
<th>需求类型</th>
<th>资源&amp;方法需求</th>
<th>必须覆盖点</th>
</tr>
</thead>
<tbody><tr>
<td>主业务类需求</td>
<td></td>
<td></td>
</tr>
<tr>
<td>技改类需求</td>
<td></td>
<td></td>
</tr>
<tr>
<td>全链路</td>
<td></td>
<td></td>
</tr>
<tr>
<td>外部商家需求</td>
<td></td>
<td></td>
</tr>
<tr>
<td>大促&amp;BU核心项目</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="第二步：业务流程梳理（业务场景）"><a href="#第二步：业务流程梳理（业务场景）" class="headerlink" title="第二步：业务流程梳理（业务场景）"></a>第二步：业务流程梳理（业务场景）</h3><p>将需求说明转化为业务流程，完成事件流（基本流+备选流）以及业务分析过程和技术分析过程的梳理。细化出原子级别的场景分支。</p>
<p><strong>事件流：</strong> 同一事件不同的触发顺序和处理结果形成事件流，事件流分为基本流和备选流<br><strong>基本流：</strong> 程序从开始执行直到成功结束所经过的最短路径。<br><strong>备选流：</strong> 一个备选流可能从基本流开始，在特定条件下执行，然后重新加入基本流中；也可起源于另一个备选流，执行后加入基本流或终止用例。根结点的备选流要具备原子性。<br>基本流和备选流：如下图所示，图中经过用例的每条路径都用基本流和备选流来表示，直黑线表示基本流，是经过用例的最简单的路径。备选流用不同的色彩表示，一个备选流可能从基本流开始，在某个特定条件下执行，然后重新加入基本流中（如备选流2和4）；也可能起源于另一个备选流（如备选流4），或者终止用例而不再重新加入到某个流（如备选流1和3）。<br><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images/Test/2-2020-12-08-Test-Scenes.jpg" alt="TestScense"></p>
<p>实例：<br><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images/Test/3-2020-12-08-Test-Scenes.jpg" alt="TestScense"></p>
<h3 id="第三步：场景串联"><a href="#第三步：场景串联" class="headerlink" title="第三步：场景串联"></a>第三步：场景串联</h3><p>通过第二步中拆解的场景，根据沉淀后的场景集，用组合，合并等方法梳理出所有的事件流。事件流必须100%覆盖所有的基本流+备选流组合。<br>例：<br><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images/Test/4-2020-12-08-Test-Scenes.jpg" alt="TestScense"></p>
<h2 id="测试用例设计"><a href="#测试用例设计" class="headerlink" title="测试用例设计"></a>测试用例设计</h2><p>测试用例的设计很多时候是测试数据设计的过程，根据事件流（基本流+备选流）、数据和根据不同的角色，进行用例覆盖。需要确保所有场景100%覆盖。<br>例：</p>
<table>
<thead>
<tr>
<th>需求类型</th>
<th>资源&amp;方法需求</th>
<th>必须覆盖点</th>
</tr>
</thead>
<tbody><tr>
<td>主业务类需求</td>
<td></td>
<td></td>
</tr>
<tr>
<td>技改类需求</td>
<td></td>
<td></td>
</tr>
<tr>
<td>全链路</td>
<td></td>
<td></td>
</tr>
<tr>
<td>外部商家需求</td>
<td></td>
<td></td>
</tr>
<tr>
<td>大促&amp;BU核心项目</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="非功能性设计扩展"><a href="#非功能性设计扩展" class="headerlink" title="非功能性设计扩展"></a>非功能性设计扩展</h2><p>测试用例在设计上除了考虑功能性质量属性，还需要对非功能性进行覆盖，推荐一个<strong>四字法</strong>进行设计。<br>    <strong>多：</strong>针对测试用例进行大数据量覆盖测试<br>    <strong>并：</strong>针对测试用例进行大数据量同时执行，验证并发下的测试结果<br>    <strong>复：</strong>重复的参数对同一用例进行执行测试。验证幂等结果是否符合预期。<br>    <strong>异：</strong>用非正常输入值进行用例测试。验证结果的正确性。</p>
<h3 id="测试策略"><a href="#测试策略" class="headerlink" title="测试策略"></a>测试策略</h3><p>策略其实考虑两个问题，过程和方法：“测什么”，“怎么测”。</p>
<ul>
<li>你的测试对象是什么？</li>
<li>本次测试的目标是什么？</li>
<li>测试中重点、难点、风险是什么？</li>
<li>测试要覆盖的深度和广度</li>
<li>如何安排各种测试计划（先测什么，再测什么，时间资源安排）</li>
<li>如何准出（测试结果）</li>
</ul>
<h2 id="测试策略可参考模版-amp-样例"><a href="#测试策略可参考模版-amp-样例" class="headerlink" title="测试策略可参考模版&amp;样例"></a>测试策略可参考模版&amp;样例</h2><hr>
<h3 id="1-业务整体概述"><a href="#1-业务整体概述" class="headerlink" title="1. 业务整体概述"></a>1. 业务整体概述</h3><h4 id="1-1-业务背景"><a href="#1-1-业务背景" class="headerlink" title="1.1 业务背景"></a>1.1 业务背景</h4><p>业务背景介绍若干字……</p>
<h4 id="1-2-产品目标"><a href="#1-2-产品目标" class="headerlink" title="1.2 产品目标"></a>1.2 产品目标</h4><p>产品目标介绍若干字……</p>
<h4 id="1-3-架构目标"><a href="#1-3-架构目标" class="headerlink" title="1.3 架构目标"></a>1.3 架构目标</h4><p>架构目标介绍若干字……</p>
<h4 id="1-4-业务目标"><a href="#1-4-业务目标" class="headerlink" title="1.4 业务目标"></a>1.4 业务目标</h4><p>业务目标介绍若干字……</p>
<h3 id="2-项目整体分析"><a href="#2-项目整体分析" class="headerlink" title="2. 项目整体分析"></a>2. 项目整体分析</h3><h4 id="2-1-功能性需求拆解"><a href="#2-1-功能性需求拆解" class="headerlink" title="2.1 功能性需求拆解"></a>2.1 功能性需求拆解</h4><p>核心业务模块介绍，复杂度，测试点分析对应列表（此步骤为关键分析步骤）。测试分析功能点，要从产品质量标准的角度思考，针对质量特性进行功能点覆盖。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td>需求名称1</td>
<td>需求说明1</td>
<td>使用场景1</td>
</tr>
<tr>
<td>需求名称2</td>
<td>需求说明2</td>
<td>使用场景2</td>
</tr>
</tbody></table>
<h4 id="2-2-测试覆盖范围（涉及针对哪些质量要求的测试方法）"><a href="#2-2-测试覆盖范围（涉及针对哪些质量要求的测试方法）" class="headerlink" title="2.2 测试覆盖范围（涉及针对哪些质量要求的测试方法）"></a>2.2 测试覆盖范围（涉及针对哪些质量要求的测试方法）</h4><p>功能性、性能效率、兼容性、易用性、可靠性、安全性、易维护性、可移植性</p>
<table>
<thead>
<tr>
<th>PRD需求</th>
<th>优先级</th>
<th>质量特性</th>
<th>测试覆盖度评估（深度和广度）</th>
<th>负责测试人员</th>
</tr>
</thead>
<tbody><tr>
<td>需求1</td>
<td>P1</td>
<td>功能性</td>
<td>59</td>
<td>xxx</td>
</tr>
<tr>
<td>需求1</td>
<td>P0</td>
<td>功能性，性能效率</td>
<td>33</td>
<td>xxxx</td>
</tr>
<tr>
<td>需求1</td>
<td>P2</td>
<td>安全性，功能性</td>
<td>11</td>
<td>yyyy</td>
</tr>
</tbody></table>
<h4 id="2-3-测试对设计方案覆盖范围（根据开发设计文档罗列）"><a href="#2-3-测试对设计方案覆盖范围（根据开发设计文档罗列）" class="headerlink" title="2.3 测试对设计方案覆盖范围（根据开发设计文档罗列）"></a>2.3 测试对设计方案覆盖范围（根据开发设计文档罗列）</h4><table>
<thead>
<tr>
<th>序号</th>
<th>接口/设计名称</th>
<th>接口描述</th>
<th>对应产品码/功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>com.xxx.api.getInfo</td>
<td>拿到信息</td>
<td>用户获取信息</td>
</tr>
<tr>
<td>2</td>
<td>com.xxx.api.getInfo</td>
<td>拿到信息</td>
<td>用户获取信息</td>
</tr>
</tbody></table>
<h3 id="3-业务流程分析"><a href="#3-业务流程分析" class="headerlink" title="3. 业务流程分析"></a>3. 业务流程分析</h3><h4 id="3-1-被测功能总体概述"><a href="#3-1-被测功能总体概述" class="headerlink" title="3.1 被测功能总体概述"></a>3.1 被测功能总体概述</h4><p>介绍若干字……</p>
<h4 id="3-2-整体业务流程"><a href="#3-2-整体业务流程" class="headerlink" title="3.2 整体业务流程"></a>3.2 整体业务流程</h4><p>介绍若干字</p>
<h4 id="3-3-业务模型图"><a href="#3-3-业务模型图" class="headerlink" title="3.3 业务模型图"></a>3.3 业务模型图</h4><p>介绍若干字</p>
<h4 id="3-4-风险分析"><a href="#3-4-风险分析" class="headerlink" title="3.4 风险分析"></a>3.4 风险分析</h4><p>介绍若干字</p>
<h3 id="4-测试场景覆盖范围"><a href="#4-测试场景覆盖范围" class="headerlink" title="4. 测试场景覆盖范围"></a>4. 测试场景覆盖范围</h3><h4 id="4-1-测试场景"><a href="#4-1-测试场景" class="headerlink" title="4.1 测试场景"></a>4.1 测试场景</h4><p>根据上一步的业务或者系统流程图，完成测试用例场景的设计</p>
<h4 id="4-2-测试用例设计（完善测试用例，补充测试数据）"><a href="#4-2-测试用例设计（完善测试用例，补充测试数据）" class="headerlink" title="4.2 测试用例设计（完善测试用例，补充测试数据）"></a>4.2 测试用例设计（完善测试用例，补充测试数据）</h4><p>根据测试场景细化测试用例，测试用例必须对测试场景和测试覆盖范围进行100%的覆盖</p>
<h4 id="4-3-测试数据要求"><a href="#4-3-测试数据要求" class="headerlink" title="4.3 测试数据要求"></a>4.3 测试数据要求</h4><p>介绍若干</p>
<h4 id="4-4-其他测试补充"><a href="#4-4-其他测试补充" class="headerlink" title="4.4 其他测试补充"></a>4.4 其他测试补充</h4><p>介绍若干</p>
<h3 id="5-测试执行计划"><a href="#5-测试执行计划" class="headerlink" title="5. 测试执行计划"></a>5. 测试执行计划</h3><p>这部分信息通常也会放在最前面。</p>
<h4 id="5-1-人员组织"><a href="#5-1-人员组织" class="headerlink" title="5.1 人员组织"></a>5.1 人员组织</h4><p>包括哪些人参与，测试边界等</p>
<h4 id="5-2-测试实施计划"><a href="#5-2-测试实施计划" class="headerlink" title="5.2 测试实施计划"></a>5.2 测试实施计划</h4><p>包括提测时间，联调时间等</p>
<h4 id="5-3-交付计划"><a href="#5-3-交付计划" class="headerlink" title="5.3 交付计划"></a>5.3 交付计划</h4><h2 id="主要是里程碑和大的时间点"><a href="#主要是里程碑和大的时间点" class="headerlink" title="主要是里程碑和大的时间点"></a>主要是里程碑和大的时间点</h2><h1 id="测试报告"><a href="#测试报告" class="headerlink" title="测试报告"></a>测试报告</h1><h2 id="测试报告-1"><a href="#测试报告-1" class="headerlink" title="测试报告"></a>测试报告</h2><p>测试报告实际就是一个质量评估的过程。内容的关键在于表达清晰两点：报告的对象是谁？报告的内容是什么？测试报告不是一个项目整体结束之后的产物，而是应该在项目整个生命周期随时同步的。<br>测试报告至少需要包括的信息：  </p>
<ul>
<li>项目背景信息</li>
<li>项目人员</li>
<li>测试覆盖度（需求、功能性、非功能性）</li>
<li>测试过程分析（执行情况）</li>
<li>缺陷分析</li>
<li>质量目标是否达到</li>
<li>遗留风险以及应对措施</li>
</ul>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>测试设计</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux上的特殊权限</title>
    <url>/2020/12/17/2020-12-17-Linux-Special-Rights/</url>
    <content><![CDATA[<p>特殊权限：SUID，SGID，STICKY</p>
<h1 id="安全上下文："><a href="#安全上下文：" class="headerlink" title="安全上下文："></a>安全上下文：</h1><p>1、进程以某用户的身份运行；进程是发起此进程用户的代理，因此以此用户的身份和权限完成此操作。<br>2、权限匹配模型：<br>(1)判断进程的属主，是否为被访问的文件属主；如果是，则应用属主的权限；否则检查访问控制列表的属主权限；再否则进入第2步；<br>(2)判断进程的属组，是否属于被访问的文件属组；如果是，则应用属组的权限；否则检查访问控制列表的属组权限；再否则进入第3步；<br>(3)使用Other权限。  </p>
<h1 id="1-SUID"><a href="#1-SUID" class="headerlink" title="1. SUID"></a>1. SUID</h1><p>默认情况下：用户发起的进程，进程的属主是属于发起者；因此，其以发起者的身份运行。<br><strong>功用：</strong>用户运行某程序时，如果此程序拥有SUID权限，那么程序运行为进程时，进程的属主不是发起者，而程序文件自己的属主。<br>管理文件的SUID权限：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod u+|-s FILE…</span><br></pre></td></tr></table></figure>
<p><strong>展示位置：</strong>属主的执行权限位；如果属主原本有执行权限，显示为小写s；否则显示为大写S。<br><strong>示例：</strong>  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ubuntu 用户查看/etc/shadow，提示无权限</span></span><br><span class="line">ubuntu@YAITZA:/$ ls -l /etc/shadow</span><br><span class="line">-rw-r----- 1 root shadow 929 Dec 17 15:42 /etc/shadow</span><br><span class="line">ubuntu@YAITZA:/$ cat /etc/shadow</span><br><span class="line">cat: /etc/shadow: Permission denied</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造新的cat程序，用ubuntu用户启动该进程，依旧提示无权限</span></span><br><span class="line">ubuntu@YAITZA:/$ sudo cp /bin/cat /tmp/cat</span><br><span class="line">ubuntu@YAITZA:/$ ls -l /tmp/cat</span><br><span class="line">-rwxr-xr-x 1 root root 35064 Dec 17 16:08 /tmp/cat</span><br><span class="line">ubuntu@YAITZA:/$ /tmp/cat /etc/shadow</span><br><span class="line">/tmp/cat: /etc/shadow: Permission denied</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给cat服务SUID权限，则使用/tmp/cat的进程属主权限查看/etc/shadown，则有权限</span></span><br><span class="line">ubuntu@YAITZA:/$ sudo chmod u+s /tmp/cat</span><br><span class="line">ubuntu@YAITZA:/$ ls -l /tmp/cat</span><br><span class="line">-rwsr-xr-x 1 root root 35064 Dec 17 16:08 /tmp/cat</span><br><span class="line">ubuntu@YAITZA:/$ /tmp/cat /etc/shadow</span><br><span class="line">root:*:17737:0:99999:7:::</span><br><span class="line">daemon:*:17737:0:99999:7:::</span><br></pre></td></tr></table></figure>

<h1 id="2-SGID"><a href="#2-SGID" class="headerlink" title="2. SGID"></a>2. SGID</h1><p><strong>功用：</strong>当目录属组有写权限，且有SGID权限时，那么所有属于此目录的属组，且以属组身份在此目录中新建文件或目录时，新文件的属组不是用户的基本组，而是此目录的属组。<br>管理文件的SGID权限：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod g+|-s FILE…</span><br></pre></td></tr></table></figure>
<p><strong>展示位置：</strong>属组的执行权限位；如果属组原本有执行权限，显示为小写s；否则显示为大写S。<br><strong>示例：</strong>  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建用户centos，fedora；并附加组为mygrp</span></span><br><span class="line">ubuntu@YAITZA:/var/tmp$ id centos</span><br><span class="line">uid=1001(centos) gid=1002(centos) groups=1002(centos),1001(mygrp)</span><br><span class="line">ubuntu@YAITZA:/var/tmp$ id fedora</span><br><span class="line">uid=1002(fedora) gid=1003(fedora) groups=1003(fedora),1001(mygrp)</span><br><span class="line">ubuntu@YAITZA:/var/tmp$ ls -l</span><br><span class="line">total 0</span><br><span class="line">-rw-rw-r-- 1 root mygrp 0 Dec 17 16:54 <span class="built_in">test</span></span><br><span class="line"><span class="comment"># test目录下对应用户创建文件，文件权限为对应的属主和属组</span></span><br><span class="line">root@YAITZA:/var/tmp<span class="comment"># ls -l</span></span><br><span class="line">total 0</span><br><span class="line">drwxrwxr-x 1 root mygrp 4096 Dec 17 16:58 <span class="built_in">test</span></span><br><span class="line">centos@YAITZA:/var/tmp/<span class="built_in">test</span>$ touch a.centos</span><br><span class="line">fedora@YAITZA:/var/tmp/<span class="built_in">test</span>$ touch a.fedora</span><br><span class="line">ubuntu@YAITZA:/var/tmp/<span class="built_in">test</span>$ ll</span><br><span class="line">total 0</span><br><span class="line">drwxrwxr-x 1 root   mygrp  4096 Dec 17 17:00 ./</span><br><span class="line">drwxrwxrwt 1 root   root   4096 Dec 17 16:58 ../</span><br><span class="line">-rw-rw-r-- 1 centos centos    0 Dec 17 17:00 a.centos</span><br><span class="line">-rw-rw-r-- 1 fedora fedora    0 Dec 17 16:59 a.fedora</span><br><span class="line"><span class="comment"># 赋予test目录属组SGID权限</span></span><br><span class="line">ubuntu@YAITZA:/var/tmp$ sudo chmod g+s <span class="built_in">test</span>/</span><br><span class="line">ubuntu@YAITZA:/var/tmp$ ls -l</span><br><span class="line">total 0</span><br><span class="line">drwxrwsr-x 1 root mygrp 4096 Dec 17 17:00 <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 则centos，fedora用户创建的文件，属主为自己，属组为test的属组</span></span><br><span class="line">ubuntu@YAITZA:/var/tmp/<span class="built_in">test</span>$ ls -l</span><br><span class="line">total 0</span><br><span class="line">-rw-rw-r-- 1 centos centos 0 Dec 17 17:00 a.centos</span><br><span class="line">-rw-rw-r-- 1 fedora fedora 0 Dec 17 16:59 a.fedora</span><br><span class="line">-rw-rw-r-- 1 centos mygrp  0 Dec 17 17:03 b.centos</span><br><span class="line">-rw-rw-r-- 1 fedora mygrp  0 Dec 17 17:03 b.fedora</span><br></pre></td></tr></table></figure>

<h1 id="3-STICKY"><a href="#3-STICKY" class="headerlink" title="3. STICKY"></a>3. STICKY</h1><p><strong>功用：</strong>对于属组或全局可写的目录，组内的所有用户或系统上的所有用户对此目录中都能创建新文件或删除所有的已有文件；如果为此目录设置STICKY权限，则每个用户能创建新文件，且只能删除自己的文件。<br>管理文件的SGID权限：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod o+|-t FILE…</span><br></pre></td></tr></table></figure>
<p><strong>展示位置：</strong>其他的执行权限位；如果其他原本有执行权限，显示为小写t；否则显示为大写T。<br><strong>示例：</strong> </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ubuntu@YAITZA:/var/tmp$ mkdir <span class="built_in">test</span></span><br><span class="line">ubuntu@YAITZA:/var/tmp$ ll</span><br><span class="line">total 0</span><br><span class="line">drwxrwxrwt 1 root   root   4096 Dec 17 17:13 ./</span><br><span class="line">drwxr-xr-x 1 root   root   4096 Jul 25  2018 ../</span><br><span class="line">drwxrwxr-x 1 ubuntu ubuntu 4096 Dec 17 17:13 <span class="built_in">test</span>/</span><br><span class="line">ubuntu@YAITZA:/var/tmp$ ll</span><br><span class="line">total 0</span><br><span class="line">drwxrwxrwt 1 root   root   4096 Dec 17 17:13 ./</span><br><span class="line">drwxr-xr-x 1 root   root   4096 Jul 25  2018 ../</span><br><span class="line">drwxrwxrwt 1 ubuntu ubuntu 4096 Dec 17 17:18 <span class="built_in">test</span>/</span><br><span class="line">centos@YAITZA:/var/tmp/<span class="built_in">test</span>$ ls -l</span><br><span class="line">total 0</span><br><span class="line">-rw-rw-r-- 1 centos mygrp 0 Dec 17 17:14 a.centos</span><br><span class="line">-rw-rw-r-- 1 fedora mygrp 0 Dec 17 17:15 a.fedora</span><br><span class="line"><span class="comment"># test文件其他赋予STICKY权限后，fedora用户删除centos创建的文件，提示无权限</span></span><br><span class="line">fedora@YAITZA:/var/tmp/<span class="built_in">test</span>$ rm a.centos</span><br><span class="line">rm: cannot remove <span class="string">'a.centos'</span>: Operation not permitted</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 系统上的/tmp和/var/tmp目录默认均有sticky权限。<br>管理特殊权限的另一方式：  </p>
<table>
<thead>
<tr>
<th>SUID</th>
<th>SGID</th>
<th>STICKY</th>
<th>八进制权限</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>4</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>5</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>6</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>7</td>
</tr>
</tbody></table>
<p>基于八进制方式赋权时，可与默认的三位八进制数字左侧再加一位八进制数字。<br>例如：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod 1777 FILE…</span><br></pre></td></tr></table></figure>

<h1 id="4-facl：file-access-control-lists"><a href="#4-facl：file-access-control-lists" class="headerlink" title="4. facl：file access control lists"></a>4. facl：file access control lists</h1><h2 id="4-1-文件的额外赋权机制"><a href="#4-1-文件的额外赋权机制" class="headerlink" title="4.1 文件的额外赋权机制"></a>4.1 文件的额外赋权机制</h2><p>在原有的u，g，o外，另一层让普通用户能控制赋权给另外的用户或组的赋权机制。 </p>
<h2 id="4-2-getfacl命令"><a href="#4-2-getfacl命令" class="headerlink" title="4.2 getfacl命令"></a>4.2 getfacl命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">getfacl FILE…</span><br></pre></td></tr></table></figure>
<h2 id="4-3-setfacl命令"><a href="#4-3-setfacl命令" class="headerlink" title="4.3 setfacl命令"></a>4.3 setfacl命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#赋权给用户</span></span><br><span class="line">setfacl -m u:USERNAME:MODE FILE…</span><br><span class="line"><span class="comment">#赋权给组：</span></span><br><span class="line">setfacl -m g:GROUPNAME:MODE FILE…</span><br><span class="line"></span><br><span class="line"><span class="comment">#撤销赋权给用户:</span></span><br><span class="line">setfacl -x u:USERNAME:MODE FILE…</span><br><span class="line"><span class="comment">#撤销赋权给组：</span></span><br><span class="line">setfacl -x g:GROUPNAME:MODE FILE…</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux上的文件名通配</title>
    <url>/2020/12/25/2020-12-17-Linux-Glob/</url>
    <content><![CDATA[<h1 id="1-glob：文件名通配"><a href="#1-glob：文件名通配" class="headerlink" title="1. glob：文件名通配"></a>1. glob：文件名通配</h1><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">匹配模式：元字符；详细说明请参见Linux官方说明问题；命令：man glob。</span><br></pre></td></tr></table></figure>
<h2 id="1-1-任意字符匹配"><a href="#1-1-任意字符匹配" class="headerlink" title="1.1. 任意字符匹配"></a>1.1. 任意字符匹配</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">*：匹配任意长度的任意字符</span><br></pre></td></tr></table></figure>
<h2 id="1-2-任意单个字符匹配"><a href="#1-2-任意单个字符匹配" class="headerlink" title="1.2. 任意单个字符匹配"></a>1.2. 任意单个字符匹配</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">?：匹配任意单个字符</span><br></pre></td></tr></table></figure>
<h2 id="1-3-指定范围内的任意单个字符"><a href="#1-3-指定范围内的任意单个字符" class="headerlink" title="1.3. 指定范围内的任意单个字符"></a>1.3. 指定范围内的任意单个字符</h2><pre><code>[]：匹配指定范围内的任意单个字符</code></pre><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">有几种特殊格式：</span><br><span class="line"><span class="bullet">- </span>[a-z]</span><br><span class="line"><span class="bullet">- </span>[A-Z]</span><br><span class="line"><span class="bullet">- </span>[0-9]</span><br><span class="line"><span class="bullet">- </span>[a-z0-9]</span><br><span class="line"><span class="bullet">- </span>[[:upper::]]：所有大写字符</span><br><span class="line"><span class="bullet">- </span>[[:lower:]]：所有小写字符</span><br><span class="line"><span class="bullet">- </span>[[:alpha:]]：所有字母</span><br><span class="line"><span class="bullet">- </span>[[:digit:]]：所有数字</span><br><span class="line"><span class="bullet">- </span>[[:alnum:]]：所有字母和数字，This is equivalent to A-Za-z0-9.</span><br><span class="line"><span class="bullet">- </span>[[:space:]]：所有空白字符</span><br><span class="line"><span class="bullet">- </span>[[:blank:]]：所有空白或tab</span><br><span class="line"><span class="bullet">- </span>[[:punct::]]：所有标点符号</span><br><span class="line"><span class="bullet">- </span>[[:xdigit:]]：所有十六进制，This is equivalent to 0-9A-Fa-f.</span><br><span class="line"><span class="bullet">- </span>[[:print:]]：可打印字符，Matches characters in the range of ASCII 32 - 126. This is the same as [:graph:], above, but adding the space character.</span><br><span class="line"><span class="bullet">- </span>[:graph:] (graphic printable characters). Matches characters in the range of ASCII 33 - 126. This is the same as [:print:], below, but excluding the space character.</span><br></pre></td></tr></table></figure>
<h2 id="1-4-指定范围外的任意单个字符"><a href="#1-4-指定范围外的任意单个字符" class="headerlink" title="1.4. 指定范围外的任意单个字符"></a>1.4. 指定范围外的任意单个字符</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[^]或[!]：匹配指定范围外的任意单个字符</span><br></pre></td></tr></table></figure>
<h2 id="1-5-匹配指定的模式"><a href="#1-5-匹配指定的模式" class="headerlink" title="1.5. 匹配指定的模式"></a>1.5. 匹配指定的模式</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;…&#125;：匹配大括号里面的所有模式，模式之间使用逗号分隔</span><br></pre></td></tr></table></figure>
<h2 id="1-6-连续字符匹配"><a href="#1-6-连续字符匹配" class="headerlink" title="1.6. 连续字符匹配"></a>1.6. 连续字符匹配</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;start…end&#125;：匹配连续范围的字符</span><br></pre></td></tr></table></figure>

<h1 id="2-练习："><a href="#2-练习：" class="headerlink" title="2. 练习："></a>2. 练习：</h1><h2 id="2-1-显示-var目录所有以1开头，以小写字母结尾，且中间出现一位任意字符的文件或目录"><a href="#2-1-显示-var目录所有以1开头，以小写字母结尾，且中间出现一位任意字符的文件或目录" class="headerlink" title="2.1. 显示/var目录所有以1开头，以小写字母结尾，且中间出现一位任意字符的文件或目录"></a>2.1. 显示/var目录所有以1开头，以小写字母结尾，且中间出现一位任意字符的文件或目录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ubuntu@YAITZA:~$ ls -d /var/l?[a-z]</span><br><span class="line">/var/lib  /var/<span class="built_in">log</span></span><br><span class="line">ubuntu@YAITZA:~$ ls -d /var/l?[[:lower:]]</span><br><span class="line">/var/lib  /var/<span class="built_in">log</span></span><br></pre></td></tr></table></figure>
<h2 id="2-2-显示-etc目录下，以任意一位数字开头，且以非数字结尾的文件或目录"><a href="#2-2-显示-etc目录下，以任意一位数字开头，且以非数字结尾的文件或目录" class="headerlink" title="2.2. 显示/etc目录下，以任意一位数字开头，且以非数字结尾的文件或目录"></a>2.2. 显示/etc目录下，以任意一位数字开头，且以非数字结尾的文件或目录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls -d /etc/[0-9]*[^0-9]</span><br><span class="line">ls -d /etc/[[:digit:]]*[^[:digit]]</span><br></pre></td></tr></table></figure>
<h2 id="2-3-显示-etc目录下，以非字母开头，后面跟一个字母及其它任意长度任意字符的文件或目录"><a href="#2-3-显示-etc目录下，以非字母开头，后面跟一个字母及其它任意长度任意字符的文件或目录" class="headerlink" title="2.3. 显示/etc目录下，以非字母开头，后面跟一个字母及其它任意长度任意字符的文件或目录"></a>2.3. 显示/etc目录下，以非字母开头，后面跟一个字母及其它任意长度任意字符的文件或目录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls -d /etc/[^[:alpha:]][[:alpha:]]*</span><br><span class="line">ubuntu@YAITZA:/tmp$ ls -d [^[:alpha:]][[:alpha:]]*</span><br><span class="line">3aHHH</span><br><span class="line">ls -d /etc/[^a-z][a-z]*</span><br><span class="line">ubuntu@YAITZA:/tmp$ ls -d [^a-z][a-z]*</span><br><span class="line">3aHHH  AaJJ</span><br></pre></td></tr></table></figure>
<h2 id="2-4-复制-etc目录下，所有以m开头，以非数字结尾的文件或目录至-tmp-test目录"><a href="#2-4-复制-etc目录下，所有以m开头，以非数字结尾的文件或目录至-tmp-test目录" class="headerlink" title="2.4. 复制/etc目录下，所有以m开头，以非数字结尾的文件或目录至/tmp/test目录"></a>2.4. 复制/etc目录下，所有以m开头，以非数字结尾的文件或目录至/tmp/test目录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp -r /etc/m*[^0-9] /tmp/<span class="built_in">test</span></span><br><span class="line">cp -r /etc/m*[^[:digit:]] /tmp/<span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<h2 id="2-5-复制-usr-share-man目录下，所有以man开头，后跟一个数字结尾的文件或目录至-tmp-man-目录下"><a href="#2-5-复制-usr-share-man目录下，所有以man开头，后跟一个数字结尾的文件或目录至-tmp-man-目录下" class="headerlink" title="2.5. 复制/usr/share/man目录下，所有以man开头，后跟一个数字结尾的文件或目录至/tmp/man/目录下"></a>2.5. 复制/usr/share/man目录下，所有以man开头，后跟一个数字结尾的文件或目录至/tmp/man/目录下</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp -r /usr/share/man/man[0-9] /tmp/man</span><br><span class="line">cp -r /usr/share/man/man[[:digit:]] /tmp/man</span><br></pre></td></tr></table></figure>
<h2 id="2-6-复制-etc目录下，所有以-conf结尾，且以m-n-r-p开头的文件或目录至-tmp-conf-d目录下"><a href="#2-6-复制-etc目录下，所有以-conf结尾，且以m-n-r-p开头的文件或目录至-tmp-conf-d目录下" class="headerlink" title="2.6. 复制/etc目录下，所有以.conf结尾，且以m,n,r,p开头的文件或目录至/tmp/conf.d目录下"></a>2.6. 复制/etc目录下，所有以.conf结尾，且以m,n,r,p开头的文件或目录至/tmp/conf.d目录下</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp -r /etc/[mnrp]*.conf /tmp/conf.d</span><br><span class="line">cp -r /etc/&#123;m,n,r,p&#125;*.conf /tmp/conf.d</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>稻香</title>
    <url>/2021/06/10/2021-06-10-Rice-Fragrant/</url>
    <content><![CDATA[<center>
这个世界如果你有太多的抱怨，跌倒了

<p>就不敢继续往前走，为什么</p>
<p>人要这么的脆弱，堕落</p>
<p>请你打开电视看看，多少人为生命在努力勇敢的走下去</p>
<p>我们是不是该知足，珍惜一切就算没有拥有</p>
<p>还记得，你说家是唯一的城堡</p>
<p>随着稻香河流继续奔跑，微微笑</p>
<p>小时候的梦我知道，不要哭</p>
<p>让萤火虫带着你逃跑，乡间的歌谣</p>
<p>永远的依靠，回家吧</p>
<p>回到最初的美好，不要这么容易</p>
<p>就想放弃，就像我说的</p>
<p>追不到的梦想，换个梦不就得了</p>
<p>为自己的人生鲜艳上色，先把爱涂上喜欢的颜色</p>
<p>笑一个吧，功成名就不是目的</p>
<p>让自己快乐快乐，这才叫做意义</p>
<p>童年的纸飞机，现在终于飞回我手里</p>
<p>所谓的那快乐，赤脚在田里追蜻蜓</p>
<p>追到累了，偷摘水果被蜜蜂给</p>
<p>叮到怕了，谁在偷笑呢</p>
<p>我靠着稻草人，吹着风</p>
<p>唱着歌，睡着了</p>
<p>哦，哦</p>
<p>午后吉它在虫鸣中更清脆，哦</p>
<p>哦，阳光洒在路上不怕心碎</p>
<p>珍惜，一切就算没有拥有</p>
<p>还记得，你说家是唯一的城堡</p>
<p>随着稻香河流继续奔跑，微微笑</p>
<p>小时候的梦我知道，不要哭</p>
<p>让萤火虫带着你逃跑，乡间的歌谣永远的依靠</p>
<p>回家吧，回到最初的美好</p>
<p>还记得，你说家是唯一的城堡</p>
<p>随着稻香河流继续奔跑，微微笑</p>
<p>小时候的梦我知道，不要哭</p>
<p>让萤火虫带着你逃跑，乡间的歌谣</p>
<p>永远的依靠，回家吧</p>
<p>回到最初的美好</p>
</center>

<p>第一次听到这首哥的时候我还在上高二，那是一个午后；同寝的同学当时很迷周杰伦，出了新专辑；买了一盘正版的磁带坐在床头，放着这首歌曲。</p>
<p>第一次听到说不上来喜欢也说不上来不喜欢，当时至少不难听。由于歌词不仔细听不大清楚，从未去细究过它的歌词，最多也就哼一下而已。</p>
<p>可是，在送女儿去上补习班的车上；女儿非常喜欢唱这首歌，反复的播放；总算听清楚了整首歌的歌词，一时间竟感触良多。</p>
<p>初听不识曲中意，再听深谙曲中情。</p>
<p>童年的纸飞机，何时飞回我手里！！！</p>
<p><img src="https://raw.githubusercontent.com/yaitza/yaitza.github.io/master/images/images/Article/2021-06-10-Rice-Fragrant.png" alt="fly"></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
